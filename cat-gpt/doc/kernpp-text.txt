INFO: START:
  This is a project that I worked on a long time ago.  It is intended to be the
  start of a freestanding implementation of a library.  I have not messed with
  it in quite a while.

  Could you look it over, see if you see where I am going with it, and give your
  opinion on what about is is good, bad, or ugly?

  Still needs lots of work on mem management and exception handling ....

  But I like the "no c" motif ...

  Also, I am curious how well the file format here works for you.  I wanted
  something human readable, but also unambiguous.

  I added the periods because nl does not number blank lins.

  Thanks in advance.

INFO: END:
FILE: START: .clang-format
HASH: MD5: 6c5eabc35965c3f4f1e06ba2aa9653f9
     1	. ---
     2	. Language:        Cpp
     3	. AccessModifierOffset: -2
     4	. AlignAfterOpenBracket: Align
     5	. AlignConsecutiveMacros: true
     6	. AlignConsecutiveAssignments: true
     7	. AlignConsecutiveDeclarations: true
     8	. AlignEscapedNewlines: Right
     9	. AlignOperands:   true
    10	. AlignTrailingComments: true
    11	. AllowAllArgumentsOnNextLine: true
    12	. AllowAllConstructorInitializersOnNextLine: true
    13	. AllowAllParametersOfDeclarationOnNextLine: true
    14	. AllowShortBlocksOnASingleLine: false
    15	. AllowShortCaseLabelsOnASingleLine: false
    16	. AllowShortFunctionsOnASingleLine: false
    17	. AllowShortLambdasOnASingleLine: All
    18	. AllowShortIfStatementsOnASingleLine: Never
    19	. AllowShortLoopsOnASingleLine: false
    20	. AlwaysBreakAfterDefinitionReturnType: None
    21	. AlwaysBreakAfterReturnType: None
    22	. AlwaysBreakBeforeMultilineStrings: true
    23	. AlwaysBreakTemplateDeclarations: Yes
    24	. BinPackArguments: false
    25	. BinPackParameters: false
    26	. BraceWrapping:
    27	.   AfterCaseLabel:  false
    28	.   AfterClass:      true
    29	.   AfterControlStatement: false
    30	.   AfterEnum:       true
    31	.   AfterFunction:   true
    32	.   AfterNamespace:  true
    33	.   AfterObjCDeclaration: false
    34	.   AfterStruct:     true
    35	.   AfterUnion:      true
    36	.   AfterExternBlock: true
    37	.   BeforeCatch:     false
    38	.   BeforeElse:      true
    39	.   IndentBraces:    false
    40	.   SplitEmptyFunction: true
    41	.   SplitEmptyRecord: true
    42	.   SplitEmptyNamespace: true
    43	. BreakBeforeBinaryOperators: None
    44	. BreakBeforeBraces: Allman
    45	. BreakBeforeInheritanceComma: false
    46	. BreakInheritanceList: BeforeComma
    47	. BreakBeforeTernaryOperators: true
    48	. BreakConstructorInitializersBeforeComma: false
    49	. BreakConstructorInitializers: BeforeComma
    50	. BreakAfterJavaFieldAnnotations: false
    51	. BreakStringLiterals: true
    52	. ColumnLimit:     75
    53	. CommentPragmas:  '^ IWYU pragma:'
    54	. CompactNamespaces: false
    55	. ConstructorInitializerAllOnOneLineOrOnePerLine: false
    56	. ConstructorInitializerIndentWidth: 4
    57	. ContinuationIndentWidth: 9
    58	. Cpp11BracedListStyle: false
    59	. DerivePointerAlignment: false
    60	. DisableFormat:   false
    61	. ExperimentalAutoDetectBinPacking: false
    62	. FixNamespaceComments: true
    63	. ForEachMacros:
    64	.   - foreach
    65	.   - Q_FOREACH
    66	.   - BOOST_FOREACH
    67	. IncludeBlocks:   Preserve
    68	. IncludeCategories:
    69	.   - Regex:           '^"(llvm|llvm-c|clang|clang-c)/'
    70	.     Priority:        2
    71	.   - Regex:           '^(<|"(gtest|gmock|isl|json)/)'
    72	.     Priority:        3
    73	.   - Regex:           '.*'
    74	.     Priority:        1
    75	. IncludeIsMainRegex: '(Test)?$'
    76	. IndentCaseLabels: true
    77	. IndentPPDirectives: None
    78	. IndentWidth:     2
    79	. IndentWrappedFunctionNames: true
    80	. JavaScriptQuotes: Leave
    81	. JavaScriptWrapImports: true
    82	. KeepEmptyLinesAtTheStartOfBlocks: true
    83	. MacroBlockBegin: ''
    84	. MacroBlockEnd:   ''
    85	. MaxEmptyLinesToKeep: 2
    86	. NamespaceIndentation: All
    87	. ObjCBinPackProtocolList: Auto
    88	. ObjCBlockIndentWidth: 2
    89	. ObjCSpaceAfterProperty: true
    90	. ObjCSpaceBeforeProtocolList: false
    91	. PenaltyBreakAssignment: 2
    92	. PenaltyBreakBeforeFirstCallParameter: 19
    93	. PenaltyBreakComment: 300
    94	. PenaltyBreakFirstLessLess: 120
    95	. PenaltyBreakString: 1000
    96	. PenaltyBreakTemplateDeclaration: 10
    97	. PenaltyExcessCharacter: 1000000
    98	. PenaltyReturnTypeOnItsOwnLine: 200
    99	. PointerAlignment: Left
   100	. ReflowComments:  true
   101	. SortIncludes:    true
   102	. SortUsingDeclarations: true
   103	. SpaceAfterCStyleCast: false
   104	. SpaceAfterLogicalNot: false
   105	. SpaceAfterTemplateKeyword: true
   106	. SpaceBeforeAssignmentOperators: false
   107	. SpaceBeforeCpp11BracedList: false
   108	. SpaceBeforeCtorInitializerColon: true
   109	. SpaceBeforeInheritanceColon: true
   110	. SpaceBeforeParens: false
   111	. SpaceBeforeRangeBasedForLoopColon: true
   112	. SpaceInEmptyParentheses: false
   113	. SpacesBeforeTrailingComments: 1
   114	. SpacesInAngles:  false
   115	. SpacesInContainerLiterals: true
   116	. SpacesInCStyleCastParentheses: false
   117	. SpacesInParentheses: false
   118	. SpacesInSquareBrackets: false
   119	. Standard:        Cpp11
   120	. StatementMacros:
   121	.   - Q_UNUSED
   122	.   - QT_REQUIRE_VERSION
   123	. TabWidth:        8
   124	. UseTab:          Never
   125	. ...
   126	. 
FILE: END: .clang-format
FILE: START: .gitignore
HASH: MD5: 9eea8f583429c3f9d415a57858672849
     1	. bin/markout
     2	. **.d
     3	. **.[os]
     4	. **.ii
     5	. **.a
     6	. log/
     7	. *.out
     8	. bin/report
     9	. bin/string_view
    10	. output
    11	. tags
    12	. trace
    13	. .gdb_history
    14	. core.*
    15	. out
    16	. fuck
    17	. 
    18	. *.oo
    19	. *.aa
FILE: END: .gitignore
FILE: START: LICENSE
HASH: MD5: b9920a9188e67c7f680f61db05f525f4
     1	. MIT License
     2	. 
     3	. Copyright (c) 2019 Nobody
     4	. 
     5	. Permission is hereby granted, free of charge, to any person obtaining a copy
     6	. of this software and associated documentation files (the "Software"), to deal
     7	. in the Software without restriction, including without limitation the rights
     8	. to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     9	. copies of the Software, and to permit persons to whom the Software is
    10	. furnished to do so, subject to the following conditions:
    11	. 
    12	. The above copyright notice and this permission notice shall be included in all
    13	. copies or substantial portions of the Software.
    14	. 
    15	. THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    16	. IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    17	. FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    18	. AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    19	. LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    20	. OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    21	. SOFTWARE.
FILE: END: LICENSE
FILE: START: Makefile
HASH: MD5: ac399ad3458c8ee5a9a646325a577556
     1	. MAKEFLAGS:= -rR -j24
     2	. .EXPORT_ALL_VARIABLED:
     3	. all:
     4	. 
     5	. bin/src:= $(wildcard bin/*.cc)
     6	. bin/exe:= $(patsubst %.cc,%,     $(bin/src))
     7	. bin/asm:= $(wildcard bin/*.S)
     8	. bin/xxx:= $(patsubst %.S,%.oo,$(bin/asm))
     9	. bin/exe+= $(patsubst %.S,%,      $(bin/asm))
    10	. bin/obj:= $(patsubst %.cc,%.oo,  $(bin/src))
    11	. bin/cpp:= $(patsubst %.cc,%.ii,  $(bin/src))
    12	. bin/dep:= $(patsubst %,%.d,$(bin/obj) $(bin/cpp))
    13	. bin:=$(bin/exe)
    14	. 
    15	. lib/src:= $(wildcard lib/*.cc)
    16	. lib/lib:= lib/libkpp.aa
    17	. lib/asm:= $(wildcard lib/*.S)
    18	. lib/xxx:= $(patsubst %.S,%.oo, $(lib/asm))
    19	. lib/obj:= $(patsubst %.cc,%.oo,  $(lib/src))
    20	. lib/cpp:= $(patsubst %.cc,%.ii,  $(lib/src))
    21	. lib/dep:= $(patsubst %.cc,%.oo.d,$(lib/src))
    22	. lib/dep:= $(patsubst %.cc,%.ii.d,$(lib/src))
    23	. lib:=$(lib/lib)
    24	. 
    25	. all/obj:= $(lib/obj) $(bin/obj)
    26	. all/xxx:= $(lib/xxx) $(bin/xxx)
    27	. all/cpp:= $(lib/cpp) $(bin/cpp)
    28	. all/src:= $(lib/src) $(bin/src)
    29	. all/dep:= $(lib/dep) $(bin/dep)
    30	. 
    31	. include /dev/null $(wildcard $(all/dep))
    32	. 
    33	. ext/obj:= $(filter-out $(all/obj), $(wildcard *.oo))
    34	. ext/xxx:= $(filter-out $(all/xxx), $(wildcard *.oo))
    35	. 
    36	. all:= $(bin/exe) $(lib/lib)
    37	. bin:= $(bin/exe)
    38	. lib:= $(lib/lib)
    39	. $(bin): $(lib)
    40	. all: $(all)
    41	. 
    42	. include /dev/null $(wildcard $(all/dep))
    43	. 
    44	. $(lib/lib): $(lib/obj) $(lib/xxx)
    45	. 	sbin/arch "$@" $(lib/obj) $(lib/xxx)
    46	. 
    47	. $(bin/exe): %: %.oo sbin/link etc/ld_flags
    48	. 	sbin/link "$@" $(lib/lib)
    49	. 
    50	. $(all/cpp): %.ii: %.cc sbin/prec etc/cppflags
    51	. 	rm -f $*.ii $*.oo
    52	. 	sbin/prec "$@"
    53	. 
    54	. $(all/xxx): %.oo: %.S sbin/casm etc/asmflags
    55	. 	sbin/casm "$@"
    56	. 
    57	. $(all/obj): %.oo: %.ii sbin/comp etc/cxxflags
    58	. 	sbin/comp "$@"
    59	. 
    60	. cur/dep:=$(wildcard *.oo.d)
    61	. cur/obj:=$(wildcard *.oo) $(patsubst %.d,%,$(cur/dep))
    62	. cur/src:=$(patsubst %.oo,%.cc,$(cur/obj))
    63	. 
    64	. 
    65	. ifneq ($(have),$(want))
    66	. $(lib/lib): rem-lib
    67	. endif
    68	. 
    69	. ###   
    70	. clean: date:=$(shell serdate)
    71	. 
    72	. clean:
    73	. 	rm -f */*.[ioa][ioa]
    74	. 
    75	. $(all/obj): sbin/comp
    76	. $(bin/exe): sbin/link
    77	. $(lib/lib): sbin/arch
    78	. $(bin/exe): $(lib)
    79	. 
    80	. tags: */*.cc */*.hh
    81	. 	ctags --language-force=c++ */*.cc */*.hh
    82	. 
    83	. nm:
    84	. 	nm */*.aa */*.oo --defined-only -A --demangle
FILE: END: Makefile
FILE: START: README.md
HASH: MD5: d2995bc6650a11f5a1a52643fb11f5d1
     1	. # kernpp
     2	. A c++ library that runs right on top of the Linux kernel.
     3	. 
     4	. First, let's be clear, I'm doing this on a lark.  I don't know if it
     5	. will be useful to me or to anyone long term.  I am experimenting on some
     6	. ideas for c++ code without the huge libc baggage.  I would like to try
     7	. some different things, and I figure I might as well do it publicly.
     8	. I appreciate suggestions, but this is my project to fuck around.
     9	. I might not do it the right way because I am interested in discovering
    10	. the characteristics of the wrongness produced by doing it the wrong way.
FILE: END: README.md
FILE: START: bin/.gitignore
HASH: MD5: 580550bf479c4d9fccebb68a002beb9d
     1	. cat
     2	. echo
     3	. false
     4	. fmt
     5	. ls
     6	. markout
     7	. true
     8	. usleep
FILE: END: bin/.gitignore
FILE: START: bin/cat.cc
HASH: MD5: 5f9a2c6725807f10277144469dfb5b9c
     1	. #include <fmt.hh>
     2	. #include <syscall.hh>
     3	. #include <getopt.hh>
     4	. 
     5	. using namespace fmt;
     6	. void fatal(const char* message, size_t len)
     7	. {
     8	.   if(len < 0)
     9	.     len= strlen(message);
    10	.   write(2, message, len);
    11	.   exit(1);
    12	. }
    13	. void fatal(const char* message)
    14	. {
    15	.   fatal(message, strlen(message));
    16	. }
    17	. template <size_t size_>
    18	. struct sbuf_t
    19	. {
    20	.   enum
    21	.   {
    22	.     size= size_
    23	.   };
    24	.   char  buf[size - 1];
    25	.   char  end[1];
    26	.   char* b()
    27	.   {
    28	.     return buf;
    29	.   };
    30	.   char* e()
    31	.   {
    32	.     return end;
    33	.   };
    34	. };
    35	. static sbuf_t<1024 * 10> buf;
    36	. using namespace sys;
    37	. bool catfile(int ifd, int ofd)
    38	. {
    39	.   while(true)
    40	.   {
    41	.     size_t rres= read(ifd, buf.buf, sizeof(buf.buf));
    42	.     if(rres == 0)
    43	.       return true;
    44	.     if(rres < 0)
    45	.       fatal(L("read error\n"));
    46	.     size_t wres= full_write(ofd, buf.buf, rres);
    47	.     if(wres != rres)
    48	.       fatal(L("write error\n"));
    49	.   };
    50	. };
    51	. 
    52	. extern "C" {
    53	.   int main(int argc, char**argv,char **envp);
    54	. };
    55	. template<typename val_t>
    56	. struct vector
    57	. {
    58	.   val_t *arr;
    59	.   size_t len;
    60	.   vector()
    61	.     : arr(nullptr), len(0)
    62	.   {
    63	.   };
    64	.   vector(val_t *beg, val_t *end)
    65	.     : arr(beg), len(end-beg)
    66	.   {
    67	.   };
    68	.   val_t &operator[](size_t n)
    69	.   {
    70	.     assert(n<size());
    71	.     return arr[n];
    72	.   };
    73	.   const val_t &operator[](size_t n) const
    74	.   {
    75	.     assert(n<size());
    76	.     return arr[n];
    77	.   };
    78	.   size_t size() const {
    79	.     return  len;
    80	.   };
    81	.   const val_t *begin() const {
    82	.     return arr;
    83	.   };
    84	.   const val_t *end() const {
    85	.     return arr+len;
    86	.   };
    87	.   val_t *begin() {
    88	.     return arr;
    89	.   };
    90	.   val_t *end() {
    91	.     return arr+len;
    92	.   };
    93	. };
    94	. const char *program_name=nullptr;
    95	. struct opts_t
    96	. {
    97	.   int num;
    98	.   int empty;
    99	.   int show_non;
   100	.   int show_tab;
   101	.   int show_end;
   102	.   opts_t()
   103	.     : num(0), empty(0), show_non(0), show_tab(0), show_end(0)
   104	.   {
   105	.   };
   106	. 
   107	. } opts;
   108	. 
   109	. static struct option long_options[] = {
   110	.   { "number", no_argument, 0, 'n' },
   111	.   { "number-non-empty", no_argument, 0, 'b' },
   112	.   { "show-nonprinting", no_argument, 0, 'v' },
   113	.   { "show-tabs", no_argument, 0, 't' },
   114	.   { "show-ends", no_argument, 0, 'e' },
   115	.   { "show-all", no_argument, 0, 'A' },
   116	.   { 0, 0, 0, 0 },
   117	. };
   118	. int main(int argc, char** argv,char**envp)
   119	. {
   120	.   int c;
   121	.   c_str names[argc];
   122	.   int nnames=0;
   123	.   while(1)
   124	.   {
   125	.     int this_option_intind = optind ? optind: 1;
   126	.     int option_index=0;
   127	.     c=getopt_long(argc,argv,"nbvteA",long_options,&option_index);
   128	.     write(1,"c=");
   129	.     write_dec(1,c);
   130	.     write(1," argc=");
   131	.     write_dec(1,argc);
   132	.     write(1," optind=");
   133	.     write_dec(1,optind);
   134	.     write(1,"\n");
   135	.     switch(c) {
   136	.       case -1:
   137	.         names[nnames++]=argv[optind++];
   138	.         break;
   139	.       case 0:
   140	.         write(1,L("option: "));
   141	.         write(1,long_options[option_index].name);
   142	.         write(1,L("\n"));
   143	.         break;
   144	.       case 'n':
   145	.         opts.num=1;
   146	.         opts.empty=1;
   147	.         break;
   148	.       case 'b':
   149	.         opts.num=1;
   150	.         opts.empty=0;
   151	.         break;
   152	.       case 'v':
   153	.         opts.show_non=1;
   154	.         break;
   155	.       case 't':
   156	.         opts.show_tab=1;
   157	.         break;
   158	.       case 'e':
   159	.         opts.show_end=1;
   160	.         break;
   161	.       case 'A':
   162	.         opts.show_non=1;
   163	.         opts.show_tab=1;
   164	.         opts.show_end=1;
   165	.         break;
   166	.       default: 
   167	.         write(2,L("unexpected option'"));
   168	.         char chs[2];
   169	.         chs[0]=c;
   170	.         chs[1]=0;
   171	.         write(2,c_str(chs,chs+1));
   172	.         write(2,"'\n");
   173	.         sys::exit(1);
   174	.     };
   175	.     if(optind==argc)
   176	.       break;
   177	.   };
   178	.   for(int i=0;i<nnames;i++)
   179	.   {
   180	.     auto &name=names[i];
   181	.     if(name=="--")
   182	.       continue;
   183	.     else if (name=="-")
   184	.       catfile(0,1);
   185	.     else {
   186	.       int fd=open(name.begin(),o_rdonly);
   187	.       if(fd<0) {
   188	.         write(2,"open:",5);
   189	.         write(2,name.begin());
   190	.         write(2,":",1);
   191	.         write_dec(2,errno);
   192	.         write(2,":",1);
   193	.         write(2,strerror(errno));
   194	.         write(2,"\n",1);
   195	.       } else {
   196	.         catfile(fd,1);
   197	.       };
   198	.     };
   199	.   };
   200	.   return 0;
   201	. }
   202	. #if 0
   203	. BusyBox v1.27.2 (Ubuntu 1:1.27.2-2ubuntu3.2) multi-call binary.
   204	. 
   205	. Usage: cat [-nbvteA] [FILE]...
   206	. 
   207	. Print FILEs to stdout
   208	. 
   209	. 	-n	Number output lines
   210	. 	-b	Number nonempty lines
   211	. 	-v	Show nonprinting characters as ^x or M-x
   212	. 	-t	...and tabs as ^I
   213	. 	-e	...and end lines with $
   214	. 	-A	Same as -vte
   215	. #endif
FILE: END: bin/cat.cc
FILE: START: bin/echo.cc
HASH: MD5: 5e66013d1dad3b2543f10b65ccffaa4a
     1	. #include <syscall.hh>
     2	. using sys::write;
     3	. 
     4	. extern "C" {
     5	.   int main(int argc, char**argv);
     6	. };
     7	. int main(int argc, char**argv) {
     8	.   ++argv;
     9	.   if(*argv)
    10	.     write(1, *argv++);
    11	.   while(*argv) {
    12	.     write(1,L(" "));
    13	.     write(1, *argv++);
    14	.   };
    15	.   write(1, L("\n"));
    16	.   return 0;
    17	. };
FILE: END: bin/echo.cc
FILE: START: bin/false.S
HASH: MD5: 01fcb00f95be73d44995d3d5c4f8c7e8
     1	. 	.text
     2	. .Ltext0:
     3	. #APP
     4	. 	.global _start
     5	. _start:
     6	.    movq $1,%rdi
     7	.    movl $60,%eax
     8	.    syscall
     9	.    int3
    10	. 
    11	. 
FILE: END: bin/false.S
FILE: START: bin/ls.cc
HASH: MD5: 66fb10f0eb79ee20c0619aa869c45f48
     1	. #include <syscall.hh>
     2	. #include <new.hh>
     3	. #include <fmt.hh>
     4	. #include <getopt.hh>
     5	. 
     6	. using sys::write;
     7	. using sys::errno;
     8	. 
     9	. template<typename obj_t>
    10	. void swap(obj_t &lhs, obj_t rhs)
    11	. {
    12	.   obj_t tmp(lhs);
    13	.   lhs=rhs;
    14	.   rhs=tmp;
    15	. };
    16	. struct dirents_t {
    17	.   struct ent_t {
    18	.     bool dir;
    19	.     char name[256];
    20	.     ent_t()
    21	.       :dir(false)
    22	.     {
    23	.     };
    24	.     ent_t(const char *_name, bool _dir)
    25	.       :dir(_dir)
    26	.     {
    27	.       strncpy(name,_name,sizeof(name));
    28	.     };
    29	.   };
    30	.   size_t cap;
    31	.   size_t cnt;
    32	.   ent_t **lst;
    33	.   dirents_t()
    34	.     : lst(0), cap(0), cnt(0)
    35	.   {
    36	.   };
    37	.   int cmp(ent_t &lhs, ent_t&rhs) {
    38	.     return strcmp(rhs.name,lhs.name);
    39	.   };
    40	.   void sort() {
    41	.     size_t n=size();
    42	.     for(int i=0;i<n-2;i++) {
    43	.       int m=i;
    44	.       for(int j=i+1;j<n;j++) {
    45	.         if(cmp(*lst[m],*lst[j])<0)
    46	.           m=j;
    47	.       };
    48	.       if(i!=m)
    49	.         swap(lst[i],lst[m]);
    50	.     };
    51	.   };
    52	.   ~dirents_t() {
    53	.     for(int i=0;i<cnt;i++)
    54	.       delete lst[i];
    55	.     delete[] lst;
    56	.   };
    57	.   void push_back(const char *name, bool isdir)
    58	.   {
    59	.     if(cnt==cap) {
    60	.       if(cap) {
    61	.         ent_t **nlst = new ent_t*[cap+16];
    62	.         memcpy(nlst,lst,sizeof(ent_t*)*cap);
    63	.         delete[] lst;
    64	.         lst=nlst;
    65	.       } else {
    66	.         lst = new ent_t*[16];
    67	.       };
    68	.       cap+=16;
    69	.     };
    70	.     ent_t *new_ent=new ent_t(name,isdir);
    71	.     lst[cnt++]=new_ent;
    72	.   };
    73	.   ent_t &get(size_t pos)
    74	.   {
    75	.     return *lst[pos];
    76	.   };
    77	.   size_t size() const {
    78	.     return cnt;
    79	.   };
    80	. };
    81	. enum ignore_t {
    82	.   normal,
    83	.   minimal,
    84	.   dot_dot,
    85	. } ignore;
    86	. extern "C" {
    87	.   void mm_show();
    88	. };
    89	. static void *ptrs[4096];
    90	. static size_t nptr=0;
    91	. using namespace sys;
    92	. void lsdir(int fd) {
    93	.   enum { size = 4096 };
    94	.   dirents_t ents;
    95	.   char buf[size];
    96	.   for(;;){
    97	.     int nread=getdents(fd,(linux_dirent*)(char*)buf,size);
    98	.     if(nread<0)
    99	.       pexit("getdents");
   100	.     else if (nread==0)
   101	.       break;
   102	.     auto beg = reinterpret_cast<linux_dirent*>(&buf[0]);
   103	.     auto end = reinterpret_cast<linux_dirent*>(&buf[nread]);
   104	.     while(beg!=end) {
   105	.       ents.push_back(beg->d_name,beg->d_type == DT_DIR);
   106	.       beg=beg->next();
   107	.     };
   108	.     //mm_show();
   109	.   };
   110	.   ents.sort();
   111	.   for(size_t i=0;i<ents.size();i++)
   112	.   {
   113	.     auto ent=ents.get(i);
   114	.     if(ignore==dot_dot) {
   115	.       if(!strcmp(ent.name,"."))
   116	.         continue;
   117	.       if(!strcmp(ent.name,".."))
   118	.         continue;
   119	.     } else if ( ignore != minimal ) {
   120	.       if(ent.name[0]=='.')
   121	.         continue;
   122	.     };
   123	.     write(1,ent.name);
   124	.     write(1,L("\n"));
   125	.   };
   126	. };
   127	. void lsarg(const char *path)
   128	. {
   129	.   int fd = open(path,open_flags(o_directory|o_rdonly));
   130	.   if(fd>=0)
   131	.   {
   132	.     lsdir(fd);
   133	.   } else if ( errno == ENOTDIR ) {
   134	.     write(1,path);
   135	.     write(1,"\n",1);
   136	.   } else {
   137	.     write(2,"open: ");
   138	.     write(2,path);
   139	.     write(2," failed (");
   140	.     char buf[32];
   141	.     char *end=&buf[sizeof(buf)-1];
   142	.     bool neg = (errno<0);
   143	.     unsigned long num=(neg?-1:1)*errno; 
   144	.     char *str=fmt::fmt_dec(neg,num,buf,end);
   145	.     write(2,str,end);
   146	.     write(2,")\n");
   147	.   };
   148	.   close(fd);
   149	. };
   150	. 
   151	. static option longopts[]={
   152	.   { "version", 0, 0, 1 },
   153	.   { "help",    0, 0, 2 },
   154	.   { 0, 0, 0, 0}
   155	. };
   156	. const char help_msg[]=
   157	. "Usage: /bin/ls [OPTION]... [FILE]...\n"
   158	. "List information about the FILEs (the current directory by default).\n"
   159	. "Sort entries alphabetically if none of -cftuvSUX nor --sort is specified.\n"
   160	. "\n"
   161	. "Mandatory arguments to long options are mandatory for short options too.\n"
   162	. "  -a, --all                  do not ignore entries starting with .\n"
   163	. "  -A, --almost-all           do not list implied . and ..\n"
   164	. "  -b, --escape               print C-style escapes for nongraphic characters\n"
   165	. "  -d, --directory            list directories themselves, not their contents\n"
   166	. "      --help     display this help and exit\n"
   167	. "      --version  output version information and exit\n"
   168	. "\n"
   169	. "Exit status:\n"
   170	. " 0  if OK,\n"
   171	. " 1  if minor problems (e.g., cannot access subdirectory),\n"
   172	. " 2  if serious trouble (e.g., cannot access command-line argument).\n"
   173	. ;
   174	. int help(int res)
   175	. {
   176	.   write((res?2:1),L(help_msg));
   177	.   return 0;
   178	. };
   179	. int version() {
   180	.   write(1,L("ls (kernpp) 1.0\n"));
   181	.   return 0;
   182	. };
   183	. extern "C" {
   184	.   int main(int argc, char**argv, char**envp) ;
   185	. };
   186	. int main(int argc, char**argv,char**envp) 
   187	. {
   188	.   int ch;
   189	.   int longidx=0;
   190	.   signed long u=1;
   191	.   signed long lu=0;
   192	.   // show directory contents
   193	.   bool dir_cont=true;
   194	.   if(dup2(1,2)<0)
   195	.     pexit("dup2");
   196	.   while((ch=getopt_long(argc,argv,"aA",longopts,&longidx))!=-1)
   197	.   {
   198	.     switch(ch) {
   199	.       case 1: return version();
   200	.       case 2: return help(0);
   201	.       case 'a': ignore=minimal; break;
   202	.       case 'A': ignore=dot_dot; break;
   203	.       case 'd': dir_cont=false; break;
   204	.       default: return help(1);
   205	.     };
   206	.   };
   207	.   if(optind<argc) {
   208	.     for(int i=optind;i<argc;i++){
   209	.       lsarg(argv[i]);
   210	.     };
   211	.   } else {
   212	.     lsarg(".");
   213	.   };
   214	.   for(int i=0;i<nptr;i++) {
   215	.     if(ptrs[i]){
   216	.       fmt::write_ptr(2,ptrs[i]);
   217	.       write(2,L("\n"));
   218	.       free(ptrs[i]);
   219	.       ptrs[i]=0;
   220	.     };
   221	.   };
   222	.   return 0;
   223	. };
FILE: END: bin/ls.cc
FILE: START: bin/report.cc
HASH: MD5: 9a705d48c3d534c60a4537352eec8135
     1	. #include <errno.hh>
     2	. #include <fmt.hh>
     3	. #include <syscall.hh>
     4	. #include <getopt.hh>
     5	. #include <buf.hh>
     6	. 
     7	. using namespace fmt;
     8	. extern "C" {
     9	.   int main(int argc, char**argv, char**envp);
    10	. };
    11	. #define assert(x) _assert((x),#x)
    12	. buf_ns::buf_t buf;
    13	. void _assert(bool ok, const char *cond){
    14	.   if(ok)
    15	.     return;
    16	.   buf.println("assertion failed:\n  ", cond,"\n");
    17	.   exit(1);
    18	. };
    19	. // int execve(const char * fn, char *const * argv, char *const * envp)
    20	. pid_t xfork()
    21	. {
    22	.   pid_t pid=sys::fork();
    23	.   if(pid<0) {
    24	.     sys::write(1,"fork:",5);
    25	.     sys::write(1,"wtf?",4);
    26	.     exit(1);
    27	.   };
    28	.   return pid;
    29	. };
    30	. char def1[]="/bin/echo";
    31	. char def2[]="/bin/sh";
    32	. char *defs[] = { 
    33	.   def1, def2, 0
    34	. };
    35	. #define wifexited(res) (wtermsig(res)==0)
    36	. #define wtermsig(res) (res&0x7f)
    37	. #define wexitstatus(res) ((res&0xff00)>>8)
    38	. 
    39	. 
    40	. static char to_char(int num)
    41	. {
    42	.   return num+'0';
    43	. };
    44	. char env1[]="TEST1=test1";
    45	. char env2[]="TEST2=test2";
    46	. char env3[]="TEST3=test3";
    47	. char *env[]
    48	. {
    49	.   env1, env2, env3, 0
    50	. };
    51	. char **clone(char **in)
    52	. {
    53	.   int c=0;
    54	.   while(in[c])
    55	.     ++c;
    56	.   char **res=new char*[c+1];
    57	.   for(int i=0;i<c;i++)
    58	.   {
    59	.     res[i]=in[i];
    60	.   };
    61	.   res[c]=0;
    62	.   return res;
    63	. };
    64	. int count(char**arr) 
    65	. {
    66	.   int c=0;
    67	.   while(arr[c])
    68	.     ++c;
    69	.   return c;
    70	. };
    71	. int dump(char**arr) 
    72	. {
    73	.   buf.println("\narr: ",(void*)arr);
    74	.   int c=0;
    75	.   buf.println();
    76	.   while(arr[c])
    77	.     ++c;
    78	.   buf.println("arr.size()=",c);
    79	.   for(int i=0;i<=c;i++) {
    80	.     buf.println("arr[",i,"]=",arr[i]?arr[i]:"<null>  &=",(void*)arr[i]);
    81	.   };
    82	.   buf.println();
    83	.   return c;
    84	. };
    85	. 
    86	. template<typename itr_t, typename pred_t>
    87	. itr_t find( itr_t &beg, pred_t pred )
    88	. {
    89	.   while(true)
    90	.   {
    91	.     if(pred(*beg))
    92	.       return beg;
    93	.     ++beg;
    94	.   };
    95	. };
    96	. 
    97	. typedef char * str_t;
    98	. typedef const char *str_c;
    99	. 
   100	. template<size_t _n>
   101	. struct str_list
   102	. {
   103	.   static constexpr size_t n = _n;
   104	.   typedef str_t value_type;
   105	.   //typedef str_t *iterator;
   106	.   typedef str_t &reference;
   107	.   typedef str_t *pointer;
   108	.   typedef const str_t *const_pointer;
   109	.   struct lim_int {
   110	.     size_t min;
   111	.     size_t max;
   112	.     size_t val;
   113	.     lim_int(size_t min, size_t max, size_t val)
   114	.       : min(min), max(max),val(min)
   115	.     {
   116	.       set(val);
   117	.     }
   118	.     lim_int(const lim_int &copy, int val)
   119	.       : min(copy.min), max(copy.max), val(copy.min)
   120	.     {
   121	.       set(val);
   122	.     }
   123	.     void set(size_t newval) {
   124	.       assert(newval>=min && newval<=max);
   125	.       val=newval;
   126	.     };
   127	.     operator const size_t &() const {
   128	.       return val;
   129	.     };
   130	.     lim_int operator++(int) {
   131	.       lim_int res(*this);
   132	.       ++*this;
   133	.       return res;
   134	.     };
   135	.     lim_int &operator++() {
   136	.       set(val+1);
   137	.       return *this;
   138	.     };
   139	.   };
   140	.   struct iterator {
   141	.     str_list &list;
   142	.     lim_int i;
   143	.     iterator(str_list list, const lim_int &i)
   144	.       :list(list), i(i,0)
   145	.     {
   146	.       assert(i<=n);
   147	.     };
   148	.     ~iterator() {
   149	.       memset(this,0,sizeof(this));
   150	.     };
   151	.     bool operator!=(const iterator &rhs)
   152	.     {
   153	.       assert(&list==&rhs.list);
   154	.       return i!=rhs.i;
   155	.     }
   156	.     iterator operator++(int) {
   157	.       iterator res(*this);
   158	.       ++i;
   159	.       return res;
   160	.     };
   161	.     iterator &operator++() {
   162	.       assert(i<list.data.i);
   163	.       ++i;
   164	.       return *this;
   165	.     };
   166	.     str_t &operator*() {
   167	.       assert(list.data.i<n);
   168	.       while(i<list.data.i) {
   169	.         assert(list.data.i<n);
   170	.         list.push_back("");
   171	.       };
   172	.       return list[i];
   173	.     };
   174	.   };
   175	.   str_t &operator[](size_t p)
   176	.   {
   177	.     assert(p<=data.i);
   178	.     return data.list[p];
   179	.   };
   180	. 
   181	. 
   182	.   struct data_t {
   183	.     str_t list[n+1];
   184	.     lim_int i;
   185	.     data_t()
   186	.       :i(0,n,0)
   187	.     {
   188	.       memset(list,0,sizeof(list));
   189	.     };
   190	.     void push_back(const str_t &str)
   191	.     {
   192	.       if(i<n)
   193	.         list[i++]=str;
   194	.     }
   195	.     template<typename itr_t>
   196	.     void push_back(itr_t beg, itr_t end)
   197	.     {
   198	.       while(beg!=end)
   199	.         push_back(*beg++);
   200	.     };
   201	.   }data;
   202	. 
   203	.   str_list(str_t * const &beg, str_t * const &end)
   204	.   {
   205	.     push_back(beg,end);
   206	.   }
   207	.   template<typename itr_t>
   208	.     str_list(itr_t beg)
   209	.     {
   210	.       while(*beg)
   211	.         push_back(*beg++);
   212	.     }
   213	.   void push_back(str_c str)
   214	.   {
   215	.     assert(data.i<n);
   216	.     static int count=0;
   217	.     data.push_back((str_t)str);
   218	.   };
   219	.   void push_back(str_t str)
   220	.   {
   221	.     assert(data.i<n);
   222	.     data.push_back(str);
   223	.   };
   224	.   const_pointer end() const
   225	.   {
   226	.     assert(data.i<n);
   227	.     return &data.list[data.i];
   228	.   };
   229	.   const_pointer begin() const
   230	.   {
   231	.     assert(data.i<n);
   232	.     return &data.list[0];
   233	.   };
   234	.   iterator begin() {
   235	.     assert(data.i<n);
   236	.     return iterator(*this,lim_int(0,n,0));
   237	.   };
   238	.   iterator end() {
   239	.     assert(data.i<n);
   240	.     return iterator(*this,lim_int(0,n,size()));
   241	.   };
   242	.   template<typename itr_t>
   243	.   void push_back(itr_t beg, itr_t end)
   244	.   {
   245	.     assert(data.i<n);
   246	.     auto osize=size();
   247	.     while(beg!=end) {
   248	.       push_back(*beg++);
   249	.     };
   250	.     auto nsize=size();
   251	.     buf.println("added ", (nsize-osize), "messags");
   252	.   };
   253	.   size_t size() const
   254	.   {
   255	.     return data.i;
   256	.   };
   257	. };
   258	. 
   259	. int main(int argc, char** _argv, char **_envp)
   260	. {
   261	.   int res=0;
   262	.   str_list<1024> argv(_argv,_argv+argc);
   263	.   str_list<1024> envp(_envp);
   264	. 
   265	.   argv.push_back(".");
   266	.   for( auto str : argv )
   267	.     buf.println(str);
   268	. 
   269	.   buf.println(argv.size()," items");
   270	.   envp=_envp;
   271	. #if 0
   272	.   int fd=open("/dev/pts/7", sys::o_wronly);
   273	.   sys::dup2(fd,2);
   274	.   if(fd>2)
   275	.     sys::close(fd);
   276	. #endif
   277	. 
   278	.   if(argc<2) {
   279	.     buf.println("argc=",argc," need 2");
   280	.     return 2;
   281	.   };
   282	.   timespec_t dur = { 0, 100000 };
   283	.   timespec_t rem = { -1, -1 };
   284	.   pid_t opid=sys::getpid();
   285	.   pid_t npid=xfork();
   286	.   if(npid) {
   287	.     if(sys::wait(&res)<0){
   288	.       buf.println(sys::errno,"wait:",sys::strerror(sys::errno));
   289	.       return 1;
   290	.     };
   291	.     
   292	.     if( wifexited(res) ) {
   293	.       res=wexitstatus(res);
   294	.     } else {
   295	.       buf.println("sig: ", wtermsig(res), "\n\n");
   296	.     };
   297	.     auto pos=argv.begin();
   298	.     while(pos!=argv.end()){
   299	.       buf.print(*pos++," ");
   300	.     };
   301	.     buf.println("returned ",res);
   302	.   } else {
   303	.     sys::execve(argv[0],argv.data.list, envp.data.list);
   304	.     buf.println("failed to exec: ", argv[0]);
   305	.     return 0;
   306	.   };
   307	.   return res;
   308	. };
FILE: END: bin/report.cc
FILE: START: bin/string_view.cc
HASH: MD5: 0a92536cd2b5cf7e03019e74b82f1f8e
     1	. #include <string_view.hh>
     2	. 
     3	. extern "C" int main(int, char**);
     4	. 
     5	. using str::string_view;
     6	. 
     7	. int main(int argc, char**argv)
     8	. {
     9	.   string_view str("test");
    10	.   
    11	.   return 0;
    12	. };
FILE: END: bin/string_view.cc
FILE: START: bin/true.S
HASH: MD5: 66b12e50ca348c395942fe8a33164e8f
     1	. 	.text
     2	. .Ltext0:
     3	. #APP
     4	. 	.global _start
     5	. _start:
     6	.    movq $0,%rdi
     7	.    movl $60,%eax
     8	.    syscall
     9	.    int3
    10	. 
    11	. 
FILE: END: bin/true.S
FILE: START: bin/usleep.cc
HASH: MD5: 1e0a8ca8f8e5ff94dbd7a4e72dba6fc1
     1	. #include <syscall.hh>
     2	. #include <fmt.hh>
     3	. #include <getopt.hh>
     4	. 
     5	. 
     6	. using sys::write;
     7	. using sys::nanosleep;
     8	. using namespace fmt;
     9	. 
    10	. void too_many() {
    11	.   write(2,L("too many!\n\n"));
    12	.   exit(1);
    13	. };
    14	. const static int million=1000000;
    15	. const static int billion=1000*million;
    16	. extern "C" {
    17	.   int main(int argc, char**argv, char **envp);
    18	. };
    19	. int main(int argc, char**argv, char **envp)
    20	. {
    21	.   int opt;
    22	.   ++argv;
    23	.   --argv; 
    24	.   size_t mul=0;
    25	.   while ((opt = getopt(argc, argv, "sun")) != -1) {
    26	.     write(1,L("main: got '"));
    27	.     char ch=opt;
    28	.     write(1,&ch,1);
    29	.     write(1,L("\n"));
    30	.     switch(opt) {
    31	.       case 'n':
    32	.         if(mul)
    33	.           too_many();
    34	.         write(2,L("nanoseconds\n"));
    35	.         mul=1;
    36	.         break;
    37	. 
    38	. 
    39	.       case 'u':
    40	.         if(mul)
    41	.           too_many();
    42	.         write(2,L("microseconds\n"));
    43	.         mul=1000;
    44	.         break;
    45	. 
    46	.       case 's':
    47	.         if(mul)
    48	.           too_many();
    49	.         write(2,L("seconds\n"));
    50	.         mul=1000000000;
    51	.         break;
    52	. 
    53	. 
    54	.       default:
    55	.         write(2,L("bad option\n"));
    56	.         return 1;
    57	.         break;
    58	. 
    59	.     };
    60	.   };
    61	.   timespec tm;
    62	.   if(optind<argc) {
    63	.     tm.tv_nsec=atoi(argv[optind++]);
    64	.     if(tm.tv_nsec >= billion){
    65	.       tm.tv_sec=tm.tv_nsec/billion;
    66	.       tm.tv_nsec=tm.tv_nsec%billion;
    67	.     };
    68	.   } else {
    69	.     tm.tv_sec=1;
    70	.     tm.tv_nsec=0;
    71	.   };
    72	.   write_tm(2,tm);write(2,L("\n"));
    73	.   nanosleep(&tm,0);
    74	.   return 0;
    75	. };
FILE: END: bin/usleep.cc
FILE: START: doc/all_syscalls.h
HASH: MD5: d6309bca21205fc7fd58eb236c655b37
     1	. extern "C" {
     2	. // __NR__ read = 0 
     3	. 
     4	. inline ssize_t read(fd_t fd, ostr_t buf, size_t count)
     5	.   __attribute__((__always_inline__));
     6	. // __NR__ write = 1 
     7	. 
     8	. inline ssize_t sys_write(fd_t fd, istr_t buf, size_t count)
     9	.   __attribute__((__always_inline__));
    10	. // __NR__ open = 2 
    11	. 
    12	. inline fd_t open(istr_t filename, int flags, int mode)
    13	.   __attribute__((__always_inline__));
    14	. // __NR__ close = 3 
    15	. 
    16	. inline int close(fd_t fd)
    17	.   __attribute__((__always_inline__));
    18	. // __NR__ stat = 4 
    19	. 
    20	. inline int stat(istr_t filename, stat_p statbuf)
    21	.   __attribute__((__always_inline__));
    22	. // __NR__ fstat = 5 
    23	. 
    24	. inline int fstat(fd_t fd, stat_p statbuf)
    25	.   __attribute__((__always_inline__));
    26	. // __NR__ lstat = 6 
    27	. 
    28	. inline int lstat(istr_t filename, stat_p statbuf)
    29	.   __attribute__((__always_inline__));
    30	. // __NR__ poll = 7 
    31	. 
    32	. inline int poll(pollfd_p ufds, unsigned nfds, long timeout_msecs)
    33	.   __attribute__((__always_inline__));
    34	. // __NR__ lseek = 8 
    35	. 
    36	. inline int lseek(fd_t fd, off_t offset, unsigned origin)
    37	.   __attribute__((__always_inline__));
    38	. // __NR__ mmap = 9 
    39	. 
    40	. inline char* mmap(void* addr, size_t len, int prot, int flags, fd_t fd, off_t off)
    41	.   __attribute__((__always_inline__));
    42	. // __NR__ mprotect = 10 
    43	. 
    44	. inline int mprotect(uint64_t start, size_t len, uint64_t prot)
    45	.   __attribute__((__always_inline__));
    46	. // __NR__ munmap = 11 
    47	. 
    48	. inline int munmap(uint64_t addr, size_t len)
    49	.   __attribute__((__always_inline__));
    50	. // __NR__ brk = 12 
    51	. 
    52	. inline int brk(void_p brk)
    53	.   __attribute__((__always_inline__));
    54	. // __NR__ rt_sigaction = 13 
    55	. 
    56	. inline int rt_sigaction(int sig, sigaction_p act, sigaction_p oact)
    57	.   __attribute__((__always_inline__));
    58	. // __NR__ rt_sigprocmask = 14 
    59	. 
    60	. inline int rt_sigprocmask(int how, sigset_p nset, sigset_p oset, size_t sigsetsize)
    61	.   __attribute__((__always_inline__));
    62	. // __NR__ rt_sigreturn = 15 
    63	. 
    64	. inline int rt_sigreturn(uint64_t __unused)
    65	.   __attribute__((__always_inline__));
    66	. // __NR__ ioctl = 16 
    67	. 
    68	. inline int ioctl(fd_t fd, unsigned cmd, uint64_t arg)
    69	.   __attribute__((__always_inline__));
    70	. // __NR__ pread64 = 17 
    71	. 
    72	. inline int pread64(fd_t fd, ostr_t buf, size_t count, off_t pos)
    73	.   __attribute__((__always_inline__));
    74	. // __NR__ pwrite64 = 18 
    75	. 
    76	. inline int pwrite64(fd_t fd, istr_t buf, size_t count, off_t pos)
    77	.   __attribute__((__always_inline__));
    78	. // __NR__ readv = 19 
    79	. 
    80	. inline int readv(fd_t fd, iovec_p vec, uint64_t vlen)
    81	.   __attribute__((__always_inline__));
    82	. // __NR__ writev = 20 
    83	. 
    84	. inline int writev(fd_t fd, iovec_p vec, uint64_t vlen)
    85	.   __attribute__((__always_inline__));
    86	. // __NR__ access = 21 
    87	. 
    88	. inline int access(istr_t filename, int mode)
    89	.   __attribute__((__always_inline__));
    90	. // __NR__ pipe = 22 
    91	. 
    92	. inline int pipe(fd_p filedes)
    93	.   __attribute__((__always_inline__));
    94	. // __NR__ select = 23 
    95	. 
    96	. inline int select(int n, fd_set_p inp, fd_set_p outp, fd_set_p exp, timeval_p tvp)
    97	.   __attribute__((__always_inline__));
    98	. // __NR__ sched_yield = 24 
    99	. 
   100	. inline int sched_yield()
   101	.   __attribute__((__always_inline__));
   102	. // __NR__ mremap = 25 
   103	. 
   104	. inline int mremap(uint64_t addr, uint64_t old_len, uint64_t new_len, uint64_t flags, uint64_t new_addr)
   105	.   __attribute__((__always_inline__));
   106	. // __NR__ msync = 26 
   107	. 
   108	. inline int msync(uint64_t start, size_t len, int flags)
   109	.   __attribute__((__always_inline__));
   110	. // __NR__ mincore = 27 
   111	. 
   112	. inline int mincore(uint64_t start, size_t len, ostr_t vec)
   113	.   __attribute__((__always_inline__));
   114	. // __NR__ madvise = 28 
   115	. 
   116	. inline int madvise(uint64_t start, size_t len_in, int behavior)
   117	.   __attribute__((__always_inline__));
   118	. // __NR__ shmget = 29 
   119	. 
   120	. inline int shmget(key_t key, size_t size, int shmflg)
   121	.   __attribute__((__always_inline__));
   122	. // __NR__ shmat = 30 
   123	. 
   124	. inline int shmat(int shmid, ostr_t shmaddr, int shmflg)
   125	.   __attribute__((__always_inline__));
   126	. // __NR__ shmctl = 31 
   127	. 
   128	. inline int shmctl(int shmid, int cmd, shmid_ds_p buf)
   129	.   __attribute__((__always_inline__));
   130	. // __NR__ dup = 32 
   131	. 
   132	. inline int dup(unsigned fildes)
   133	.   __attribute__((__always_inline__));
   134	. // __NR__ dup2 = 33 
   135	. 
   136	. inline int dup2(fd_t oldfd, fd_t newfd)
   137	.   __attribute__((__always_inline__));
   138	. // __NR__ pause = 34 
   139	. 
   140	. inline int pause()
   141	.   __attribute__((__always_inline__));
   142	. // __NR__ nanosleep = 35 
   143	. 
   144	. inline int nanosleep(timespec_p rqtp, timespec_p rmtp)
   145	.   __attribute__((__always_inline__));
   146	. // __NR__ getitimer = 36 
   147	. 
   148	. inline int getitimer(int which, itimerval_p value)
   149	.   __attribute__((__always_inline__));
   150	. // __NR__ alarm = 37 
   151	. 
   152	. inline int alarm(unsigned seconds)
   153	.   __attribute__((__always_inline__));
   154	. // __NR__ setitimer = 38 
   155	. 
   156	. inline int setitimer(int which, itimerval_p value, itimerval_p ovalue)
   157	.   __attribute__((__always_inline__));
   158	. // __NR__ getpid = 39 
   159	. 
   160	. inline int getpid()
   161	.   __attribute__((__always_inline__));
   162	. // __NR__ sendfile = 40 
   163	. 
   164	. inline int sendfile(int out_fd, int in_fd, off_p offset, size_t count)
   165	.   __attribute__((__always_inline__));
   166	. // __NR__ socket = 41 
   167	. 
   168	. inline int socket(int family, int type, int protocol)
   169	.   __attribute__((__always_inline__));
   170	. // __NR__ connect = 42 
   171	. 
   172	. inline int connect(fd_t fd, sockaddr_p uservaddr, int addrlen)
   173	.   __attribute__((__always_inline__));
   174	. // __NR__ accept = 43 
   175	. 
   176	. inline int accept(fd_t fd, sockaddr_p upeer_sockaddr, int32_p upeer_addrlen)
   177	.   __attribute__((__always_inline__));
   178	. // __NR__ sendto = 44 
   179	. 
   180	. inline int sendto(fd_t fd, void_p buff, size_t len, unsigned flags, sockaddr_p addr, int addr_len)
   181	.   __attribute__((__always_inline__));
   182	. // __NR__ recvfrom = 45 
   183	. 
   184	. inline int recvfrom(fd_t fd, void_p ubuf, size_t size, unsigned flags, sockaddr_p addr, int32_p addr_len)
   185	.   __attribute__((__always_inline__));
   186	. // __NR__ sendmsg = 46 
   187	. 
   188	. inline int sendmsg(fd_t fd, msghdr_p msg, unsigned flags)
   189	.   __attribute__((__always_inline__));
   190	. // __NR__ recvmsg = 47 
   191	. 
   192	. inline int recvmsg(fd_t fd, msghdr_p msg, unsigned flags)
   193	.   __attribute__((__always_inline__));
   194	. // __NR__ shutdown = 48 
   195	. 
   196	. inline int shutdown(fd_t fd, int how)
   197	.   __attribute__((__always_inline__));
   198	. // __NR__ bind = 49 
   199	. 
   200	. inline int bind(fd_t fd, sockaddr_p umyaddr, int addrlen)
   201	.   __attribute__((__always_inline__));
   202	. // __NR__ listen = 50 
   203	. 
   204	. inline int listen(fd_t fd, int backlog)
   205	.   __attribute__((__always_inline__));
   206	. // __NR__ getsockname = 51 
   207	. 
   208	. inline int getsockname(fd_t fd, sockaddr_p usockaddr, int32_p usockaddr_len)
   209	.   __attribute__((__always_inline__));
   210	. // __NR__ getpeername = 52 
   211	. 
   212	. inline int getpeername(fd_t fd, sockaddr_p usockaddr, int32_p usockaddr_len)
   213	.   __attribute__((__always_inline__));
   214	. // __NR__ socketpair = 53 
   215	. 
   216	. inline int socketpair(int family, int type, int protocol, int32_p usockvec)
   217	.   __attribute__((__always_inline__));
   218	. // __NR__ setsockopt = 54 
   219	. 
   220	. inline int setsockopt(fd_t fd, int level, int optname, ostr_t optval, int optlen)
   221	.   __attribute__((__always_inline__));
   222	. // __NR__ getsockopt = 55 
   223	. 
   224	. inline int getsockopt(fd_t fd, int level, int optname, ostr_t optval, int32_p optlen)
   225	.   __attribute__((__always_inline__));
   226	. // __NR__ clone = 56 
   227	. 
   228	. inline int sys_clone(uint64_t clone_flags, uint64_t newsp, void_p parent_tid, void_p child_tid)
   229	.   __attribute__((__always_inline__));
   230	. // __NR__ fork = 57 
   231	. 
   232	. inline int fork()
   233	.   __attribute__((__always_inline__));
   234	. // __NR__ vfork = 58 
   235	. 
   236	. inline int vfork()
   237	.   __attribute__((__always_inline__));
   238	. // __NR__ execve = 59 
   239	. 
   240	. inline int execve(const char * filename, char *const * argv, char *const * envp)
   241	.   __attribute__((__always_inline__));
   242	. // __NR__ exit = 60 
   243	. 
   244	. inline void _exit(int error_code)
   245	.   __attribute__((__always_inline__));
   246	. // __NR__ wait4 = 61 
   247	. 
   248	. inline int wait4(pid_t upid, int32_p stat_addr, int options, rusage_p ru)
   249	.   __attribute__((__always_inline__));
   250	. // __NR__ kill = 62 
   251	. 
   252	. inline int kill(pid_t pid, int sig)
   253	.   __attribute__((__always_inline__));
   254	. // __NR__ uname = 63 
   255	. 
   256	. inline int uname(utsname_p name)
   257	.   __attribute__((__always_inline__));
   258	. // __NR__ semget = 64 
   259	. 
   260	. inline int semget(key_t key, int nsems, int semflg)
   261	.   __attribute__((__always_inline__));
   262	. // __NR__ semop = 65 
   263	. 
   264	. inline int semop(int semid, sembuf_p tsops, unsigned nsops)
   265	.   __attribute__((__always_inline__));
   266	. // __NR__ semctl = 66 
   267	. 
   268	. inline int semctl(int semid, int semnum, int cmd, union semun arg)
   269	.   __attribute__((__always_inline__));
   270	. // __NR__ shmdt = 67 
   271	. 
   272	. inline int shmdt(ostr_t shmaddr)
   273	.   __attribute__((__always_inline__));
   274	. // __NR__ msgget = 68 
   275	. 
   276	. inline int msgget(key_t key, int msgflg)
   277	.   __attribute__((__always_inline__));
   278	. // __NR__ msgsnd = 69 
   279	. 
   280	. inline int msgsnd(int msqid, msgbuf_p msgp, size_t msgsz, int msgflg)
   281	.   __attribute__((__always_inline__));
   282	. // __NR__ msgrcv = 70 
   283	. 
   284	. inline int msgrcv(int msqid, msgbuf_p msgp, size_t msgsz, long msgtyp, int msgflg)
   285	.   __attribute__((__always_inline__));
   286	. // __NR__ msgctl = 71 
   287	. 
   288	. inline int msgctl(int msqid, int cmd, msqid_ds_p buf)
   289	.   __attribute__((__always_inline__));
   290	. // __NR__ fcntl = 72 
   291	. 
   292	. inline int fcntl(fd_t fd, unsigned cmd, uint64_t arg)
   293	.   __attribute__((__always_inline__));
   294	. // __NR__ flock = 73 
   295	. 
   296	. inline int flock(fd_t fd, unsigned cmd)
   297	.   __attribute__((__always_inline__));
   298	. // __NR__ fsync = 74 
   299	. 
   300	. inline int fsync(fd_t fd)
   301	.   __attribute__((__always_inline__));
   302	. // __NR__ fdatasync = 75 
   303	. 
   304	. inline int fdatasync(fd_t fd)
   305	.   __attribute__((__always_inline__));
   306	. // __NR__ truncate = 76 
   307	. 
   308	. inline int truncate(istr_t path, long length)
   309	.   __attribute__((__always_inline__));
   310	. // __NR__ ftruncate = 77 
   311	. 
   312	. inline int ftruncate(fd_t fd, uint64_t length)
   313	.   __attribute__((__always_inline__));
   314	. // __NR__ getdents = 78 
   315	. 
   316	. inline ssize_t getdents(fd_t fd, linux_dirent_p dirent, size_t count)
   317	.   __attribute__((__always_inline__));
   318	. // __NR__ getcwd = 79 
   319	. 
   320	. inline int getcwd(ostr_t buf, uint64_t size)
   321	.   __attribute__((__always_inline__));
   322	. // __NR__ chdir = 80 
   323	. 
   324	. inline int chdir(istr_t filename)
   325	.   __attribute__((__always_inline__));
   326	. // __NR__ fchdir = 81 
   327	. 
   328	. inline int fchdir(fd_t fd)
   329	.   __attribute__((__always_inline__));
   330	. // __NR__ rename = 82 
   331	. 
   332	. inline int rename(istr_t oldname, istr_t newname)
   333	.   __attribute__((__always_inline__));
   334	. // __NR__ mkdir = 83 
   335	. 
   336	. inline int mkdir(istr_t pathname, int mode)
   337	.   __attribute__((__always_inline__));
   338	. // __NR__ rmdir = 84 
   339	. 
   340	. inline int rmdir(istr_t pathname)
   341	.   __attribute__((__always_inline__));
   342	. // __NR__ creat = 85 
   343	. 
   344	. inline int creat(istr_t pathname, int mode)
   345	.   __attribute__((__always_inline__));
   346	. // __NR__ link = 86 
   347	. 
   348	. inline int link(istr_t oldname, istr_t newname)
   349	.   __attribute__((__always_inline__));
   350	. // __NR__ unlink = 87 
   351	. 
   352	. inline int unlink(istr_t pathname)
   353	.   __attribute__((__always_inline__));
   354	. // __NR__ symlink = 88 
   355	. 
   356	. inline int symlink(istr_t oldname, istr_t newname)
   357	.   __attribute__((__always_inline__));
   358	. // __NR__ readlink = 89 
   359	. 
   360	. inline int readlink(istr_t path, ostr_t buf, int bufsiz)
   361	.   __attribute__((__always_inline__));
   362	. // __NR__ chmod = 90 
   363	. 
   364	. inline int chmod(istr_t filename, mode_t mode)
   365	.   __attribute__((__always_inline__));
   366	. // __NR__ fchmod = 91 
   367	. 
   368	. inline int fchmod(fd_t fd, mode_t mode)
   369	.   __attribute__((__always_inline__));
   370	. // __NR__ chown = 92 
   371	. 
   372	. inline int chown(istr_t filename, uid_t user, gid_t group)
   373	.   __attribute__((__always_inline__));
   374	. // __NR__ fchown = 93 
   375	. 
   376	. inline int fchown(fd_t fd, uid_t user, gid_t group)
   377	.   __attribute__((__always_inline__));
   378	. // __NR__ lchown = 94 
   379	. 
   380	. inline int lchown(istr_t filename, uid_t user, gid_t group)
   381	.   __attribute__((__always_inline__));
   382	. // __NR__ umask = 95 
   383	. 
   384	. inline int umask(int mask)
   385	.   __attribute__((__always_inline__));
   386	. // __NR__ gettimeofday = 96 
   387	. 
   388	. inline int gettimeofday(timeval_p tv, timezone_p tz)
   389	.   __attribute__((__always_inline__));
   390	. // __NR__ getrlimit = 97 
   391	. 
   392	. inline int getrlimit(unsigned resource, rlimit_p rlim)
   393	.   __attribute__((__always_inline__));
   394	. // __NR__ getrusage = 98 
   395	. 
   396	. inline int getrusage(int who, rusage_p ru)
   397	.   __attribute__((__always_inline__));
   398	. // __NR__ sysinfo = 99 
   399	. 
   400	. inline int sysinfo(sysinfo_p info)
   401	.   __attribute__((__always_inline__));
   402	. // __NR__ times = 100 
   403	. 
   404	. inline int times(sysinfo_p info)
   405	.   __attribute__((__always_inline__));
   406	. // __NR__ ptrace = 101 
   407	. 
   408	. inline int ptrace(long request, long pid, uint64_t addr, uint64_t data)
   409	.   __attribute__((__always_inline__));
   410	. // __NR__ getuid = 102 
   411	. 
   412	. inline int getuid()
   413	.   __attribute__((__always_inline__));
   414	. // __NR__ syslog = 103 
   415	. 
   416	. inline int syslog(int type, ostr_t buf, int len)
   417	.   __attribute__((__always_inline__));
   418	. // __NR__ getgid = 104 
   419	. 
   420	. inline int getgid()
   421	.   __attribute__((__always_inline__));
   422	. // __NR__ setuid = 105 
   423	. 
   424	. inline int setuid(uid_t uid)
   425	.   __attribute__((__always_inline__));
   426	. // __NR__ setgid = 106 
   427	. 
   428	. inline int setgid(gid_t gid)
   429	.   __attribute__((__always_inline__));
   430	. // __NR__ geteuid = 107 
   431	. 
   432	. inline int geteuid()
   433	.   __attribute__((__always_inline__));
   434	. // __NR__ getegid = 108 
   435	. 
   436	. inline int getegid()
   437	.   __attribute__((__always_inline__));
   438	. // __NR__ setpgid = 109 
   439	. 
   440	. inline int setpgid(pid_t pid, pid_t pgid)
   441	.   __attribute__((__always_inline__));
   442	. // __NR__ getppid = 110 
   443	. 
   444	. inline int getppid()
   445	.   __attribute__((__always_inline__));
   446	. // __NR__ getpgrp = 111 
   447	. 
   448	. inline int getpgrp()
   449	.   __attribute__((__always_inline__));
   450	. // __NR__ setsid = 112 
   451	. 
   452	. inline int setsid()
   453	.   __attribute__((__always_inline__));
   454	. // __NR__ setreuid = 113 
   455	. 
   456	. inline int setreuid(uid_t ruid, uid_t euid)
   457	.   __attribute__((__always_inline__));
   458	. // __NR__ setregid = 114 
   459	. 
   460	. inline int setregid(gid_t rgid, gid_t egid)
   461	.   __attribute__((__always_inline__));
   462	. // __NR__ getgroups = 115 
   463	. 
   464	. inline int getgroups(int gidsetsize, gid_p grouplist)
   465	.   __attribute__((__always_inline__));
   466	. // __NR__ setgroups = 116 
   467	. 
   468	. inline int setgroups(int gidsetsize, gid_p grouplist)
   469	.   __attribute__((__always_inline__));
   470	. // __NR__ setresuid = 117 
   471	. 
   472	. inline int setresuid(uid_p ruid, uid_p euid, uid_p suid)
   473	.   __attribute__((__always_inline__));
   474	. // __NR__ getresuid = 118 
   475	. 
   476	. inline int getresuid(uid_p ruid, uid_p euid, uid_p suid)
   477	.   __attribute__((__always_inline__));
   478	. // __NR__ setresgid = 119 
   479	. 
   480	. inline int setresgid(gid_t rgid, gid_t egid, gid_t sgid)
   481	.   __attribute__((__always_inline__));
   482	. // __NR__ getresgid = 120 
   483	. 
   484	. inline int getresgid(gid_p rgid, gid_p egid, gid_p sgid)
   485	.   __attribute__((__always_inline__));
   486	. // __NR__ getpgid = 121 
   487	. 
   488	. inline int getpgid(pid_t pid)
   489	.   __attribute__((__always_inline__));
   490	. // __NR__ setfsuid = 122 
   491	. 
   492	. inline int setfsuid(uid_t uid)
   493	.   __attribute__((__always_inline__));
   494	. // __NR__ setfsgid = 123 
   495	. 
   496	. inline int setfsgid(gid_t gid)
   497	.   __attribute__((__always_inline__));
   498	. // __NR__ getsid = 124 
   499	. 
   500	. inline int getsid(pid_t pid)
   501	.   __attribute__((__always_inline__));
   502	. // __NR__ capget = 125 
   503	. 
   504	. inline int capget(cap_user_header_t header, cap_user_data_t dataptr)
   505	.   __attribute__((__always_inline__));
   506	. // __NR__ capset = 126 
   507	. 
   508	. inline int capset(cap_user_header_t header, const cap_user_data_t data)
   509	.   __attribute__((__always_inline__));
   510	. // __NR__ rt_sigpending = 127 
   511	. 
   512	. inline int rt_sigpending(sigset_p set, size_t sigsetsize)
   513	.   __attribute__((__always_inline__));
   514	. // __NR__ rt_sigtimedwait = 128 
   515	. 
   516	. inline int rt_sigtimedwait(const sigset_p uthese, siginfo_p uinfo, timespec_p uts, size_t sigsetsize)
   517	.   __attribute__((__always_inline__));
   518	. // __NR__ rt_sigqueueinfo = 129 
   519	. 
   520	. inline int rt_sigqueueinfo(pid_t pid, int sig, siginfo_p uinfo)
   521	.   __attribute__((__always_inline__));
   522	. // __NR__ rt_sigsuspend = 130 
   523	. 
   524	. inline int rt_sigsuspend(sigset_p unewset, size_t sigsetsize)
   525	.   __attribute__((__always_inline__));
   526	. // __NR__ sigaltstack = 131 
   527	. 
   528	. inline int sigaltstack(const stack_p uss, stack_p uoss)
   529	.   __attribute__((__always_inline__));
   530	. // __NR__ utime = 132 
   531	. 
   532	. inline int utime(ostr_t filename, utimbuf_p times)
   533	.   __attribute__((__always_inline__));
   534	. // __NR__ mknod = 133 
   535	. 
   536	. inline int mknod(istr_t filename, umode_t mode, unsigned dev)
   537	.   __attribute__((__always_inline__));
   538	. // __NR__ personality = 135 
   539	. 
   540	. inline int personality(unsigned personality)
   541	.   __attribute__((__always_inline__));
   542	. // __NR__ ustat = 136 
   543	. 
   544	. inline int ustat(unsigned dev, ustat_p ubuf)
   545	.   __attribute__((__always_inline__));
   546	. // __NR__ statfs = 137 
   547	. 
   548	. inline int statfs(istr_t pathname, statfs_p buf)
   549	.   __attribute__((__always_inline__));
   550	. // __NR__ fstatfs = 138 
   551	. 
   552	. inline int fstatfs(fd_t fd, statfs_p buf)
   553	.   __attribute__((__always_inline__));
   554	. // __NR__ sysfs = 139 
   555	. 
   556	. inline int sysfs(int option, uint64_t arg1, uint64_t arg2)
   557	.   __attribute__((__always_inline__));
   558	. // __NR__ getpriority = 140 
   559	. 
   560	. inline int getpriority(int which, int who)
   561	.   __attribute__((__always_inline__));
   562	. // __NR__ setpriority = 141 
   563	. 
   564	. inline int setpriority(int which, int who, int niceval)
   565	.   __attribute__((__always_inline__));
   566	. // __NR__ sched_setparam = 142 
   567	. 
   568	. inline int sys_sched_setparam(pid_t pid, const void * param)
   569	.   __attribute__((__always_inline__));
   570	. // __NR__ sched_getparam = 143 
   571	. 
   572	. inline int sched_getparam(pid_t pid, sched_param_p param)
   573	.   __attribute__((__always_inline__));
   574	. // __NR__ sched_setscheduler = 144 
   575	. 
   576	. inline int sys_sched_setscheduler(pid_t pid, int policy, sched_param_p param)
   577	.   __attribute__((__always_inline__));
   578	. // __NR__ sched_getscheduler = 145 
   579	. 
   580	. inline int sched_getscheduler(pid_t pid)
   581	.   __attribute__((__always_inline__));
   582	. // __NR__ sched_get_priority_max = 146 
   583	. 
   584	. inline int sched_get_priority_max(int policy)
   585	.   __attribute__((__always_inline__));
   586	. // __NR__ sched_get_priority_min = 147 
   587	. 
   588	. inline int sched_get_priority_min(int policy)
   589	.   __attribute__((__always_inline__));
   590	. // __NR__ sched_rr_get_interval = 148 
   591	. 
   592	. inline int sched_rr_get_interval(pid_t pid, timespec_p interval)
   593	.   __attribute__((__always_inline__));
   594	. // __NR__ mlock = 149 
   595	. 
   596	. inline int mlock(void_p start, size_t len)
   597	.   __attribute__((__always_inline__));
   598	. // __NR__ munlock = 150 
   599	. 
   600	. inline int munlock(void_p start, size_t len)
   601	.   __attribute__((__always_inline__));
   602	. // __NR__ mlockall = 151 
   603	. 
   604	. inline int mlockall(int flags)
   605	.   __attribute__((__always_inline__));
   606	. // __NR__ munlockall = 152 
   607	. 
   608	. inline int munlockall()
   609	.   __attribute__((__always_inline__));
   610	. // __NR__ vhangup = 153 
   611	. 
   612	. inline int vhangup()
   613	.   __attribute__((__always_inline__));
   614	. // __NR__ modify_ldt = 154 
   615	. 
   616	. inline int modify_ldt(int func, void_p ptr, uint64_t bytecount)
   617	.   __attribute__((__always_inline__));
   618	. // __NR__ pivot_root = 155 
   619	. 
   620	. inline int pivot_root(istr_t new_root, istr_t put_old)
   621	.   __attribute__((__always_inline__));
   622	. // __NR__ _sysctl = 156 
   623	. 
   624	. inline int _sysctl(sysctl_args_p args)
   625	.   __attribute__((__always_inline__));
   626	. // __NR__ prctl = 157 
   627	. 
   628	. inline int prctl(int option, uint64_t arg2, uint64_t arg3, uint64_t arg4, uint64_t arg5)
   629	.   __attribute__((__always_inline__));
   630	. // __NR__ arch_prctl = 158 
   631	. 
   632	. inline int arch_prctl(task_struct_p task, int code, uint64_t addr)
   633	.   __attribute__((__always_inline__));
   634	. // __NR__ adjtimex = 159 
   635	. 
   636	. inline int adjtimex(timex_p txc_p)
   637	.   __attribute__((__always_inline__));
   638	. // __NR__ setrlimit = 160 
   639	. 
   640	. inline int setrlimit(unsigned resource, rlimit_p rlim)
   641	.   __attribute__((__always_inline__));
   642	. // __NR__ chroot = 161 
   643	. 
   644	. inline int chroot(istr_t filename)
   645	.   __attribute__((__always_inline__));
   646	. // __NR__ sync = 162 
   647	. 
   648	. inline int sync()
   649	.   __attribute__((__always_inline__));
   650	. // __NR__ acct = 163 
   651	. 
   652	. inline int acct(istr_t name)
   653	.   __attribute__((__always_inline__));
   654	. // __NR__ settimeofday = 164 
   655	. 
   656	. inline int settimeofday(timeval_p tv, timezone_p tz)
   657	.   __attribute__((__always_inline__));
   658	. // __NR__ mount = 165 
   659	. 
   660	. inline int mount(ostr_t dev_name, ostr_t dir_name, ostr_t type, uint64_t flags, void_p data)
   661	.   __attribute__((__always_inline__));
   662	. // __NR__ umount2 = 166 
   663	. 
   664	. inline int umount2(istr_t target, int flags)
   665	.   __attribute__((__always_inline__));
   666	. // __NR__ swapon = 167 
   667	. 
   668	. inline int swapon(istr_t specialfile, int swap_flags)
   669	.   __attribute__((__always_inline__));
   670	. // __NR__ swapoff = 168 
   671	. 
   672	. inline int swapoff(istr_t specialfile)
   673	.   __attribute__((__always_inline__));
   674	. // __NR__ reboot = 169 
   675	. 
   676	. inline int reboot(int magic1, int magic2, unsigned cmd, void_p arg)
   677	.   __attribute__((__always_inline__));
   678	. // __NR__ sethostname = 170 
   679	. 
   680	. inline int sethostname(ostr_t name, int len)
   681	.   __attribute__((__always_inline__));
   682	. // __NR__ setdomainname = 171 
   683	. 
   684	. inline int setdomainname(ostr_t name, int len)
   685	.   __attribute__((__always_inline__));
   686	. // __NR__ iopl = 172 
   687	. 
   688	. inline int iopl(unsigned level, pt_regs_p regs)
   689	.   __attribute__((__always_inline__));
   690	. // __NR__ ioperm = 173 
   691	. 
   692	. inline int ioperm(uint64_t from, uint64_t num, int turn_on)
   693	.   __attribute__((__always_inline__));
   694	. // __NR__ init_module = 175 
   695	. 
   696	. inline int init_module(void_p umod, uint64_t len, istr_t uargs)
   697	.   __attribute__((__always_inline__));
   698	. // __NR__ delete_module = 176 
   699	. 
   700	. inline int delete_module(istr_t name_user, unsigned flags)
   701	.   __attribute__((__always_inline__));
   702	. // __NR__ quotactl = 179 
   703	. 
   704	. inline int quotactl(unsigned cmd, istr_t special, qid_t id, void_p addr)
   705	.   __attribute__((__always_inline__));
   706	. // __NR__ gettid = 186 
   707	. 
   708	. inline int gettid()
   709	.   __attribute__((__always_inline__));
   710	. // __NR__ readahead = 187 
   711	. 
   712	. inline int readahead(fd_t fd, off_t offset, size_t count)
   713	.   __attribute__((__always_inline__));
   714	. // __NR__ setxattr = 188 
   715	. 
   716	. inline int setxattr(istr_t pathname, istr_t name, const void_p value, size_t size, int flags)
   717	.   __attribute__((__always_inline__));
   718	. // __NR__ lsetxattr = 189 
   719	. 
   720	. inline int lsetxattr(istr_t pathname, istr_t name, const void_p value, size_t size, int flags)
   721	.   __attribute__((__always_inline__));
   722	. // __NR__ fsetxattr = 190 
   723	. 
   724	. inline int fsetxattr(fd_t fd, istr_t name, const void_p value, size_t size, int flags)
   725	.   __attribute__((__always_inline__));
   726	. // __NR__ getxattr = 191 
   727	. 
   728	. inline int getxattr(istr_t pathname, istr_t name, void_p value, size_t size)
   729	.   __attribute__((__always_inline__));
   730	. // __NR__ lgetxattr = 192 
   731	. 
   732	. inline int lgetxattr(istr_t pathname, istr_t name, void_p value, size_t size)
   733	.   __attribute__((__always_inline__));
   734	. // __NR__ fgetxattr = 193 
   735	. 
   736	. inline int fgetxattr(fd_t fd, istr_t name, void_p value, size_t size)
   737	.   __attribute__((__always_inline__));
   738	. // __NR__ listxattr = 194 
   739	. 
   740	. inline int listxattr(istr_t pathname, ostr_t list, size_t size)
   741	.   __attribute__((__always_inline__));
   742	. // __NR__ llistxattr = 195 
   743	. 
   744	. inline int llistxattr(istr_t pathname, ostr_t list, size_t size)
   745	.   __attribute__((__always_inline__));
   746	. // __NR__ flistxattr = 196 
   747	. 
   748	. inline int flistxattr(fd_t fd, ostr_t list, size_t size)
   749	.   __attribute__((__always_inline__));
   750	. // __NR__ removexattr = 197 
   751	. 
   752	. inline int removexattr(istr_t pathname, istr_t name)
   753	.   __attribute__((__always_inline__));
   754	. // __NR__ lremovexattr = 198 
   755	. 
   756	. inline int lremovexattr(istr_t pathname, istr_t name)
   757	.   __attribute__((__always_inline__));
   758	. // __NR__ fremovexattr = 199 
   759	. 
   760	. inline int fremovexattr(fd_t fd, istr_t name)
   761	.   __attribute__((__always_inline__));
   762	. // __NR__ tkill = 200 
   763	. 
   764	. inline int tkill(pid_t pid, int sig)
   765	.   __attribute__((__always_inline__));
   766	. // __NR__ time = 201 
   767	. 
   768	. inline time_t time(time_p tloc)
   769	.   __attribute__((__always_inline__));
   770	. // __NR__ futex = 202 
   771	. 
   772	. inline int futex(uint32_p uaddr, int op, uint32_t val, timespec_p utime, uint32_p uaddr2, uint32_t val3)
   773	.   __attribute__((__always_inline__));
   774	. // __NR__ sched_setaffinity = 203 
   775	. 
   776	. inline int sys_sched_setaffinity(pid_t pid, size_t len, const void * user_mask_ptr)
   777	.   __attribute__((__always_inline__));
   778	. // __NR__ sched_getaffinity = 204 
   779	. 
   780	. inline int sys_sched_getaffinity(pid_t pid, unsigned len, uint64_p user_mask_ptr)
   781	.   __attribute__((__always_inline__));
   782	. // __NR__ io_setup = 206 
   783	. 
   784	. inline int io_setup(unsigned nr_events, aio_context_p ctxp)
   785	.   __attribute__((__always_inline__));
   786	. // __NR__ io_destroy = 207 
   787	. 
   788	. inline int io_destroy(aio_context_t ctx)
   789	.   __attribute__((__always_inline__));
   790	. // __NR__ io_getevents = 208 
   791	. 
   792	. inline int io_getevents(aio_context_t ctx_id, long min_nr, long nr, io_event_p events)
   793	.   __attribute__((__always_inline__));
   794	. // __NR__ io_submit = 209 
   795	. 
   796	. inline int io_submit(aio_context_t ctx_id, long nr, iocb_p iocbpp)
   797	.   __attribute__((__always_inline__));
   798	. // __NR__ io_cancel = 210 
   799	. 
   800	. inline int io_cancel(aio_context_t ctx_id, iocb_p iocb, io_event_p result)
   801	.   __attribute__((__always_inline__));
   802	. // __NR__ lookup_dcookie = 212 
   803	. 
   804	. inline int lookup_dcookie(uint64_t cookie64, long buf, long len)
   805	.   __attribute__((__always_inline__));
   806	. // __NR__ epoll_create = 213 
   807	. 
   808	. inline int epoll_create(int size)
   809	.   __attribute__((__always_inline__));
   810	. // __NR__ remap_file_pages = 216 
   811	. 
   812	. inline int remap_file_pages(uint64_t start, uint64_t size, uint64_t prot, uint64_t pgoff, uint64_t flags)
   813	.   __attribute__((__always_inline__));
   814	. // __NR__ getdents64 = 217 
   815	. 
   816	. inline int getdents64(fd_t fd, linux_dirent64_p dirent, unsigned count)
   817	.   __attribute__((__always_inline__));
   818	. // __NR__ set_tid_address = 218 
   819	. 
   820	. inline int set_tid_address(int32_p tidptr)
   821	.   __attribute__((__always_inline__));
   822	. // __NR__ restart_syscall = 219 
   823	. 
   824	. inline int restart_syscall()
   825	.   __attribute__((__always_inline__));
   826	. // __NR__ semtimedop = 220 
   827	. 
   828	. inline int semtimedop(int semid, sembuf_p tsops, unsigned nsops, timespec_p timeout)
   829	.   __attribute__((__always_inline__));
   830	. // __NR__ fadvise64 = 221 
   831	. 
   832	. inline int fadvise64(fd_t fd, off_t offset, size_t len, int advice)
   833	.   __attribute__((__always_inline__));
   834	. // __NR__ timer_create = 222 
   835	. 
   836	. inline int timer_create(const clockid_t which_clock, sigevent_p timer_event_spec, timer_p created_timer_id)
   837	.   __attribute__((__always_inline__));
   838	. // __NR__ timer_settime = 223 
   839	. 
   840	. inline int timer_settime(timer_t timer_id, int flags, itimerspec_p new_setting, itimerspec_p old_setting)
   841	.   __attribute__((__always_inline__));
   842	. // __NR__ timer_gettime = 224 
   843	. 
   844	. inline int timer_gettime(timer_t timer_id, itimerspec_p setting)
   845	.   __attribute__((__always_inline__));
   846	. // __NR__ timer_getoverrun = 225 
   847	. 
   848	. inline int timer_getoverrun(timer_t timer_id)
   849	.   __attribute__((__always_inline__));
   850	. // __NR__ timer_delete = 226 
   851	. 
   852	. inline int timer_delete(timer_t timer_id)
   853	.   __attribute__((__always_inline__));
   854	. // __NR__ clock_settime = 227 
   855	. 
   856	. inline int clock_settime(const clockid_t which_clock, timespec_p tp)
   857	.   __attribute__((__always_inline__));
   858	. // __NR__ clock_gettime = 228 
   859	. 
   860	. inline int clock_gettime(const clockid_t which_clock, timespec_p tp)
   861	.   __attribute__((__always_inline__));
   862	. // __NR__ clock_getres = 229 
   863	. 
   864	. inline int clock_getres(const clockid_t which_clock, timespec_p tp)
   865	.   __attribute__((__always_inline__));
   866	. // __NR__ clock_nanosleep = 230 
   867	. 
   868	. inline int clock_nanosleep(const clockid_t which_clock, int flags, timespec_p rqtp, timespec_p rmtp)
   869	.   __attribute__((__always_inline__));
   870	. // __NR__ exit_group = 231 
   871	. 
   872	. inline int exit_group(int error_code)
   873	.   __attribute__((__always_inline__));
   874	. // __NR__ epoll_wait = 232 
   875	. 
   876	. inline int epoll_wait(int epfd, epoll_event_p events, int maxevents, int timeout)
   877	.   __attribute__((__always_inline__));
   878	. // __NR__ epoll_ctl = 233 
   879	. 
   880	. inline int epoll_ctl(int epfd, int op, fd_t fd, epoll_event_p event)
   881	.   __attribute__((__always_inline__));
   882	. // __NR__ tgkill = 234 
   883	. 
   884	. inline int tgkill(pid_t tgid, pid_t pid, int sig)
   885	.   __attribute__((__always_inline__));
   886	. // __NR__ utimes = 235 
   887	. 
   888	. inline int utimes(ostr_t filename, timeval_p utimes)
   889	.   __attribute__((__always_inline__));
   890	. // __NR__ mbind = 237 
   891	. 
   892	. inline int mbind(uint64_t start, uint64_t len, uint64_t mode, uint64_p nmask, uint64_t maxnode, unsigned flags)
   893	.   __attribute__((__always_inline__));
   894	. // __NR__ set_mempolicy = 238 
   895	. 
   896	. inline int set_mempolicy(int mode, uint64_p nmask, uint64_t maxnode)
   897	.   __attribute__((__always_inline__));
   898	. // __NR__ get_mempolicy = 239 
   899	. 
   900	. inline int get_mempolicy(int32_p policy, uint64_p nmask, uint64_t maxnode, uint64_t addr, uint64_t flags)
   901	.   __attribute__((__always_inline__));
   902	. // __NR__ mq_open = 240 
   903	. 
   904	. inline int mq_open(istr_t u_name, int oflag, mode_t mode, mq_attr_p u_attr)
   905	.   __attribute__((__always_inline__));
   906	. // __NR__ mq_unlink = 241 
   907	. 
   908	. inline int mq_unlink(istr_t u_name)
   909	.   __attribute__((__always_inline__));
   910	. // __NR__ mq_timedsend = 242 
   911	. 
   912	. inline int mq_timedsend(mqd_t mqdes, istr_t u_msg_ptr, size_t msg_len, unsigned msg_prio, timespec_p u_abs_timeout)
   913	.   __attribute__((__always_inline__));
   914	. // __NR__ mq_timedreceive = 243 
   915	. 
   916	. inline int mq_timedreceive(mqd_t mqdes, ostr_t u_msg_ptr, size_t msg_len, uint32_p u_msg_prio, timespec_p u_abs_timeout)
   917	.   __attribute__((__always_inline__));
   918	. // __NR__ mq_notify = 244 
   919	. 
   920	. inline int mq_notify(mqd_t mqdes, sigevent_p u_notification)
   921	.   __attribute__((__always_inline__));
   922	. // __NR__ mq_getsetattr = 245 
   923	. 
   924	. inline int mq_getsetattr(mqd_t mqdes, mq_attr_p u_mqstat, mq_attr_p u_omqstat)
   925	.   __attribute__((__always_inline__));
   926	. // __NR__ kexec_load = 246 
   927	. 
   928	. inline int kexec_load(uint64_t entry, uint64_t nr_segments, kexec_segment_p segments, uint64_t flags)
   929	.   __attribute__((__always_inline__));
   930	. // __NR__ waitid = 247 
   931	. 
   932	. inline int waitid(int which, pid_t upid, siginfo_p infop, int options, rusage_p ru)
   933	.   __attribute__((__always_inline__));
   934	. // __NR__ add_key = 248 
   935	. 
   936	. inline int add_key(istr_t _type, istr_t _description, const void_p _payload, size_t plen)
   937	.   __attribute__((__always_inline__));
   938	. // __NR__ request_key = 249 
   939	. 
   940	. inline int request_key(istr_t _type, istr_t _description, istr_t _callout_info, uint64_t destringid)
   941	.   __attribute__((__always_inline__));
   942	. // __NR__ keyctl = 250 
   943	. 
   944	. inline int keyctl(int option, uint64_t arg2, uint64_t arg3, uint64_t arg4, uint64_t arg5)
   945	.   __attribute__((__always_inline__));
   946	. // __NR__ ioprio_set = 251 
   947	. 
   948	. inline int ioprio_set(int which, int who, int ioprio)
   949	.   __attribute__((__always_inline__));
   950	. // __NR__ ioprio_get = 252 
   951	. 
   952	. inline int ioprio_get(int which, int who)
   953	.   __attribute__((__always_inline__));
   954	. // __NR__ inotify_init = 253 
   955	. 
   956	. inline int inotify_init()
   957	.   __attribute__((__always_inline__));
   958	. // __NR__ inotify_add_watch = 254 
   959	. 
   960	. inline int inotify_add_watch(fd_t fd, istr_t pathname, uint32_t mask)
   961	.   __attribute__((__always_inline__));
   962	. // __NR__ inotify_rm_watch = 255 
   963	. 
   964	. inline int inotify_rm_watch(fd_t fd, int32_t wd)
   965	.   __attribute__((__always_inline__));
   966	. // __NR__ migrate_pages = 256 
   967	. 
   968	. inline int migrate_pages(pid_t pid, uint64_t maxnode, uint64_p old_nodes, uint64_p new_nodes)
   969	.   __attribute__((__always_inline__));
   970	. // __NR__ openat = 257 
   971	. 
   972	. inline int openat(fd_t dfd, istr_t filename, int flags, int mode)
   973	.   __attribute__((__always_inline__));
   974	. // __NR__ mkdirat = 258 
   975	. 
   976	. inline int mkdirat(fd_t dfd, istr_t pathname, int mode)
   977	.   __attribute__((__always_inline__));
   978	. // __NR__ mknodat = 259 
   979	. 
   980	. inline int mknodat(fd_t dfd, istr_t filename, int mode, unsigned dev)
   981	.   __attribute__((__always_inline__));
   982	. // __NR__ fchownat = 260 
   983	. 
   984	. inline int fchownat(fd_t dfd, istr_t filename, uid_t user, gid_t group, int flag)
   985	.   __attribute__((__always_inline__));
   986	. // __NR__ futimesat = 261 
   987	. 
   988	. inline int futimesat(fd_t dfd, istr_t filename, timeval_p utimes)
   989	.   __attribute__((__always_inline__));
   990	. // __NR__ newfstatat = 262 
   991	. 
   992	. inline int newfstatat(fd_t dfd, istr_t filename, stat_p statbuf, int flag)
   993	.   __attribute__((__always_inline__));
   994	. // __NR__ unlinkat = 263 
   995	. 
   996	. inline int unlinkat(fd_t dfd, istr_t pathname, int flag)
   997	.   __attribute__((__always_inline__));
   998	. // __NR__ renameat = 264 
   999	. 
  1000	. inline int renameat(fd_t oldfd, istr_t oldname, fd_t newfd, istr_t newname)
  1001	.   __attribute__((__always_inline__));
  1002	. // __NR__ linkat = 265 
  1003	. 
  1004	. inline int linkat(fd_t oldfd, istr_t oldname, fd_t newfd, istr_t newname, int flags)
  1005	.   __attribute__((__always_inline__));
  1006	. // __NR__ symlinkat = 266 
  1007	. 
  1008	. inline int symlinkat(istr_t oldname, fd_t newfd, istr_t newname)
  1009	.   __attribute__((__always_inline__));
  1010	. // __NR__ readlinkat = 267 
  1011	. 
  1012	. inline int readlinkat(fd_t dfd, istr_t pathname, ostr_t buf, int bufsiz)
  1013	.   __attribute__((__always_inline__));
  1014	. // __NR__ fchmodat = 268 
  1015	. 
  1016	. inline int fchmodat(fd_t dfd, istr_t filename, mode_t mode)
  1017	.   __attribute__((__always_inline__));
  1018	. // __NR__ faccessat = 269 
  1019	. 
  1020	. inline int faccessat(fd_t dfd, istr_t filename, int mode)
  1021	.   __attribute__((__always_inline__));
  1022	. // __NR__ pselect6 = 270 
  1023	. 
  1024	. inline int pselect6(int n, fd_set_p inp, fd_set_p outp, fd_set_p exp, timespec_p tsp, void_p sig)
  1025	.   __attribute__((__always_inline__));
  1026	. // __NR__ ppoll = 271 
  1027	. 
  1028	. inline int ppoll(pollfd_p ufds, unsigned nfds, timespec_p tsp, const sigset_p sigmask, size_t sigsetsize)
  1029	.   __attribute__((__always_inline__));
  1030	. // __NR__ unshare = 272 
  1031	. 
  1032	. inline int unshare(int unshare_flags)
  1033	.   __attribute__((__always_inline__));
  1034	. // __NR__ set_robust_list = 273 
  1035	. 
  1036	. inline int set_robust_list(robust_list_head_p head, size_t len)
  1037	.   __attribute__((__always_inline__));
  1038	. // __NR__ get_robust_list = 274 
  1039	. 
  1040	. inline int get_robust_list(int pid, robust_list_head_p head_ptr, size_p len_ptr)
  1041	.   __attribute__((__always_inline__));
  1042	. // __NR__ splice = 275 
  1043	. 
  1044	. inline int splice(int fd_in, off_p off_in, int fd_out, off_p off_out, size_t len, unsigned flags)
  1045	.   __attribute__((__always_inline__));
  1046	. // __NR__ tee = 276 
  1047	. 
  1048	. inline int tee(int fdin, int fdout, size_t len, unsigned flags)
  1049	.   __attribute__((__always_inline__));
  1050	. // __NR__ sync_file_range = 277 
  1051	. 
  1052	. inline int sync_file_range(fd_t fd, off_t offset, off_t bytes, long flags)
  1053	.   __attribute__((__always_inline__));
  1054	. // __NR__ vmsplice = 278 
  1055	. 
  1056	. inline int vmsplice(fd_t fd, iovec_p iov, uint64_t nr_segs, unsigned flags)
  1057	.   __attribute__((__always_inline__));
  1058	. // __NR__ move_pages = 279 
  1059	. 
  1060	. inline int move_pages(pid_t pid, uint64_t nr_pages, void_p pages, int32_p nodes, int32_p status, int flags)
  1061	.   __attribute__((__always_inline__));
  1062	. // __NR__ utimensat = 280 
  1063	. 
  1064	. inline int utimensat(fd_t dfd, istr_t filename, timespec_p utimes, int flags)
  1065	.   __attribute__((__always_inline__));
  1066	. // __NR__ epoll_pwait = 281 
  1067	. 
  1068	. inline int epoll_pwait(int epfd, epoll_event_p events, int maxevents, int timeout, const sigset_p sigmask, size_t sigsetsize)
  1069	.   __attribute__((__always_inline__));
  1070	. // __NR__ signalfd = 282 
  1071	. 
  1072	. inline int signalfd(int ufd, sigset_p user_mask, size_t sizemask)
  1073	.   __attribute__((__always_inline__));
  1074	. // __NR__ timerfd_create = 283 
  1075	. 
  1076	. inline int timerfd_create(int clockid, int flags)
  1077	.   __attribute__((__always_inline__));
  1078	. // __NR__ eventfd = 284 
  1079	. 
  1080	. inline int eventfd(unsigned count)
  1081	.   __attribute__((__always_inline__));
  1082	. // __NR__ fallocate = 285 
  1083	. 
  1084	. inline int fallocate(fd_t fd, long mode, off_t offset, off_t len)
  1085	.   __attribute__((__always_inline__));
  1086	. // __NR__ timerfd_settime = 286 
  1087	. 
  1088	. inline int timerfd_settime(int ufd, int flags, itimerspec_p utmr, itimerspec_p otmr)
  1089	.   __attribute__((__always_inline__));
  1090	. // __NR__ timerfd_gettime = 287 
  1091	. 
  1092	. inline int timerfd_gettime(int ufd, itimerspec_p otmr)
  1093	.   __attribute__((__always_inline__));
  1094	. // __NR__ accept4 = 288 
  1095	. 
  1096	. inline int accept4(fd_t fd, sockaddr_p upeer_sockaddr, int32_p upeer_addrlen, int flags)
  1097	.   __attribute__((__always_inline__));
  1098	. // __NR__ signalfd4 = 289 
  1099	. 
  1100	. inline int signalfd4(int ufd, sigset_p user_mask, size_t sizemask, int flags)
  1101	.   __attribute__((__always_inline__));
  1102	. // __NR__ eventfd2 = 290 
  1103	. 
  1104	. inline int eventfd2(unsigned count, int flags)
  1105	.   __attribute__((__always_inline__));
  1106	. // __NR__ epoll_create1 = 291 
  1107	. 
  1108	. inline int epoll_create1(int flags)
  1109	.   __attribute__((__always_inline__));
  1110	. // __NR__ dup3 = 292 
  1111	. 
  1112	. inline int dup3(fd_t oldfd, fd_t newfd, int flags)
  1113	.   __attribute__((__always_inline__));
  1114	. // __NR__ pipe2 = 293 
  1115	. 
  1116	. inline int pipe2(fd_p filedes, int flags)
  1117	.   __attribute__((__always_inline__));
  1118	. // __NR__ inotify_init1 = 294 
  1119	. 
  1120	. inline int inotify_init1(int flags)
  1121	.   __attribute__((__always_inline__));
  1122	. // __NR__ preadv = 295 
  1123	. 
  1124	. inline int preadv(fd_t fd, iovec_p vec, uint64_t vlen, uint64_t pos_l, uint64_t pos_h)
  1125	.   __attribute__((__always_inline__));
  1126	. // __NR__ pwritev = 296 
  1127	. 
  1128	. inline int pwritev(fd_t fd, iovec_p vec, uint64_t vlen, uint64_t pos_l, uint64_t pos_h)
  1129	.   __attribute__((__always_inline__));
  1130	. // __NR__ rt_tgsigqueueinfo = 297 
  1131	. 
  1132	. inline int rt_tgsigqueueinfo(pid_t tgid, pid_t pid, int sig, siginfo_p uinfo)
  1133	.   __attribute__((__always_inline__));
  1134	. // __NR__ perf_event_open = 298 
  1135	. 
  1136	. inline int perf_event_open(perf_event_attr_p attr_uptr, pid_t pid, int cpu, int group_fd, uint64_t flags)
  1137	.   __attribute__((__always_inline__));
  1138	. // __NR__ recvmmsg = 299 
  1139	. 
  1140	. inline int recvmmsg(fd_t fd, msghdr_p mmsg, unsigned vlen, unsigned flags, timespec_p timeout)
  1141	.   __attribute__((__always_inline__));
  1142	. // __NR__ fanotify_init = 300 
  1143	. 
  1144	. inline int fanotify_init(unsigned flags, unsigned event_f_flags)
  1145	.   __attribute__((__always_inline__));
  1146	. // __NR__ fanotify_mark = 301 
  1147	. 
  1148	. inline int fanotify_mark(long fanotify_fd, long flags, uint64_t mask, fd_t dfd, long pathname)
  1149	.   __attribute__((__always_inline__));
  1150	. // __NR__ prlimit64 = 302 
  1151	. 
  1152	. inline int prlimit64(pid_t pid, unsigned resource, rlimit64_p new_rlim, rlimit64_p old_rlim)
  1153	.   __attribute__((__always_inline__));
  1154	. // __NR__ name_to_handle_at = 303 
  1155	. 
  1156	. inline int name_to_handle_at(fd_t dfd, istr_t name, file_handle_p handle, int32_p mnt_id, int flag)
  1157	.   __attribute__((__always_inline__));
  1158	. // __NR__ open_by_handle_at = 304 
  1159	. 
  1160	. inline int open_by_handle_at(fd_t dfd, istr_t name, file_handle_p handle, int32_p mnt_id, int flags)
  1161	.   __attribute__((__always_inline__));
  1162	. // __NR__ clock_adjtime = 305 
  1163	. 
  1164	. inline int clock_adjtime(clockid_t which_clock, timex_p tx)
  1165	.   __attribute__((__always_inline__));
  1166	. // __NR__ syncfs = 306 
  1167	. 
  1168	. inline int syncfs(fd_t fd)
  1169	.   __attribute__((__always_inline__));
  1170	. // __NR__ sendmmsg = 307 
  1171	. 
  1172	. inline int sendmmsg(fd_t fd, msghdr_p mmsg, unsigned vlen, unsigned flags)
  1173	.   __attribute__((__always_inline__));
  1174	. // __NR__ setns = 308 
  1175	. 
  1176	. inline int setns(fd_t fd, int nstype)
  1177	.   __attribute__((__always_inline__));
  1178	. // __NR__ getcpu = 309 
  1179	. 
  1180	. inline int getcpu(uint32_p cpup, uint32_p nodep)
  1181	.   __attribute__((__always_inline__));
  1182	. // __NR__ process_vm_readv = 310 
  1183	. 
  1184	. inline int process_vm_readv(pid_t pid, iovec_p lvec, uint64_t liovcnt, iovec_p rvec, uint64_t riovcnt, uint64_t flags)
  1185	.   __attribute__((__always_inline__));
  1186	. // __NR__ process_vm_writev = 311 
  1187	. 
  1188	. inline int process_vm_writev(pid_t pid, iovec_p lvec, uint64_t liovcnt, iovec_p rvec, uint64_t riovcnt, uint64_t flags)
  1189	.   __attribute__((__always_inline__));
  1190	. // __NR__ kcmp = 312 
  1191	. 
  1192	. inline int kcmp(pid_t pid1, pid_t pid2, int type, uint64_t idx1, uint64_t idx2)
  1193	.   __attribute__((__always_inline__));
  1194	. // __NR__ finit_module = 313 
  1195	. 
  1196	. inline int finit_module(fd_t fd, istr_t uargs, int flags)
  1197	.   __attribute__((__always_inline__));
  1198	. // __NR__ sched_setattr = 314 
  1199	. 
  1200	. inline int sched_setattr(pid_t pid, sched_attr_p attr, unsigned flags)
  1201	.   __attribute__((__always_inline__));
  1202	. // __NR__ sched_getattr = 315 
  1203	. 
  1204	. inline int sched_getattr(pid_t pid, sched_attr_p attr, unsigned size, unsigned flags)
  1205	.   __attribute__((__always_inline__));
  1206	. // __NR__ renameat2 = 316 
  1207	. 
  1208	. inline int renameat2(int olddfd, istr_t oldname, int newdfd, istr_t newname, unsigned flags)
  1209	.   __attribute__((__always_inline__));
  1210	. // __NR__ seccomp = 317 
  1211	. 
  1212	. inline int seccomp(unsigned op, unsigned flags, istr_t uargs)
  1213	.   __attribute__((__always_inline__));
  1214	. // __NR__ getrandom = 318 
  1215	. 
  1216	. inline int getrandom(ostr_t buf, size_t count, unsigned flags)
  1217	.   __attribute__((__always_inline__));
  1218	. // __NR__ memfd_create = 319 
  1219	. 
  1220	. inline int memfd_create(istr_t uname_ptr, unsigned flags)
  1221	.   __attribute__((__always_inline__));
  1222	. // __NR__ kexec_file_load = 320 
  1223	. 
  1224	. inline int kexec_file_load(int kernel_fd, int initrd_fd, size_t cmdline_len, istr_t cmdline_ptr, uint64_t flags)
  1225	.   __attribute__((__always_inline__));
  1226	. // __NR__ bpf = 321 
  1227	. 
  1228	. inline int bpf(int cmd, bpf_attr_p attr, unsigned size)
  1229	.   __attribute__((__always_inline__));
  1230	. // __NR__ stub_execveat = 322 
  1231	. 
  1232	. inline int stub_execveat(fd_t dfd, istr_t filename, istr_v argv, istr_v envp, int flags)
  1233	.   __attribute__((__always_inline__));
  1234	. // __NR__ userfaultfd = 323 
  1235	. 
  1236	. inline int userfaultfd(int flags)
  1237	.   __attribute__((__always_inline__));
  1238	. // __NR__ membarrier = 324 
  1239	. 
  1240	. inline int membarrier(int cmd, int flags)
  1241	.   __attribute__((__always_inline__));
  1242	. // __NR__ mlock2 = 325 
  1243	. 
  1244	. inline int mlock2(uint64_t start, size_t len, int flags)
  1245	.   __attribute__((__always_inline__));
  1246	. // __NR__ copy_file_range = 326 
  1247	. 
  1248	. inline int copy_file_range(fd_t fd_in, off_p off_in, fd_t fd_out, off_p off_out, size_t len, unsigned flags)
  1249	.   __attribute__((__always_inline__));
  1250	. // __NR__ preadv2 = 327 
  1251	. 
  1252	. inline int preadv2(fd_t fd, iovec_p vec, uint64_t vlen, uint64_t pos_l, uint64_t pos_h, int flags)
  1253	.   __attribute__((__always_inline__));
  1254	. // __NR__ pwritev2 = 328 
  1255	. 
  1256	. inline int pwritev2(fd_t fd, iovec_p vec, uint64_t vlen, uint64_t pos_l, uint64_t pos_h, int flags)
  1257	.   __attribute__((__always_inline__));
  1258	. }
FILE: END: doc/all_syscalls.h
FILE: START: doc/git-log.txt
HASH: MD5: 24e02bb64688f2785ed49758d53c56bb
     1	. commit 2e3f02e7aad58683873e0fc5251bb3f5761efdf9
     2	. Author: nobody <github2@invisiblehand.church>
     3	. Date:   Wed May 1 04:29:37 2024 -0400
     4	. 
     5	.     x
     6	. 
     7	. commit 4fcf2d36e777e6e0aca42ddf00c9241a0f25ad27
     8	. Author: nobody <github2@invisiblehand.church>
     9	. Date:   Tue Apr 30 21:36:41 2024 -0400
    10	. 
    11	.     x
    12	. 
    13	. commit 61e667f90e8c619267400c74e26357d6f67938be
    14	. Author: nobody <github2@invisiblehand.church>
    15	. Date:   Mon Apr 29 23:06:58 2024 -0400
    16	. 
    17	.     x
    18	. 
    19	. commit ac6d2c43727cae5ffb2df4146113912205ae5107
    20	. Author: nobody <github2@invisiblehand.church>
    21	. Date:   Mon Apr 29 22:54:37 2024 -0400
    22	. 
    23	.     x
    24	. 
    25	. commit 438828753d89f7aa575192a19909ae9e353833c7
    26	. Author: nobody <github2@invisiblehand.church>
    27	. Date:   Sun Nov 13 08:24:20 2022 -0500
    28	. 
    29	.     x
    30	. 
    31	. commit 6e84d4bc61bb15c25601215878d5d399ea4ba0aa
    32	. Author: nobody <github2@invisiblehand.church>
    33	. Date:   Thu Sep 8 19:20:14 2022 -0400
    34	. 
    35	.     x
    36	. 
    37	. commit a07463804f41843246ec48d6479ce33ab0f2a516
    38	. Author: nobody <github2@invisiblehand.church>
    39	. Date:   Thu Sep 8 19:18:47 2022 -0400
    40	. 
    41	.     x
    42	. 
    43	. commit 00f2d5e92cbce076373e0acbfc21a8b6f23b8923
    44	. Author: nobody <github2@invisiblehand.church>
    45	. Date:   Sun Aug 30 20:03:56 2020 -0400
    46	. 
    47	.     x
    48	. 
    49	. commit fe88d6d9084b331641eca0a801182480d87c853e
    50	. Author: nobody <github2@invisiblehand.church>
    51	. Date:   Sun Aug 30 18:56:33 2020 -0400
    52	. 
    53	.     x
    54	. 
    55	. commit ef71a6bf00bad3a25d0627aae6fbd87466083510
    56	. Author: nobody <github2@invisiblehand.church>
    57	. Date:   Sun Aug 30 18:53:27 2020 -0400
    58	. 
    59	.     x
    60	. 
    61	. commit 2a77f111b5d687a804fef29b833d5a45b584f83b
    62	. Author: nobody <github2@invisiblehand.church>
    63	. Date:   Sun Aug 30 18:08:04 2020 -0400
    64	. 
    65	.     x
    66	. 
    67	. commit 86ddc1c9ba9ed82345d0288c38e225fa9d7438f5
    68	. Author: nobody <github2@invisiblehand.church>
    69	. Date:   Sun Aug 30 18:06:43 2020 -0400
    70	. 
    71	.     moved flag files into etc
    72	. 
    73	. commit 371f08316d0736861cd6964b6d8bdb5cb48a9ce8
    74	. Author: nobody <github2@invisiblehand.church>
    75	. Date:   Sun Aug 30 18:04:58 2020 -0400
    76	. 
    77	.     Adding dbg.hh, removing iostreams from it
    78	. 
    79	. commit f61ad0644c40869b46fb3a1e82ece2cc7f4a35cf
    80	. Author: nobody <github2@invisiblehand.church>
    81	. Date:   Sun Aug 30 17:57:06 2020 -0400
    82	. 
    83	.     compiles
    84	. 
    85	. commit a24c29477564085413a2fecd94dea394310e79ce
    86	. Author: nobody <github2@invisiblehand.church>
    87	. Date:   Sun Aug 30 17:27:07 2020 -0400
    88	. 
    89	.     x
    90	. 
    91	. commit 77a1001edc8fb3293036cd537827ca40e38188e4
    92	. Author: nobody <github2@invisiblehand.church>
    93	. Date:   Sun Aug 30 16:19:40 2020 -0400
    94	. 
    95	.     got report working, and made new depends.pl
    96	. 
    97	. commit 6a74a27065b5d6c13828edc16228ea71b1c02ac6
    98	. Author: nobody <github2@invisiblehand.church>
    99	. Date:   Sun Aug 30 16:17:45 2020 -0400
   100	. 
   101	.     x
   102	. 
   103	. commit 8047fc3fbd1a93de41557284aff03e3d4d8535f9
   104	. Author: nobody <github2@invisiblehand.church>
   105	. Date:   Sun Aug 30 15:53:29 2020 -0400
   106	. 
   107	.     x
   108	. 
   109	. commit 0d5fcee4cbb67e9aac9ea52881a7a5beda0c2217
   110	. Author: nobody <github2@invisiblehand.church>
   111	. Date:   Sun Aug 30 15:53:12 2020 -0400
   112	. 
   113	.     x
   114	. 
   115	. commit fac8783e27c9d2a5c672793851e0d29fd9fdc794
   116	. Author: nobody <github2@invisiblehand.church>
   117	. Date:   Sun Aug 30 10:50:55 2020 -0400
   118	. 
   119	.     x
   120	. 
   121	. commit 816902c3c84b76e29833444445356d9a97eac8b5
   122	. Author: Nobody <rich.freeman.paul@gmail.com>
   123	. Date:   Wed Jun 3 12:12:19 2020 -0500
   124	. 
   125	.     many updates
   126	. 
   127	. commit 24671a9b677bed805b12bce1e075fc91dc1fb5f0
   128	. Author: Nobody <rich.freeman.paul@gmail.com>
   129	. Date:   Mon May 25 10:35:45 2020 -0500
   130	. 
   131	.     started to add string_view.
   132	. 
   133	. commit bebf26e77172859fff3a485956ace2c901e14981
   134	. Author: Nobody <rich.freeman.paul@gmail.com>
   135	. Date:   Thu May 14 17:01:35 2020 -0500
   136	. 
   137	.     cleaned up ls
   138	. 
   139	. commit f709c40a67c3c98cd4ddfd448baf06cbb49f4962
   140	. Author: Nobody <rich.freeman.paul@gmail.com>
   141	. Date:   Thu May 14 15:53:57 2020 -0500
   142	. 
   143	.     adf
   144	. 
   145	. commit d9e1f3a615e49939ccc0adda6d7b9b89da335e5a
   146	. Author: Nobody <rich.freeman.paul@gmail.com>
   147	. Date:   Thu May 14 15:46:19 2020 -0500
   148	. 
   149	.     asdf
   150	. 
   151	. commit d9cc84e762006bcc2e4a3ba33257a7678b1e64f4
   152	. Author: Nobody <rich.freeman.paul@gmail.com>
   153	. Date:   Thu May 14 15:45:37 2020 -0500
   154	. 
   155	.     asdf
   156	. 
   157	. commit bba44d1afaf2bbd0a5e65c87e688097eb9068dfb
   158	. Author: Nobody <rich.freeman.paul@gmail.com>
   159	. Date:   Thu May 14 15:39:02 2020 -0500
   160	. 
   161	.     adf
   162	. 
   163	. commit 2aad04d40ec1c483f4f8a251ee4f3a377f4d2243
   164	. Author: Nobody <rich.freeman.paul@gmail.com>
   165	. Date:   Thu May 14 15:38:51 2020 -0500
   166	. 
   167	.     adf
   168	. 
   169	. commit 8f1420705d542c2535d474981e06da4b26542b2a
   170	. Author: Nobody <rich.freeman.paul@gmail.com>
   171	. Date:   Thu May 14 15:34:18 2020 -0500
   172	. 
   173	.     adf
   174	. 
   175	. commit 721bcab5029e890c8ec77a73bf5d4046ce4f6b41
   176	. Author: Nobody <rich.freeman.paul@gmail.com>
   177	. Date:   Thu May 14 15:32:12 2020 -0500
   178	. 
   179	.     asdf
   180	. 
   181	. commit 4212421f1298eb11103e84ea9169e18ebe963f00
   182	. Author: Nobody <rich.freeman.paul@gmail.com>
   183	. Date:   Thu May 14 15:24:08 2020 -0500
   184	. 
   185	.     as
   186	. 
   187	. commit dbcd2a14b6616f7a9bb612a7552fce0f4a66f580
   188	. Author: Nobody <rich.freeman.paul@gmail.com>
   189	. Date:   Thu May 14 15:21:53 2020 -0500
   190	. 
   191	.     adf`
   192	. 
   193	. commit a42bc230eab343c80fcbe4d840eca74f3571a94a
   194	. Author: Nobody <rich.freeman.paul@gmail.com>
   195	. Date:   Thu May 14 15:21:14 2020 -0500
   196	. 
   197	.     adf
   198	. 
   199	. commit 6475915e5cce1801e52747dfd3fff882d0391d05
   200	. Author: Nobody <rich.freeman.paul@gmail.com>
   201	. Date:   Thu May 14 15:13:49 2020 -0500
   202	. 
   203	.     afd
   204	. 
   205	. commit 6aeb2f498fa2a1604020e150f90094414aa65d7a
   206	. Author: Nobody <rich.freeman.paul@gmail.com>
   207	. Date:   Thu May 14 15:13:39 2020 -0500
   208	. 
   209	.     removed assert
   210	. 
   211	. commit c67808a48b209d63a9fbbc082d1670402e91d3f2
   212	. Author: Nobody <rich.freeman.paul@gmail.com>
   213	. Date:   Thu May 14 15:11:46 2020 -0500
   214	. 
   215	.     remove assert
   216	. 
   217	. commit 7f67129407df7778c6693b8ee632dfd351e558dd
   218	. Author: Nobody <rich.freeman.paul@gmail.com>
   219	. Date:   Thu May 14 15:09:04 2020 -0500
   220	. 
   221	.     adf
   222	. 
   223	. commit 3eec517fe66a9e26593c6dfd7330e0d43e670738
   224	. Author: Nobody <rich.freeman.paul@gmail.com>
   225	. Date:   Thu May 14 15:08:48 2020 -0500
   226	. 
   227	.     asdf
   228	. 
   229	. commit 1ae582e41a3b3ed6c5bf3e34882b620cbc63db78
   230	. Author: Nobody <rich.freeman.paul@gmail.com>
   231	. Date:   Thu May 14 15:03:49 2020 -0500
   232	. 
   233	.     removed rc
   234	. 
   235	. commit 8caf2ad666cf382f46dbb3a9596882427d5d94c0
   236	. Author: Nobody <rich.freeman.paul@gmail.com>
   237	. Date:   Thu May 14 15:02:48 2020 -0500
   238	. 
   239	.     removed debug
   240	. 
   241	. commit b7523d24bb956ea4157c8ebadf8f7b4ad7b3f233
   242	. Author: Nobody <rich.freeman.paul@gmail.com>
   243	. Date:   Thu May 14 15:02:24 2020 -0500
   244	. 
   245	.     removed old debug stuff.
   246	. 
   247	. commit 70a8b36a595a1c8924299177c2181aad23b16dac
   248	. Author: Nobody <rich.freeman.paul@gmail.com>
   249	. Date:   Thu May 14 14:58:21 2020 -0500
   250	. 
   251	.     added .gitignnore
   252	. 
   253	. commit 8f9c3aeee7205ccc28f2eb837c1f0d9704d58ceb
   254	. Author: Nobody <rich.freeman.paul@gmail.com>
   255	. Date:   Thu May 14 13:48:05 2020 -0500
   256	. 
   257	.     as
   258	. 
   259	. commit 1cacffdec0ca7c3ffbf2c1060b7cb9c2815ab38d
   260	. Author: Nobody <rich.freeman.paul@gmail.com>
   261	. Date:   Thu May 14 13:46:52 2020 -0500
   262	. 
   263	.     asdf
   264	. 
   265	. commit c867efc8cc9eac5aedcc31520cab245042d7d133
   266	. Author: Nobody <rich.freeman.paul@gmail.com>
   267	. Date:   Sun May 10 21:39:28 2020 -0500
   268	. 
   269	.     x
   270	. 
   271	. commit b40cb9b646b638e965d20d2ecae5d580d91ce063
   272	. Author: Nobody <rich.freeman.paul@gmail.com>
   273	. Date:   Mon May 4 01:04:15 2020 -0400
   274	. 
   275	.     killed empty file
   276	. 
   277	. commit c70c5076df071e197e0cc986b5c9c20f378ae3da
   278	. Author: Nobody <rich.freeman.paul@gmail.com>
   279	. Date:   Mon May 4 01:02:28 2020 -0400
   280	. 
   281	.     idk what i did.
   282	. 
   283	. commit 2b6778790e15c5571fd6dedc923d834e56009508
   284	. Author: Nobody <rich.freeman.paul@gmail.com>
   285	. Date:   Sat Feb 1 21:21:42 2020 -0500
   286	. 
   287	.     fixed line numbers for created file.
   288	. 
   289	. commit 665445d66318bc340590d0ca9dbe3e67b14ff92a
   290	. Author: Nobody <rich.freeman.paul@gmail.com>
   291	. Date:   Sat Feb 1 21:19:34 2020 -0500
   292	. 
   293	.     updated gitignore
   294	. 
   295	. commit 318445e915f1732a67af838d6d3845c99ebb4b8d
   296	. Author: Nobody <rich.freeman.paul@gmail.com>
   297	. Date:   Sat Feb 1 21:19:08 2020 -0500
   298	. 
   299	.     added openhack
   300	. 
   301	. commit 9bfec9b53b2679f02a14a0b86a031b8c7e2b5ab5
   302	. Author: Nobody <rich.freeman.paul@gmail.com>
   303	. Date:   Sat Feb 1 21:17:55 2020 -0500
   304	. 
   305	.     general cleanup.
   306	. 
   307	. commit eb3495adcd12c8f245ef7aa2ef2e4b4452511f98
   308	. Author: Nobody <rich.freeman.paul@gmail.com>
   309	. Date:   Sat Feb 1 21:17:28 2020 -0500
   310	. 
   311	.     general cleanup
   312	. 
   313	. commit ac72033ae281bb776087b78ae392dfdbb55e9ebe
   314	. Author: Nobody <rich.freeman.paul@gmail.com>
   315	. Date:   Sat Feb 1 21:15:35 2020 -0500
   316	. 
   317	.     removed my-file.  better solution found elsewhere.
   318	. 
   319	. commit 396a03d3041243310af889b8e1be9984ecb33edd
   320	. Author: Nobody <rich.freeman.paul@gmail.com>
   321	. Date:   Sat Feb 1 21:14:48 2020 -0500
   322	. 
   323	.     a
   324	. 
   325	. commit 9bc3a6081b4bd497e46d0dc26e4e657e8220ded2
   326	. Author: Nobody <rich.freeman.paul@gmail.com>
   327	. Date:   Sun Jan 26 15:23:03 2020 -0500
   328	. 
   329	.     cleaned up the pstree module
   330	. 
   331	. commit f6f4b9646cf58c5e212d42aa4efd51d4a035ec19
   332	. Author: Nobody <rich.freeman.paul@gmail.com>
   333	. Date:   Sun Jan 26 02:47:34 2020 -0500
   334	. 
   335	.     renamed to pstree
   336	. 
   337	. commit b26d6e57d30c184ca98220d2269fceb671cb05c6
   338	. Author: Nobody <rich.freeman.paul@gmail.com>
   339	. Date:   Sun Jan 26 02:47:24 2020 -0500
   340	. 
   341	.     renamed to pstree
   342	. 
   343	. commit 08bd90abd269d0bb31e8a0e7db58e7ef2d2bed87
   344	. Author: Nobody <rich.freeman.paul@gmail.com>
   345	. Date:   Sun Jan 26 02:45:27 2020 -0500
   346	. 
   347	.     mod works
   348	. 
   349	. commit 68ca595c77ac99dd99990271c95482bf6bb96746
   350	. Author: Nobody <rich.freeman.paul@gmail.com>
   351	. Date:   Sun Jan 26 02:43:36 2020 -0500
   352	. 
   353	.     no idea
   354	. 
   355	. commit 71133184b76ed3f3fab9233af1098dfba5963fd9
   356	. Author: Nobody <rich.freeman.paul@gmail.com>
   357	. Date:   Sun Jan 26 02:42:49 2020 -0500
   358	. 
   359	.     I have no idea
   360	. 
   361	. commit cbcf9e3948e33de0d8f84659d970d9696d7d0351
   362	. Author: Nobody <rich.freeman.paul@gmail.com>
   363	. Date:   Sun Jan 26 02:40:34 2020 -0500
   364	. 
   365	.     Added shit
   366	. 
   367	. commit e224a981680228f958fb5eda8363f259bd18c243
   368	. Author: Nobody <rich.freeman.paul@gmail.com>
   369	. Date:   Sun Jan 26 01:37:43 2020 -0500
   370	. 
   371	.     added flags file
   372	. 
   373	. commit 39eb2f1be1b0c2eb76b8f84f1bfd85c1340dbe8e
   374	. Author: Nobody <rich.freeman.paul@gmail.com>
   375	. Date:   Sun Jan 26 01:34:21 2020 -0500
   376	. 
   377	.     compiles and links
   378	. 
   379	. commit 884f857733a1258bd48ef7fb92b20d5a417fa518
   380	. Author: Nobody <rich.freeman.paul@gmail.com>
   381	. Date:   Sat Jan 25 22:51:59 2020 -0500
   382	. 
   383	.     improved subdir handling.  still ugly.  Needs a rewrite
   384	. 
   385	. commit 86def6e2a0ac399bf21fa38847858932d6ec1d86
   386	. Author: Nobody <rich.freeman.paul@gmail.com>
   387	. Date:   Wed Jan 15 08:42:44 2020 -0500
   388	. 
   389	.     added write_buf
   390	. 
   391	. commit f6af56e1d730ed37d35999e8a0e4bdb6a2271e54
   392	. Author: Nobody <rich.freeman.paul@gmail.com>
   393	. Date:   Mon Jan 13 15:45:13 2020 -0500
   394	. 
   395	.     trying regular stl
   396	. 
   397	. commit 0cf8d99cb8ec381f6f6f9ae9dea7790a6319cdd0
   398	. Author: Nobody <rich.freeman.paul@gmail.com>
   399	. Date:   Mon Jan 13 15:18:30 2020 -0500
   400	. 
   401	.     started proc_file
   402	. 
   403	. commit 827df441fdd59bb5799c467d60ffd93c845eaf21
   404	. Author: Nobody <rich.freeman.paul@gmail.com>
   405	. Date:   Mon Jan 13 15:18:24 2020 -0500
   406	. 
   407	.     started proc_file
   408	. 
   409	. commit d14df4fe461a04e0591c257040ffa77d4c09457a
   410	. Author: Nobody <rich.freeman.paul@gmail.com>
   411	. Date:   Mon Jan 13 08:30:09 2020 -0500
   412	. 
   413	.     These are more like their names now.
   414	. 
   415	. commit 24c367964f9ab3f349d28c547a9cc303f48d18d0
   416	. Author: Nobody <rich.freeman.paul@gmail.com>
   417	. Date:   Mon Jan 13 08:26:29 2020 -0500
   418	. 
   419	.     Added apt-file replacement.
   420	. 
   421	. commit bb440c2cf20c15fcac0fcd04c6feaf1b8fa9a12b
   422	. Author: Nobody <rich.freeman.paul@gmail.com>
   423	. Date:   Fri Jan 10 05:02:57 2020 -0500
   424	. 
   425	.     cleaned up cat a bit
   426	. 
   427	. commit a417ad6ac9826b6d6c257b5a4851ff017fef0bfd
   428	. Author: Nobody <rich.freeman.paul@gmail.com>
   429	. Date:   Thu Jan 9 11:25:05 2020 -0500
   430	. 
   431	.     clean
   432	. 
   433	. commit 070d7f9fce1498cb4818143872c324e9673b7829
   434	. Author: Nobody <rich.freeman.paul@gmail.com>
   435	. Date:   Thu Jan 9 11:23:47 2020 -0500
   436	. 
   437	.     Added some shit.
   438	. 
   439	. commit dcfc17cc2679e10ee43bef6bb461efa8e283fecb
   440	. Author: Nobody <rich.freeman.paul@gmail.com>
   441	. Date:   Thu Jan 9 10:25:59 2020 -0500
   442	. 
   443	.     This was some intersting info I found.
   444	. 
   445	. commit b286836e22eda37fae6b5f7b43a1ef8284d8537a
   446	. Author: Nobody <rich.freeman.paul@gmail.com>
   447	. Date:   Thu Jan 9 10:25:35 2020 -0500
   448	. 
   449	.     a
   450	. 
   451	. commit db2a43fa286d2125b0960907ff25b43401838521
   452	. Author: Nobody <rich.freeman.paul@gmail.com>
   453	. Date:   Thu Jan 9 10:24:54 2020 -0500
   454	. 
   455	.     Added some stuff to the project.  It's mostly example code.
   456	. 
   457	. commit e104a24a020ac20caa8f7162b60c54a715ac1889
   458	. Author: Nobody <rich.freeman.paul@gmail.com>
   459	. Date:   Thu Jan 9 01:57:50 2020 -0500
   460	. 
   461	.     Moving some stuff around.
   462	. 
   463	. commit bcf1e761e0001e521979bdd31541dd8a6db06452
   464	. Author: Nobody <rich.freeman.paul@gmail.com>
   465	. Date:   Thu Jan 9 01:55:05 2020 -0500
   466	. 
   467	.     Added show code that played with numbers just for sizes and shit.
   468	. 
   469	. commit 5df70e4086836ad4a382b30e64d6ad7b2e6ffc7f
   470	. Author: Nobody <rich.freeman.paul@gmail.com>
   471	. Date:   Tue Jan 7 08:51:13 2020 -0500
   472	. 
   473	.     added nr display
   474	. 
   475	. commit f8b757c2285ef6d3f60f2db9292c222553d52a54
   476	. Author: Nobody <rich.freeman.paul@gmail.com>
   477	. Date:   Tue Jan 7 08:50:18 2020 -0500
   478	. 
   479	.     and some more stuff
   480	. 
   481	. commit 2630ea9898ddc53542aef443db472559d1e431dc
   482	. Author: Nobody <rich.freeman.paul@gmail.com>
   483	. Date:   Tue Jan 7 08:49:42 2020 -0500
   484	. 
   485	.     some formatting work, signals, yaknow
   486	. 
   487	. commit 71aaef4493fce6fe2b4060a0275b16e41ff70fe6
   488	. Author: Nobody <rich.freeman.paul@gmail.com>
   489	. Date:   Tue Jan 7 05:19:59 2020 -0500
   490	. 
   491	.     starting buffering in usleep.  weird place for it.
   492	. 
   493	. commit 4d170c11e57990bd629fb5b12b8729b6e91a039b
   494	. Author: Nobody <rich.freeman.paul@gmail.com>
   495	. Date:   Tue Jan 7 01:34:57 2020 -0500
   496	. 
   497	.     Fuck it.
   498	. 
   499	. commit 48080e8fe85ba7df5fc9b84f934f14728603948c
   500	. Author: Nobody <rich.freeman.paul@gmail.com>
   501	. Date:   Tue Jan 7 01:33:10 2020 -0500
   502	. 
   503	.     I had a lot of cruft to get rid of
   504	. 
   505	. commit e1b7047c0a5b79f2c66c1e8538c0680f917c546e
   506	. Author: Nobody <rich.freeman.paul@gmail.com>
   507	. Date:   Sun Jan 5 17:02:46 2020 -0500
   508	. 
   509	.     added module example
   510	. 
   511	. commit cf9ee033e2d4812d645d03731328eb700b62c41b
   512	. Author: Nobody <rich.freeman.paul@gmail.com>
   513	. Date:   Sun Dec 29 18:19:27 2019 -0500
   514	. 
   515	.     removed gdbinit
   516	. 
   517	. commit 186f8d46161dc0b967b45f77e947f6d0a7c25dd6
   518	. Author: Nobody <rich.freeman.paul@gmail.com>
   519	. Date:   Sun Dec 29 18:19:04 2019 -0500
   520	. 
   521	.     cleanups.  Idk
   522	. 
   523	. commit b8126ea75f0aa2d5ee1ab308b0d00ea6087c5c16
   524	. Author: Nobody <rich.freeman.paul@gmail.com>
   525	. Date:   Sun Dec 29 18:17:46 2019 -0500
   526	. 
   527	.     More ignores
   528	. 
   529	. commit d4f2e1f2a7bf8037496e7a85515513b64053a178
   530	. Author: Nobody <rich.freeman.paul@gmail.com>
   531	. Date:   Sun Dec 29 18:17:30 2019 -0500
   532	. 
   533	.     narrowed size display
   534	. 
   535	. commit bef6db6b67a4e76e5b6f02b019552ff96cdbb8e7
   536	. Author: Nobody <rich.freeman.paul@gmail.com>
   537	. Date:   Fri Dec 20 16:11:21 2019 -0500
   538	. 
   539	.     Usleep added.  Working on signal handling.
   540	. 
   541	. commit c00242c6e742fa01180f6b733f9a6842818a8625
   542	. Author: Nobody <rich.freeman.paul@gmail.com>
   543	. Date:   Thu Dec 19 04:08:34 2019 -0500
   544	. 
   545	.     readded fmt.cc
   546	. 
   547	. commit 05fca4599f58cac9ca7e6cbb2455e2a5c7a5f793
   548	. Author: Nobody <rich.freeman.paul@gmail.com>
   549	. Date:   Thu Dec 19 04:07:04 2019 -0500
   550	. 
   551	.     Rtti works?  Again?
   552	. 
   553	. commit 5932fd2d271784e9f122366b4cef6687a99a9c09
   554	. Author: Nobody <rich.freeman.paul@gmail.com>
   555	. Date:   Thu Dec 19 04:04:44 2019 -0500
   556	. 
   557	.     rtti working?
   558	. 
   559	. commit f6d4e31ea732f8ccfa9c3861ecd1184d9d9638a3
   560	. Author: Nobody <rich.freeman.paul@gmail.com>
   561	. Date:   Thu Dec 19 04:03:04 2019 -0500
   562	. 
   563	.     renamed flags files ... again
   564	. 
   565	. commit 1f3cc8af1b79ddaa9d3912b6562355fc7e99cd13
   566	. Author: Nobody <rich.freeman.paul@gmail.com>
   567	. Date:   Thu Dec 19 04:01:48 2019 -0500
   568	. 
   569	.     copied makefile
   570	. 
   571	. commit 3f1c62112db7e9f0979a9bc11ae7718d6120db48
   572	. Author: Nobody <rich.freeman.paul@gmail.com>
   573	. Date:   Thu Dec 19 04:00:42 2019 -0500
   574	. 
   575	.     fixed syscall.hh
   576	. 
   577	. commit 0cdfe26d03dbf575f60c19ba91632bc939c11552
   578	. Author: Nobody <rich.freeman.paul@gmail.com>
   579	. Date:   Wed Dec 18 18:52:40 2019 -0500
   580	. 
   581	.     Removed command to make syscall_fwd.hh
   582	. 
   583	. commit 250191b1b983a11f8ac7724f0e7eeeca2634506f
   584	. Author: Nobody <rich.freeman.paul@gmail.com>
   585	. Date:   Wed Dec 18 18:52:07 2019 -0500
   586	. 
   587	.     removed syscall_fwd.hh
   588	. 
   589	. commit 08773ab10ba99774c3ad08858977faefc2b6a2c2
   590	. Author: Nobody <rich.freeman.paul@gmail.com>
   591	. Date:   Tue Dec 17 21:47:38 2019 -0500
   592	. 
   593	.     This compiles and runs without anything from libsupc++
   594	. 
   595	. commit a2c5fdbf8ac50d55a2ebb9c9379af9414520d223
   596	. Author: Nobody <rich.freeman.paul@gmail.com>
   597	. Date:   Tue Dec 17 21:28:48 2019 -0500
   598	. 
   599	.     idk if this was useful.
   600	. 
   601	. commit fb1ef9b2d6b613805104d1bd17a9742ca5841a10
   602	. Author: Nobody <rich.freeman.paul@gmail.com>
   603	. Date:   Tue Dec 17 21:28:04 2019 -0500
   604	. 
   605	.     Renamed assembly sources to .S to distinguish from generated .s files
   606	. 
   607	. commit 2b59dfa23e48f856f6c18637eac943a0d08ef972
   608	. Author: Nobody <rich.freeman.paul@gmail.com>
   609	. Date:   Mon Dec 16 00:43:05 2019 -0500
   610	. 
   611	.     ignore tst for now
   612	. 
   613	. commit df6f5ce0a7155f88831bf47ce5b81ac2e8f27f58
   614	. Author: Nobody <rich.freeman.paul@gmail.com>
   615	. Date:   Mon Dec 16 00:37:10 2019 -0500
   616	. 
   617	.     Empty, now.
   618	. 
   619	. commit bcb5a79460a30f439ab2896b8c939e758d5e5d65
   620	. Author: Nobody <rich.freeman.paul@gmail.com>
   621	. Date:   Sun Dec 15 00:54:49 2019 -0500
   622	. 
   623	.     Still in a state of wild flux
   624	. 
   625	. commit fa8cc45273642f12498b7bb096bde738cff8a17e
   626	. Author: Nobody <rich.freeman.paul@gmail.com>
   627	. Date:   Sat Dec 14 00:34:25 2019 -0500
   628	. 
   629	.     pressing on
   630	. 
   631	. commit 6552609f86328253fd42eaf746c153c154e0f8fb
   632	. Author: Nobody <rich.freeman.paul@gmail.com>
   633	. Date:   Fri Dec 13 22:08:54 2019 -0500
   634	. 
   635	.     added filetype enum
   636	. 
   637	. commit 19dd620dbbf626bf0a8eda9d45f98a3ea249edd2
   638	. Author: Nobody <rich.freeman.paul@gmail.com>
   639	. Date:   Fri Dec 13 22:08:32 2019 -0500
   640	. 
   641	.     got sorting working
   642	. 
   643	. commit 27febe59273eae556abf95104d963ae6e3e6888c
   644	. Author: Nobody <rich.freeman.paul@gmail.com>
   645	. Date:   Fri Dec 13 22:08:00 2019 -0500
   646	. 
   647	.     added deps and tags
   648	. 
   649	. commit 1eb3ac868fd2042204fc2b3dea418a2aa8e362d4
   650	. Author: Nobody <rich.freeman.paul@gmail.com>
   651	. Date:   Fri Dec 13 22:07:31 2019 -0500
   652	. 
   653	.     removed map file creation
   654	. 
   655	. commit 597bed0190d63a3342be1ef0359e5a1801cf6a52
   656	. Author: Nobody <rich.freeman.paul@gmail.com>
   657	. Date:   Fri Dec 13 22:06:49 2019 -0500
   658	. 
   659	.     trivial errno initializer
   660	. 
   661	. commit e0916d3b5b23689258a346bb851b9d35e1298b5f
   662	. Author: Nobody <rich.freeman.paul@gmail.com>
   663	. Date:   Fri Dec 13 21:46:55 2019 -0500
   664	. 
   665	.     fixed uninitialized variable in getopt, added args to ls
   666	. 
   667	. commit 77430a4140fd2b874dfe2ee36df080ef380fae0d
   668	. Author: Nobody <rich.freeman.paul@gmail.com>
   669	. Date:   Fri Dec 13 14:29:11 2019 -0500
   670	. 
   671	.     Removed test programs.
   672	. 
   673	. commit 5b641218389ec6660867606828ee1cdfe5849236
   674	. Author: Nobody <rich.freeman.paul@gmail.com>
   675	. Date:   Fri Dec 13 14:15:43 2019 -0500
   676	. 
   677	.     mostly working.  Switching to stdlib branch
   678	. 
   679	. commit 8f0121e51ae2cd995a93fb61fd52fd4b6567929b
   680	. Author: Nobody <rich.freeman.paul@gmail.com>
   681	. Date:   Fri Dec 13 01:31:29 2019 -0500
   682	. 
   683	.     going to redo malloc
   684	. 
   685	. commit 1f726084fbd9befffca330c326ba6d1d745dc94a
   686	. Author: Nobody <rich.freeman.paul@gmail.com>
   687	. Date:   Mon Dec 9 19:41:59 2019 -0500
   688	. 
   689	.     added getopt
   690	. 
   691	. commit 20fa77416d5dec83b3e5b76a60a1744cbd396878
   692	. Author: Nobody <rich.freeman.paul@gmail.com>
   693	. Date:   Mon Dec 9 19:41:36 2019 -0500
   694	. 
   695	.     added getopt
   696	. 
   697	. commit 3347a655fac3a1fd6ced17767021b0a52e07bc55
   698	. Author: Nobody <rich.freeman.paul@gmail.com>
   699	. Date:   Sun Dec 8 15:01:02 2019 -0500
   700	. 
   701	.     Well, here I am.  Is this useful?
   702	. 
   703	. commit bca4b1b891c67bf5655cfe4681deead7c490eb66
   704	. Author: Nobody <rich.freeman.paul@gmail.com>
   705	. Date:   Sun Dec 8 14:18:51 2019 -0500
   706	. 
   707	.     going to have to move back here.
   708	. 
   709	. commit b10b586907d4b069cf324f3daf1902b9846cf4bc
   710	. Author: Nobody <rich.freeman.paul@gmail.com>
   711	. Date:   Sun Dec 8 07:21:19 2019 -0500
   712	. 
   713	.     types fd_t,ostr_t,istr_t
   714	. 
   715	. commit 8d724544c8e209ed6b8fbb5b8d723b208174fcf6
   716	. Author: Nobody <rich.freeman.paul@gmail.com>
   717	. Date:   Sun Dec 8 06:02:30 2019 -0500
   718	. 
   719	.     added gensyscall.pl
   720	. 
   721	. commit f79cda74026c44feaaf28e45b97f5fd0670e9771
   722	. Author: Nobody <rich.freeman.paul@gmail.com>
   723	. Date:   Sun Dec 8 05:50:16 2019 -0500
   724	. 
   725	.     added docs and syscall script
   726	. 
   727	. commit 8a76b02b9338705edec1487d8d7aaa11fc66d728
   728	. Author: Nobody <rich.freeman.paul@gmail.com>
   729	. Date:   Sun Dec 8 05:48:39 2019 -0500
   730	. 
   731	.     cxx flags are now stored in a file
   732	. 
   733	. commit 832d5481bb83e7bfbac98eef77c89d6fb88ed0c4
   734	. Author: Nobody <rich.freeman.paul@gmail.com>
   735	. Date:   Sun Dec 8 05:48:16 2019 -0500
   736	. 
   737	.     renamed include dir
   738	. 
   739	. commit a388c3525c15164be7eddea1468cf32ba85d10a8
   740	. Author: Nobody <rich.freeman.paul@gmail.com>
   741	. Date:   Fri Dec 6 23:58:32 2019 -0500
   742	. 
   743	.     working on malloc
   744	. 
   745	. commit f5aef74e92713417a5621d79eceb7e433d8340d0
   746	. Author: Nobody <rich.freeman.paul@gmail.com>
   747	. Date:   Fri Dec 6 23:29:59 2019 -0500
   748	. 
   749	.     added file for malloc
   750	. 
   751	. commit cd3e1de62ce0d49c21f13244fdc4aa4ed50fb671
   752	. Author: Nobody <rich.freeman.paul@gmail.com>
   753	. Date:   Fri Dec 6 22:15:37 2019 -0500
   754	. 
   755	.     defining string funcs
   756	. 
   757	. commit 58fa68744e7fecf740cff4d8fb55b70c7e70674a
   758	. Author: Nobody <rich.freeman.paul@gmail.com>
   759	. Date:   Fri Dec 6 17:22:56 2019 -0500
   760	. 
   761	.     fmt_t was interesting, but I think we can do better
   762	. 
   763	. commit f19aae36d1d9ba80d2008e1e43c1525ecce3be33
   764	. Author: Nobody <rich.freeman.paul@gmail.com>
   765	. Date:   Fri Dec 6 12:39:58 2019 -0500
   766	. 
   767	.     added fmtbuf
   768	. 
   769	. commit be01500f8c136a85b060613964317edd04a2c679
   770	. Author: Nobody <rich.freeman.paul@gmail.com>
   771	. Date:   Fri Dec 6 12:23:47 2019 -0500
   772	. 
   773	.     improt
   774	. 
   775	. commit 4f4b8dfce5d3cdd6f84f9733e40850e2ad814032
   776	. Author: Nobody <rich.freeman.paul@gmail.com>
   777	. Date:   Fri Dec 6 12:21:41 2019 -0500
   778	. 
   779	.     Importing again
   780	. 
   781	. commit c05c7de59c28b1afb6a24cf1754d3b39076b943f
   782	. Author: Nobody <rich.freeman.paul@gmail.com>
   783	. Date:   Fri Dec 6 12:06:47 2019 -0500
   784	. 
   785	.     Imported into master.
   786	. 
   787	. commit e2ff9335a3e9ff51f5a77917fe71ff76bf80ae67
   788	. Author: Nobody <32406633+FriarRich@users.noreply.github.com>
   789	. Date:   Fri Dec 6 11:54:11 2019 -0500
   790	. 
   791	.     Initial commit
FILE: END: doc/git-log.txt
FILE: START: doc/syscalls.html
HASH: MD5: 56c52e17290e9c70d2dafbcc3727eea7
     1	. <html>
     2	. 	<body>
     3	. 		<h3> Note:  I shamelessly stole this from
     4	. 			<a href="https://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64"/>
     5	. https://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/
     6	. 			</a>
     7	. 	<table>
     8	.         <tr>
     9	.             <th align="left">%rax</th>
    10	.             <th align="left">System call</th>
    11	.             <th align="left">%rdi</th>
    12	.             <th align="left">%rsi</th>
    13	.             <th align="left">%rdx</th>
    14	.             <th align="left">%r10</th>
    15	.             <th align="left">%r8</th>
    16	.             <th align="left">%r9</th>
    17	.         </tr>
    18	. 
    19	.         <tr>
    20	.             <td>0</td>
    21	.             <td>sys_read</td>
    22	.             <td>unsigned int fd</td>
    23	.             <td>char *buf</td>
    24	.             <td>size_t count</td>
    25	.             <td></td>
    26	.             <td></td>
    27	.             <td></td>
    28	.         </tr>
    29	.         <tr>
    30	.             <td>1</td>
    31	.             <td>sys_write</td>
    32	.             <td>unsigned int fd</td>
    33	.             <td>const char *buf</td>
    34	.             <td>size_t count</td>
    35	.             <td></td>
    36	.             <td></td>
    37	.             <td></td>
    38	.         </tr>
    39	.         <tr>
    40	.             <td>2</td>
    41	.             <td>sys_open</td>
    42	.             <td>const char *filename</td>
    43	.             <td>int flags</td>
    44	.             <td>int mode</td>
    45	.             <td></td>
    46	.             <td></td>
    47	.             <td></td>
    48	.         </tr>
    49	.         <tr>
    50	.             <td>3</td>
    51	.             <td>sys_close</td>
    52	.             <td>unsigned int fd</td>
    53	.             <td></td>
    54	.             <td></td>
    55	.             <td></td>
    56	.             <td></td>
    57	.             <td></td>
    58	.         </tr>
    59	.         <tr>
    60	.             <td>4</td>
    61	.             <td>sys_stat</td>
    62	.             <td>const char *filename</td>
    63	.             <td>struct stat *statbuf</td>
    64	.             <td></td>
    65	.             <td></td>
    66	.             <td></td>
    67	.             <td></td>
    68	.         </tr>
    69	.         <tr>
    70	.             <td>5</td>
    71	.             <td>sys_fstat</td>
    72	.             <td>unsigned int fd</td>
    73	.             <td>struct stat *statbuf</td>
    74	.             <td></td>
    75	.             <td></td>
    76	.             <td></td>
    77	.             <td></td>
    78	.         </tr>
    79	.         <tr>
    80	.             <td>6</td>
    81	.             <td>sys_lstat</td>
    82	.             <td>fconst char *filename</td>
    83	.             <td>struct stat *statbuf</td>
    84	.             <td></td>
    85	.             <td></td>
    86	.             <td></td>
    87	.             <td></td>
    88	.         </tr>
    89	.         <tr>
    90	.             <td>7</td>
    91	.             <td>sys_poll</td>
    92	.             <td>struct poll_fd *ufds</td>
    93	.             <td>unsigned int nfds</td>
    94	.             <td>long timeout_msecs</td>
    95	.             <td></td>
    96	.             <td></td>
    97	.             <td></td>
    98	.         </tr>
    99	.         <tr>
   100	.             <td>8</td>
   101	.             <td>sys_lseek</td>
   102	.             <td>unsigned int fd</td>
   103	.             <td>off_t offset</td>
   104	.             <td>unsigned int origin</td>
   105	.             <td></td>
   106	.             <td></td>
   107	.             <td></td>
   108	.         </tr>
   109	.         <tr>
   110	.             <td>9</td>
   111	.             <td>sys_mmap</td>
   112	.             <td>unsigned long addr</td>
   113	.             <td>unsigned long len</td>
   114	.             <td>unsigned long prot</td>
   115	.             <td>unsigned long flags</td>
   116	.             <td>unsigned long fd</td>
   117	.             <td>unsigned long off</td>
   118	.         </tr>
   119	.         <tr>
   120	.             <td>10</td>
   121	.             <td>sys_mprotect</td>
   122	.             <td>unsigned long start</td>
   123	.             <td>size_t len</td>
   124	.             <td>unsigned long prot</td>
   125	.             <td></td>
   126	.             <td></td>
   127	.             <td></td>
   128	.         </tr>
   129	.         <tr>
   130	.             <td>11</td>
   131	.             <td>sys_munmap</td>
   132	.             <td>unsigned long addr</td>
   133	.             <td>size_t len</td>
   134	.             <td></td>
   135	.             <td></td>
   136	.             <td></td>
   137	.             <td></td>
   138	.         </tr>
   139	.         <tr>
   140	.             <td>12</td>
   141	.             <td>sys_brk</td>
   142	.             <td>unsigned long brk</td>
   143	.             <td></td>
   144	.             <td></td>
   145	.             <td></td>
   146	.             <td></td>
   147	.             <td></td>
   148	.         </tr>
   149	.         <tr>
   150	.             <td>13</td>
   151	.             <td>sys_rt_sigaction</td>
   152	.             <td>int sig</td>
   153	.             <td>const struct sigaction *act</td>
   154	.             <td>struct sigaction *oact</td>
   155	.             <td>size_t sigsetsize</td>
   156	.             <td></td>
   157	.             <td></td>
   158	.         </tr>
   159	.         <tr>
   160	.             <td>14</td>
   161	.             <td>sys_rt_sigprocmask</td>
   162	.             <td>int how</td>
   163	.             <td>sigset_t *nset</td>
   164	.             <td>sigset_t *oset</td>
   165	.             <td>size_t sigsetsize</td>
   166	.             <td></td>
   167	.             <td></td>
   168	.         </tr>
   169	.         <tr>
   170	.             <td>15</td>
   171	.             <td>sys_rt_sigreturn</td>
   172	.             <td>unsigned long __unused</td>
   173	.             <td></td>
   174	.             <td></td>
   175	.             <td></td>
   176	.             <td></td>
   177	.             <td></td>
   178	.         </tr>
   179	.         <tr>
   180	.             <td>16</td>
   181	.             <td>sys_ioctl</td>
   182	.             <td>unsigned int fd</td>
   183	.             <td>unsigned int cmd</td>
   184	.             <td>unsigned long arg</td>
   185	.             <td></td>
   186	.             <td></td>
   187	.             <td></td>
   188	.         </tr>
   189	.         <tr>
   190	.             <td>17</td>
   191	.             <td>sys_pread64</td>
   192	.             <td>unsigned long fd</td>
   193	.             <td>char *buf</td>
   194	.             <td>size_t count</td>
   195	.             <td>loff_t pos</td>
   196	.             <td></td>
   197	.             <td></td>
   198	.         </tr>
   199	.         <tr>
   200	.             <td>18</td>
   201	.             <td>sys_pwrite64</td>
   202	.             <td>unsigned int fd</td>
   203	.             <td>const char *buf</td>
   204	.             <td>size_t count</td>
   205	.             <td>loff_t pos</td>
   206	.             <td></td>
   207	.             <td></td>
   208	.         </tr>
   209	.         <tr>
   210	.             <td>19</td>
   211	.             <td>sys_readv</td>
   212	.             <td>unsigned long fd</td>
   213	.             <td>const struct iovec *vec</td>
   214	.             <td>unsigned long vlen</td>
   215	.             <td></td>
   216	.             <td></td>
   217	.             <td></td>
   218	.         </tr>
   219	.         <tr>
   220	.             <td>20</td>
   221	.             <td>sys_writev</td>
   222	.             <td>unsigned long fd</td>
   223	.             <td>const struct iovec *vec</td>
   224	.             <td>unsigned long vlen</td>
   225	.             <td></td>
   226	.             <td></td>
   227	.             <td></td>
   228	.         </tr>
   229	.         <tr>
   230	.             <td>21</td>
   231	.             <td>sys_access</td>
   232	.             <td>const char *filename</td>
   233	.             <td>int mode</td>
   234	.             <td></td>
   235	.             <td></td>
   236	.             <td></td>
   237	.             <td></td>
   238	.         </tr>
   239	.         <tr>
   240	.             <td>22</td>
   241	.             <td>sys_pipe</td>
   242	.             <td>int *filedes</td>
   243	.             <td></td>
   244	.             <td></td>
   245	.             <td></td>
   246	.             <td></td>
   247	.             <td></td>
   248	.         </tr>
   249	.         <tr>
   250	.             <td>23</td>
   251	.             <td>sys_select</td>
   252	.             <td>int n</td>
   253	.             <td>fd_set *inp</td>
   254	.             <td>fd_set *outp</td>
   255	.             <td>fd_set*exp</td>
   256	.             <td>struct timeval *tvp</td>
   257	.             <td></td>
   258	.         </tr>
   259	.         <tr>
   260	.             <td>24</td>
   261	.             <td>sys_sched_yield</td>
   262	.             <td></td>
   263	.             <td></td>
   264	.             <td></td>
   265	.             <td></td>
   266	.             <td></td>
   267	.             <td></td>
   268	.         </tr>
   269	.         <tr>
   270	.             <td>25</td>
   271	.             <td>sys_mremap</td>
   272	.             <td>unsigned long addr</td>
   273	.             <td>unsigned long old_len</td>
   274	.             <td>unsigned long new_len</td>
   275	.             <td>unsigned long flags</td>
   276	.             <td>unsigned long new_addr</td>
   277	.             <td></td>
   278	.         </tr>
   279	.         <tr>
   280	.             <td>26</td>
   281	.             <td>sys_msync</td>
   282	.             <td>unsigned long start</td>
   283	.             <td>size_t len</td>
   284	.             <td>int flags</td>
   285	.             <td></td>
   286	.             <td></td>
   287	.             <td></td>
   288	.         </tr>
   289	.         <tr>
   290	.             <td>27</td>
   291	.             <td>sys_mincore</td>
   292	.             <td>unsigned long start</td>
   293	.             <td>size_t len</td>
   294	.             <td>unsigned char *vec</td>
   295	.             <td></td>
   296	.             <td></td>
   297	.             <td></td>
   298	.         </tr>
   299	.         <tr>
   300	.             <td>28</td>
   301	.             <td>sys_madvise</td>
   302	.             <td>unsigned long start</td>
   303	.             <td>size_t len_in</td>
   304	.             <td>int behavior</td>
   305	.             <td></td>
   306	.             <td></td>
   307	.             <td></td>
   308	.         </tr>
   309	.         <tr>
   310	.             <td>29</td>
   311	.             <td>sys_shmget</td>
   312	.             <td>key_t key</td>
   313	.             <td>size_t size</td>
   314	.             <td>int shmflg</td>
   315	.             <td></td>
   316	.             <td></td>
   317	.             <td></td>
   318	.         </tr>
   319	.         <tr>
   320	.             <td>30</td>
   321	.             <td>sys_shmat</td>
   322	.             <td>int shmid</td>
   323	.             <td>char *shmaddr</td>
   324	.             <td>int shmflg</td>
   325	.             <td></td>
   326	.             <td></td>
   327	.             <td></td>
   328	.         </tr>
   329	.         <tr>
   330	.             <td>31</td>
   331	.             <td>sys_shmctl</td>
   332	.             <td>int shmid</td>
   333	.             <td>int cmd</td>
   334	.             <td>struct shmid_ds *buf</td>
   335	.             <td></td>
   336	.             <td></td>
   337	.             <td></td>
   338	.         </tr>
   339	.         <tr>
   340	.             <td>32</td>
   341	.             <td>sys_dup</td>
   342	.             <td>unsigned int fildes</td>
   343	.             <td></td>
   344	.             <td></td>
   345	.             <td></td>
   346	.             <td></td>
   347	.             <td></td>
   348	.         </tr>
   349	.         <tr>
   350	.             <td>33</td>
   351	.             <td>sys_dup2</td>
   352	.             <td>unsigned int oldfd</td>
   353	.             <td>unsigned int newfd</td>
   354	.             <td></td>
   355	.             <td></td>
   356	.             <td></td>
   357	.             <td></td>
   358	.         </tr>
   359	.         <tr>
   360	.             <td>34</td>
   361	.             <td>sys_pause</td>
   362	.             <td></td>
   363	.             <td></td>
   364	.             <td></td>
   365	.             <td></td>
   366	.             <td></td>
   367	.             <td></td>
   368	.         </tr>
   369	.         <tr>
   370	.             <td>35</td>
   371	.             <td>sys_nanosleep</td>
   372	.             <td>struct timespec *rqtp</td>
   373	.             <td>struct timespec *rmtp</td>
   374	.             <td></td>
   375	.             <td></td>
   376	.             <td></td>
   377	.             <td></td>
   378	.         </tr>
   379	.         <tr>
   380	.             <td>36</td>
   381	.             <td>sys_getitimer</td>
   382	.             <td>int which</td>
   383	.             <td>struct itimerval *value</td>
   384	.             <td></td>
   385	.             <td></td>
   386	.             <td></td>
   387	.             <td></td>
   388	.         </tr>
   389	.         <tr>
   390	.             <td>37</td>
   391	.             <td>sys_alarm</td>
   392	.             <td>unsigned int seconds</td>
   393	.             <td></td>
   394	.             <td></td>
   395	.             <td></td>
   396	.             <td></td>
   397	.             <td></td>
   398	.         </tr>
   399	.         <tr>
   400	.             <td>38</td>
   401	.             <td>sys_setitimer</td>
   402	.             <td>int which</td>
   403	.             <td>struct itimerval *value</td>
   404	.             <td>struct itimerval *ovalue</td>
   405	.             <td></td>
   406	.             <td></td>
   407	.             <td></td>
   408	.         </tr>
   409	.         <tr>
   410	.             <td>39</td>
   411	.             <td>sys_getpid</td>
   412	.             <td></td>
   413	.             <td></td>
   414	.             <td></td>
   415	.             <td></td>
   416	.             <td></td>
   417	.             <td></td>
   418	.         </tr>
   419	.         <tr>
   420	.             <td>40</td>
   421	.             <td>sys_sendfile</td>
   422	.             <td>int out_fd</td>
   423	.             <td>int in_fd</td>
   424	.             <td>off_t *offset</td>
   425	.             <td>size_t count</td>
   426	.             <td></td>
   427	.             <td></td>
   428	.         </tr>
   429	.         <tr>
   430	.             <td>41</td>
   431	.             <td>sys_socket</td>
   432	.             <td>int family</td>
   433	.             <td>int type</td>
   434	.             <td>int protocol</td>
   435	.             <td></td>
   436	.             <td></td>
   437	.             <td></td>
   438	.         </tr>
   439	.         <tr>
   440	.             <td>42</td>
   441	.             <td>sys_connect</td>
   442	.             <td>int fd</td>
   443	.             <td>struct sockaddr *uservaddr</td>
   444	.             <td>int addrlen</td>
   445	.             <td></td>
   446	.             <td></td>
   447	.             <td></td>
   448	.         </tr>
   449	.         <tr>
   450	.             <td>43</td>
   451	.             <td>sys_accept</td>
   452	.             <td>int fd</td>
   453	.             <td>struct sockaddr *upeer_sockaddr</td>
   454	.             <td>int *upeer_addrlen</td>
   455	.             <td></td>
   456	.             <td></td>
   457	.             <td></td>
   458	.         </tr>
   459	.         <tr>
   460	.             <td>44</td>
   461	.             <td>sys_sendto</td>
   462	.             <td>int fd</td>
   463	.             <td>void *buff</td>
   464	.             <td>size_t len</td>
   465	.             <td>unsigned flags</td>
   466	.             <td>struct sockaddr *addr</td>
   467	.             <td>int addr_len</td>
   468	.         </tr>
   469	.         <tr>
   470	.             <td>45</td>
   471	.             <td>sys_recvfrom</td>
   472	.             <td>int fd</td>
   473	.             <td>void *ubuf</td>
   474	.             <td>size_t size</td>
   475	.             <td>unsigned flags</td>
   476	.             <td>struct sockaddr *addr</td>
   477	.             <td>int *addr_len</td>
   478	.         </tr>
   479	.         <tr>
   480	.             <td>46</td>
   481	.             <td>sys_sendmsg</td>
   482	.             <td>int fd</td>
   483	.             <td>struct msghdr *msg</td>
   484	.             <td>unsigned flags</td>
   485	.             <td></td>
   486	.             <td></td>
   487	.             <td></td>
   488	.         </tr>
   489	.         <tr>
   490	.             <td>47</td>
   491	.             <td>sys_recvmsg</td>
   492	.             <td>int fd</td>
   493	.             <td>struct msghdr *msg</td>
   494	.             <td>unsigned int flags</td>
   495	.             <td></td>
   496	.             <td></td>
   497	.             <td></td>
   498	.         </tr>
   499	.         <tr>
   500	.             <td>48</td>
   501	.             <td>sys_shutdown</td>
   502	.             <td>int fd</td>
   503	.             <td>int how</td>
   504	.             <td></td>
   505	.             <td></td>
   506	.             <td></td>
   507	.             <td></td>
   508	.         </tr>
   509	.         <tr>
   510	.             <td>49</td>
   511	.             <td>sys_bind</td>
   512	.             <td>int fd</td>
   513	.             <td>struct sokaddr *umyaddr</td>
   514	.             <td>int addrlen</td>
   515	.             <td></td>
   516	.             <td></td>
   517	.             <td></td>
   518	.         </tr>
   519	.         <tr>
   520	.             <td>50</td>
   521	.             <td>sys_listen</td>
   522	.             <td>int fd</td>
   523	.             <td>int backlog</td>
   524	.             <td></td>
   525	.             <td></td>
   526	.             <td></td>
   527	.             <td></td>
   528	.         </tr>
   529	.         <tr>
   530	.             <td>51</td>
   531	.             <td>sys_getsockname</td>
   532	.             <td>int fd</td>
   533	.             <td>struct sockaddr *usockaddr</td>
   534	.             <td>int *usockaddr_len</td>
   535	.             <td></td>
   536	.             <td></td>
   537	.             <td></td>
   538	.         </tr>
   539	.         <tr>
   540	.             <td>52</td>
   541	.             <td>sys_getpeername</td>
   542	.             <td>int fd</td>
   543	.             <td>struct sockaddr *usockaddr</td>
   544	.             <td>int *usockaddr_len</td>
   545	.             <td></td>
   546	.             <td></td>
   547	.             <td></td>
   548	.         </tr>
   549	.         <tr>
   550	.             <td>53</td>
   551	.             <td>sys_socketpair</td>
   552	.             <td>int family</td>
   553	.             <td>int type</td>
   554	.             <td>int protocol</td>
   555	.             <td>int *usockvec</td>
   556	.             <td></td>
   557	.             <td></td>
   558	.         </tr>
   559	.         <tr>
   560	.             <td>54</td>
   561	.             <td>sys_setsockopt</td>
   562	.             <td>int fd</td>
   563	.             <td>int level</td>
   564	.             <td>int optname</td>
   565	.             <td>char *optval</td>
   566	.             <td>int optlen</td>
   567	.             <td></td>
   568	.         </tr>
   569	.         <tr>
   570	.             <td>55</td>
   571	.             <td>sys_getsockopt</td>
   572	.             <td>int fd</td>
   573	.             <td>int level</td>
   574	.             <td>int optname</td>
   575	.             <td>char *optval</td>
   576	.             <td>int *optlen</td>
   577	.             <td></td>
   578	.         </tr>
   579	.         <tr>
   580	.             <td>56</td>
   581	.             <td>sys_clone</td>
   582	.             <td>unsigned long clone_flags</td>
   583	.             <td>unsigned long newsp</td>
   584	.             <td>void *parent_tid</td>
   585	.             <td>void *child_tid</td>
   586	.             <td></td>
   587	.             <td></td>
   588	.         </tr>
   589	.         <tr>
   590	.             <td>57</td>
   591	.             <td>sys_fork</td>
   592	.             <td></td>
   593	.             <td></td>
   594	.             <td></td>
   595	.             <td></td>
   596	.             <td></td>
   597	.             <td></td>
   598	.         </tr>
   599	.         <tr>
   600	.             <td>58</td>
   601	.             <td>sys_vfork</td>
   602	.             <td></td>
   603	.             <td></td>
   604	.             <td></td>
   605	.             <td></td>
   606	.             <td></td>
   607	.             <td></td>
   608	.         </tr>
   609	.         <tr>
   610	.             <td>59</td>
   611	.             <td>sys_execve</td>
   612	.             <td>const char *filename</td>
   613	.             <td>const char *const argv[]</td>
   614	.             <td>const char *const envp[]</td>
   615	.             <td></td>
   616	.             <td></td>
   617	.             <td></td>
   618	.         </tr>
   619	.         <tr>
   620	.             <td>60</td>
   621	.             <td>sys_exit</td>
   622	.             <td>int error_code</td>
   623	.             <td></td>
   624	.             <td></td>
   625	.             <td></td>
   626	.             <td></td>
   627	.             <td></td>
   628	.         </tr>
   629	.         <tr>
   630	.             <td>61</td>
   631	.             <td>sys_wait4</td>
   632	.             <td>pid_t upid</td>
   633	.             <td>int *stat_addr</td>
   634	.             <td>int options</td>
   635	.             <td>struct rusage *ru</td>
   636	.             <td></td>
   637	.             <td></td>
   638	.         </tr>
   639	.         <tr>
   640	.             <td>62</td>
   641	.             <td>sys_kill</td>
   642	.             <td>pid_t pid</td>
   643	.             <td>int sig</td>
   644	.             <td></td>
   645	.             <td></td>
   646	.             <td></td>
   647	.             <td></td>
   648	.         </tr>
   649	.         <tr>
   650	.             <td>63</td>
   651	.             <td>sys_uname</td>
   652	.             <td>struct old_utsname *name</td>
   653	.             <td></td>
   654	.             <td></td>
   655	.             <td></td>
   656	.             <td></td>
   657	.             <td></td>
   658	.         </tr>
   659	.         <tr>
   660	.             <td>64</td>
   661	.             <td>sys_semget</td>
   662	.             <td>key_t key</td>
   663	.             <td>int nsems</td>
   664	.             <td>int semflg</td>
   665	.             <td></td>
   666	.             <td></td>
   667	.             <td></td>
   668	.         </tr>
   669	.         <tr>
   670	.             <td>65</td>
   671	.             <td>sys_semop</td>
   672	.             <td>int semid</td>
   673	.             <td>struct sembuf *tsops</td>
   674	.             <td>unsigned nsops</td>
   675	.             <td></td>
   676	.             <td></td>
   677	.             <td></td>
   678	.         </tr>
   679	.         <tr>
   680	.             <td>66</td>
   681	.             <td>sys_semctl</td>
   682	.             <td>int semid</td>
   683	.             <td>int semnum</td>
   684	.             <td>int cmd</td>
   685	.             <td>union semun arg</td>
   686	.             <td></td>
   687	.             <td></td>
   688	.         </tr>
   689	.         <tr>
   690	.             <td>67</td>
   691	.             <td>sys_shmdt</td>
   692	.             <td>char *shmaddr</td>
   693	.             <td></td>
   694	.             <td></td>
   695	.             <td></td>
   696	.             <td></td>
   697	.             <td></td>
   698	.         </tr>
   699	.         <tr>
   700	.             <td>68</td>
   701	.             <td>sys_msgget</td>
   702	.             <td>key_t key</td>
   703	.             <td>int msgflg</td>
   704	.             <td></td>
   705	.             <td></td>
   706	.             <td></td>
   707	.             <td></td>
   708	.         </tr>
   709	.         <tr>
   710	.             <td>69</td>
   711	.             <td>sys_msgsnd</td>
   712	.             <td>int msqid</td>
   713	.             <td>struct msgbuf *msgp</td>
   714	.             <td>size_t msgsz</td>
   715	.             <td>int msgflg</td>
   716	.             <td></td>
   717	.             <td></td>
   718	.         </tr>
   719	.         <tr>
   720	.             <td>70</td>
   721	.             <td>sys_msgrcv</td>
   722	.             <td>int msqid</td>
   723	.             <td>struct msgbuf *msgp</td>
   724	.             <td>size_t msgsz</td>
   725	.             <td>long msgtyp</td>
   726	.             <td>int msgflg</td>
   727	.             <td></td>
   728	.         </tr>
   729	.         <tr>
   730	.             <td>71</td>
   731	.             <td>sys_msgctl</td>
   732	.             <td>int msqid</td>
   733	.             <td>int cmd</td>
   734	.             <td>struct msqid_ds *buf</td>
   735	.             <td></td>
   736	.             <td></td>
   737	.             <td></td>
   738	.         </tr>
   739	.         <tr>
   740	.             <td>72</td>
   741	.             <td>sys_fcntl</td>
   742	.             <td>unsigned int fd</td>
   743	.             <td>unsigned int cmd</td>
   744	.             <td>unsigned long arg</td>
   745	.             <td></td>
   746	.             <td></td>
   747	.             <td></td>
   748	.         </tr>
   749	.         <tr>
   750	.             <td>73</td>
   751	.             <td>sys_flock</td>
   752	.             <td>unsigned int fd</td>
   753	.             <td>unsigned int cmd</td>
   754	.             <td></td>
   755	.             <td></td>
   756	.             <td></td>
   757	.             <td></td>
   758	.         </tr>
   759	.         <tr>
   760	.             <td>74</td>
   761	.             <td>sys_fsync</td>
   762	.             <td>unsigned int fd</td>
   763	.             <td></td>
   764	.             <td></td>
   765	.             <td></td>
   766	.             <td></td>
   767	.             <td></td>
   768	.         </tr>
   769	.         <tr>
   770	.             <td>75</td>
   771	.             <td>sys_fdatasync</td>
   772	.             <td>unsigned int fd</td>
   773	.             <td></td>
   774	.             <td></td>
   775	.             <td></td>
   776	.             <td></td>
   777	.             <td></td>
   778	.         </tr>
   779	.         <tr>
   780	.             <td>76</td>
   781	.             <td>sys_truncate</td>
   782	.             <td>const char *path</td>
   783	.             <td>long length</td>
   784	.             <td></td>
   785	.             <td></td>
   786	.             <td></td>
   787	.             <td></td>
   788	.         </tr>
   789	.         <tr>
   790	.             <td>77</td>
   791	.             <td>sys_ftruncate</td>
   792	.             <td>unsigned int fd</td>
   793	.             <td>unsigned long length</td>
   794	.             <td></td>
   795	.             <td></td>
   796	.             <td></td>
   797	.             <td></td>
   798	.         </tr>
   799	.         <tr>
   800	.             <td>78</td>
   801	.             <td>sys_getdents</td>
   802	.             <td>unsigned int fd</td>
   803	.             <td>struct linux_dirent *dirent</td>
   804	.             <td>unsigned int count</td>
   805	.             <td></td>
   806	.             <td></td>
   807	.             <td></td>
   808	.         </tr>
   809	.         <tr>
   810	.             <td>79</td>
   811	.             <td>sys_getcwd</td>
   812	.             <td>char *buf</td>
   813	.             <td>unsigned long size</td>
   814	.             <td></td>
   815	.             <td></td>
   816	.             <td></td>
   817	.             <td></td>
   818	.         </tr>
   819	.         <tr>
   820	.             <td>80</td>
   821	.             <td>sys_chdir</td>
   822	.             <td>const char *filename</td>
   823	.             <td></td>
   824	.             <td></td>
   825	.             <td></td>
   826	.             <td></td>
   827	.             <td></td>
   828	.         </tr>
   829	.         <tr>
   830	.             <td>81</td>
   831	.             <td>sys_fchdir</td>
   832	.             <td>unsigned int fd</td>
   833	.             <td></td>
   834	.             <td></td>
   835	.             <td></td>
   836	.             <td></td>
   837	.             <td></td>
   838	.         </tr>
   839	.         <tr>
   840	.             <td>82</td>
   841	.             <td>sys_rename</td>
   842	.             <td>const char *oldname</td>
   843	.             <td>const char *newname</td>
   844	.             <td></td>
   845	.             <td></td>
   846	.             <td></td>
   847	.             <td></td>
   848	.         </tr>
   849	.         <tr>
   850	.             <td>83</td>
   851	.             <td>sys_mkdir</td>
   852	.             <td>const char *pathname</td>
   853	.             <td>int mode</td>
   854	.             <td></td>
   855	.             <td></td>
   856	.             <td></td>
   857	.             <td></td>
   858	.         </tr>
   859	.         <tr>
   860	.             <td>84</td>
   861	.             <td>sys_rmdir</td>
   862	.             <td>const char *pathname</td>
   863	.             <td></td>
   864	.             <td></td>
   865	.             <td></td>
   866	.             <td></td>
   867	.             <td></td>
   868	.         </tr>
   869	.         <tr>
   870	.             <td>85</td>
   871	.             <td>sys_creat</td>
   872	.             <td>const char *pathname</td>
   873	.             <td>int mode</td>
   874	.             <td></td>
   875	.             <td></td>
   876	.             <td></td>
   877	.             <td></td>
   878	.         </tr>
   879	.         <tr>
   880	.             <td>86</td>
   881	.             <td>sys_link</td>
   882	.             <td>const char *oldname</td>
   883	.             <td>const char *newname</td>
   884	.             <td></td>
   885	.             <td></td>
   886	.             <td></td>
   887	.             <td></td>
   888	.         </tr>
   889	.         <tr>
   890	.             <td>87</td>
   891	.             <td>sys_unlink</td>
   892	.             <td>const char *pathname</td>
   893	.             <td></td>
   894	.             <td></td>
   895	.             <td></td>
   896	.             <td></td>
   897	.             <td></td>
   898	.         </tr>
   899	.         <tr>
   900	.             <td>88</td>
   901	.             <td>sys_symlink</td>
   902	.             <td>const char *oldname</td>
   903	.             <td>const char *newname</td>
   904	.             <td></td>
   905	.             <td></td>
   906	.             <td></td>
   907	.             <td></td>
   908	.         </tr>
   909	.         <tr>
   910	.             <td>89</td>
   911	.             <td>sys_readlink</td>
   912	.             <td>const char *path</td>
   913	.             <td>char *buf</td>
   914	.             <td>int bufsiz</td>
   915	.             <td></td>
   916	.             <td></td>
   917	.             <td></td>
   918	.         </tr>
   919	.         <tr>
   920	.             <td>90</td>
   921	.             <td>sys_chmod</td>
   922	.             <td>const char *filename</td>
   923	.             <td>mode_t mode</td>
   924	.             <td></td>
   925	.             <td></td>
   926	.             <td></td>
   927	.             <td></td>
   928	.         </tr>
   929	.         <tr>
   930	.             <td>91</td>
   931	.             <td>sys_fchmod</td>
   932	.             <td>unsigned int fd</td>
   933	.             <td>mode_t mode</td>
   934	.             <td></td>
   935	.             <td></td>
   936	.             <td></td>
   937	.             <td></td>
   938	.         </tr>
   939	.         <tr>
   940	.             <td>92</td>
   941	.             <td>sys_chown</td>
   942	.             <td>const char *filename</td>
   943	.             <td>uid_t user</td>
   944	.             <td>gid_t group</td>
   945	.             <td></td>
   946	.             <td></td>
   947	.             <td></td>
   948	.         </tr>
   949	.         <tr>
   950	.             <td>93</td>
   951	.             <td>sys_fchown</td>
   952	.             <td>unsigned int fd</td>
   953	.             <td>uid_t user</td>
   954	.             <td>gid_t group</td>
   955	.             <td></td>
   956	.             <td></td>
   957	.             <td></td>
   958	.         </tr>
   959	.         <tr>
   960	.             <td>94</td>
   961	.             <td>sys_lchown</td>
   962	.             <td>const char *filename</td>
   963	.             <td>uid_t user</td>
   964	.             <td>gid_t group</td>
   965	.             <td></td>
   966	.             <td></td>
   967	.             <td></td>
   968	.         </tr>
   969	.         <tr>
   970	.             <td>95</td>
   971	.             <td>sys_umask</td>
   972	.             <td>int mask</td>
   973	.             <td></td>
   974	.             <td></td>
   975	.             <td></td>
   976	.             <td></td>
   977	.             <td></td>
   978	.         </tr>
   979	.         <tr>
   980	.             <td>96</td>
   981	.             <td>sys_gettimeofday</td>
   982	.             <td>struct timeval *tv</td>
   983	.             <td>struct timezone *tz</td>
   984	.             <td></td>
   985	.             <td></td>
   986	.             <td></td>
   987	.             <td></td>
   988	.         </tr>
   989	.         <tr>
   990	.             <td>97</td>
   991	.             <td>sys_getrlimit</td>
   992	.             <td>unsigned int resource</td>
   993	.             <td>struct rlimit *rlim</td>
   994	.             <td></td>
   995	.             <td></td>
   996	.             <td></td>
   997	.             <td></td>
   998	.         </tr>
   999	.         <tr>
  1000	.             <td>98</td>
  1001	.             <td>sys_getrusage</td>
  1002	.             <td>int who</td>
  1003	.             <td>struct rusage *ru</td>
  1004	.             <td></td>
  1005	.             <td></td>
  1006	.             <td></td>
  1007	.             <td></td>
  1008	.         </tr>
  1009	.         <tr>
  1010	.             <td>99</td>
  1011	.             <td>sys_sysinfo</td>
  1012	.             <td>struct sysinfo *info</td>
  1013	.             <td></td>
  1014	.             <td></td>
  1015	.             <td></td>
  1016	.             <td></td>
  1017	.             <td></td>
  1018	.         </tr>
  1019	.         <tr>
  1020	.             <td>100</td>
  1021	.             <td>sys_times</td>
  1022	.             <td>struct sysinfo *info</td>
  1023	.             <td></td>
  1024	.             <td></td>
  1025	.             <td></td>
  1026	.             <td></td>
  1027	.             <td></td>
  1028	.         </tr>
  1029	.         <tr>
  1030	.             <td>101</td>
  1031	.             <td>sys_ptrace</td>
  1032	.             <td>long request</td>
  1033	.             <td>long pid</td>
  1034	.             <td>unsigned long addr</td>
  1035	.             <td>unsigned long data</td>
  1036	.             <td></td>
  1037	.             <td></td>
  1038	.         </tr>
  1039	.         <tr>
  1040	.             <td>102</td>
  1041	.             <td>sys_getuid</td>
  1042	.             <td></td>
  1043	.             <td></td>
  1044	.             <td></td>
  1045	.             <td></td>
  1046	.             <td></td>
  1047	.             <td></td>
  1048	.         </tr>
  1049	.         <tr>
  1050	.             <td>103</td>
  1051	.             <td>sys_syslog</td>
  1052	.             <td>int type</td>
  1053	.             <td>char *buf</td>
  1054	.             <td>int len</td>
  1055	.             <td></td>
  1056	.             <td></td>
  1057	.             <td></td>
  1058	.         </tr>
  1059	.         <tr>
  1060	.             <td>104</td>
  1061	.             <td>sys_getgid</td>
  1062	.             <td></td>
  1063	.             <td></td>
  1064	.             <td></td>
  1065	.             <td></td>
  1066	.             <td></td>
  1067	.             <td></td>
  1068	.         </tr>
  1069	.         <tr>
  1070	.             <td>105</td>
  1071	.             <td>sys_setuid</td>
  1072	.             <td>uid_t uid</td>
  1073	.             <td></td>
  1074	.             <td></td>
  1075	.             <td></td>
  1076	.             <td></td>
  1077	.             <td></td>
  1078	.         </tr>
  1079	.         <tr>
  1080	.             <td>106</td>
  1081	.             <td>sys_setgid</td>
  1082	.             <td>gid_t gid</td>
  1083	.             <td></td>
  1084	.             <td></td>
  1085	.             <td></td>
  1086	.             <td></td>
  1087	.             <td></td>
  1088	.         </tr>
  1089	.         <tr>
  1090	.             <td>107</td>
  1091	.             <td>sys_geteuid</td>
  1092	.             <td></td>
  1093	.             <td></td>
  1094	.             <td></td>
  1095	.             <td></td>
  1096	.             <td></td>
  1097	.             <td></td>
  1098	.         </tr>
  1099	.         <tr>
  1100	.             <td>108</td>
  1101	.             <td>sys_getegid</td>
  1102	.             <td></td>
  1103	.             <td></td>
  1104	.             <td></td>
  1105	.             <td></td>
  1106	.             <td></td>
  1107	.             <td></td>
  1108	.         </tr>
  1109	.         <tr>
  1110	.             <td>109</td>
  1111	.             <td>sys_setpgid</td>
  1112	.             <td>pid_t pid</td>
  1113	.             <td>pid_t pgid</td>
  1114	.             <td></td>
  1115	.             <td></td>
  1116	.             <td></td>
  1117	.             <td></td>
  1118	.         </tr>
  1119	.         <tr>
  1120	.             <td>110</td>
  1121	.             <td>sys_getppid</td>
  1122	.             <td></td>
  1123	.             <td></td>
  1124	.             <td></td>
  1125	.             <td></td>
  1126	.             <td></td>
  1127	.             <td></td>
  1128	.         </tr>
  1129	.         <tr>
  1130	.             <td>111</td>
  1131	.             <td>sys_getpgrp</td>
  1132	.             <td></td>
  1133	.             <td></td>
  1134	.             <td></td>
  1135	.             <td></td>
  1136	.             <td></td>
  1137	.             <td></td>
  1138	.         </tr>
  1139	.         <tr>
  1140	.             <td>112</td>
  1141	.             <td>sys_setsid</td>
  1142	.             <td></td>
  1143	.             <td></td>
  1144	.             <td></td>
  1145	.             <td></td>
  1146	.             <td></td>
  1147	.             <td></td>
  1148	.         </tr>
  1149	.         <tr>
  1150	.             <td>113</td>
  1151	.             <td>sys_setreuid</td>
  1152	.             <td>uid_t ruid</td>
  1153	.             <td>uid_t euid</td>
  1154	.             <td></td>
  1155	.             <td></td>
  1156	.             <td></td>
  1157	.             <td></td>
  1158	.         </tr>
  1159	.         <tr>
  1160	.             <td>114</td>
  1161	.             <td>sys_setregid</td>
  1162	.             <td>gid_t rgid</td>
  1163	.             <td>gid_t egid</td>
  1164	.             <td></td>
  1165	.             <td></td>
  1166	.             <td></td>
  1167	.             <td></td>
  1168	.         </tr>
  1169	.         <tr>
  1170	.             <td>115</td>
  1171	.             <td>sys_getgroups</td>
  1172	.             <td>int gidsetsize</td>
  1173	.             <td>gid_t *grouplist</td>
  1174	.             <td></td>
  1175	.             <td></td>
  1176	.             <td></td>
  1177	.             <td></td>
  1178	.         </tr>
  1179	.         <tr>
  1180	.             <td>116</td>
  1181	.             <td>sys_setgroups</td>
  1182	.             <td>int gidsetsize</td>
  1183	.             <td>gid_t *grouplist</td>
  1184	.             <td></td>
  1185	.             <td></td>
  1186	.             <td></td>
  1187	.             <td></td>
  1188	.         </tr>
  1189	.         <tr>
  1190	.             <td>117</td>
  1191	.             <td>sys_setresuid</td>
  1192	.             <td>uid_t *ruid</td>
  1193	.             <td>uid_t *euid</td>
  1194	.             <td>uid_t *suid</td>
  1195	.             <td></td>
  1196	.             <td></td>
  1197	.             <td></td>
  1198	.         </tr>
  1199	.         <tr>
  1200	.             <td>118</td>
  1201	.             <td>sys_getresuid</td>
  1202	.             <td>uid_t *ruid</td>
  1203	.             <td>uid_t *euid</td>
  1204	.             <td>uid_t *suid</td>
  1205	.             <td></td>
  1206	.             <td></td>
  1207	.             <td></td>
  1208	.         </tr>
  1209	.         <tr>
  1210	.             <td>119</td>
  1211	.             <td>sys_setresgid</td>
  1212	.             <td>gid_t rgid</td>
  1213	.             <td>gid_t egid</td>
  1214	.             <td>gid_t sgid</td>
  1215	.             <td></td>
  1216	.             <td></td>
  1217	.             <td></td>
  1218	.         </tr>
  1219	.         <tr>
  1220	.             <td>120</td>
  1221	.             <td>sys_getresgid</td>
  1222	.             <td>gid_t *rgid</td>
  1223	.             <td>gid_t *egid</td>
  1224	.             <td>gid_t *sgid</td>
  1225	.             <td></td>
  1226	.             <td></td>
  1227	.             <td></td>
  1228	.         </tr>
  1229	.         <tr>
  1230	.             <td>121</td>
  1231	.             <td>sys_getpgid</td>
  1232	.             <td>pid_t pid</td>
  1233	.             <td></td>
  1234	.             <td></td>
  1235	.             <td></td>
  1236	.             <td></td>
  1237	.             <td></td>
  1238	.         </tr>
  1239	.         <tr>
  1240	.             <td>122</td>
  1241	.             <td>sys_setfsuid</td>
  1242	.             <td>uid_t uid</td>
  1243	.             <td></td>
  1244	.             <td></td>
  1245	.             <td></td>
  1246	.             <td></td>
  1247	.             <td></td>
  1248	.         </tr>
  1249	.         <tr>
  1250	.             <td>123</td>
  1251	.             <td>sys_setfsgid</td>
  1252	.             <td>gid_t gid</td>
  1253	.             <td></td>
  1254	.             <td></td>
  1255	.             <td></td>
  1256	.             <td></td>
  1257	.             <td></td>
  1258	.         </tr>
  1259	.         <tr>
  1260	.             <td>124</td>
  1261	.             <td>sys_getsid</td>
  1262	.             <td>pid_t pid</td>
  1263	.             <td></td>
  1264	.             <td></td>
  1265	.             <td></td>
  1266	.             <td></td>
  1267	.             <td></td>
  1268	.         </tr>
  1269	.         <tr>
  1270	.             <td>125</td>
  1271	.             <td>sys_capget</td>
  1272	.             <td>cap_user_header_t header</td>
  1273	.             <td>cap_user_data_t dataptr</td>
  1274	.             <td></td>
  1275	.             <td></td>
  1276	.             <td></td>
  1277	.             <td></td>
  1278	.         </tr>
  1279	.         <tr>
  1280	.             <td>126</td>
  1281	.             <td>sys_capset</td>
  1282	.             <td>cap_user_header_t header</td>
  1283	.             <td>const cap_user_data_t data</td>
  1284	.             <td></td>
  1285	.             <td></td>
  1286	.             <td></td>
  1287	.             <td></td>
  1288	.         </tr>
  1289	.         <tr>
  1290	.             <td>127</td>
  1291	.             <td>sys_rt_sigpending</td>
  1292	.             <td>sigset_t *set</td>
  1293	.             <td>size_t sigsetsize</td>
  1294	.             <td></td>
  1295	.             <td></td>
  1296	.             <td></td>
  1297	.             <td></td>
  1298	.         </tr>
  1299	.         <tr>
  1300	.             <td>128</td>
  1301	.             <td>sys_rt_sigtimedwait</td>
  1302	.             <td>const sigset_t *uthese</td>
  1303	.             <td>siginfo_t *uinfo</td>
  1304	.             <td>const struct timespec *uts</td>
  1305	.             <td>size_t sigsetsize</td>
  1306	.             <td></td>
  1307	.             <td></td>
  1308	.         </tr>
  1309	.         <tr>
  1310	.             <td>129</td>
  1311	.             <td>sys_rt_sigqueueinfo</td>
  1312	.             <td>pid_t pid</td>
  1313	.             <td>int sig</td>
  1314	.             <td>siginfo_t *uinfo</td>
  1315	.             <td></td>
  1316	.             <td></td>
  1317	.             <td></td>
  1318	.         </tr>
  1319	.         <tr>
  1320	.             <td>130</td>
  1321	.             <td>sys_rt_sigsuspend</td>
  1322	.             <td>sigset_t *unewset</td>
  1323	.             <td>size_t sigsetsize</td>
  1324	.             <td></td>
  1325	.             <td></td>
  1326	.             <td></td>
  1327	.             <td></td>
  1328	.         </tr>
  1329	.         <tr>
  1330	.             <td>131</td>
  1331	.             <td>sys_sigaltstack</td>
  1332	.             <td>const stack_t *uss</td>
  1333	.             <td>stack_t *uoss</td>
  1334	.             <td></td>
  1335	.             <td></td>
  1336	.             <td></td>
  1337	.             <td></td>
  1338	.         </tr>
  1339	.         <tr>
  1340	.             <td>132</td>
  1341	.             <td>sys_utime</td>
  1342	.             <td>char *filename</td>
  1343	.             <td>struct utimbuf *times</td>
  1344	.             <td></td>
  1345	.             <td></td>
  1346	.             <td></td>
  1347	.             <td></td>
  1348	.         </tr>
  1349	.         <tr>
  1350	.             <td>133</td>
  1351	.             <td>sys_mknod</td>
  1352	.             <td>const char *filename</td>
  1353	.             <td>umode_t mode</td>
  1354	.             <td>unsigned dev</td>
  1355	.             <td></td>
  1356	.             <td></td>
  1357	.             <td></td>
  1358	.         </tr>
  1359	.         <tr>
  1360	.             <td>134</td>
  1361	.             <td>sys_uselib</td>
  1362	.             <td>NOT IMPLEMENTED</td>
  1363	.             <td></td>
  1364	.             <td></td>
  1365	.             <td></td>
  1366	.             <td></td>
  1367	.             <td></td>
  1368	.         </tr>
  1369	.         <tr>
  1370	.             <td>135</td>
  1371	.             <td>sys_personality</td>
  1372	.             <td>unsigned int personality</td>
  1373	.             <td></td>
  1374	.             <td></td>
  1375	.             <td></td>
  1376	.             <td></td>
  1377	.             <td></td>
  1378	.         </tr>
  1379	.         <tr>
  1380	.             <td>136</td>
  1381	.             <td>sys_ustat</td>
  1382	.             <td>unsigned dev</td>
  1383	.             <td>struct ustat *ubuf</td>
  1384	.             <td></td>
  1385	.             <td></td>
  1386	.             <td></td>
  1387	.             <td></td>
  1388	.         </tr>
  1389	.         <tr>
  1390	.             <td>137</td>
  1391	.             <td>sys_statfs</td>
  1392	.             <td>const char *pathname</td>
  1393	.             <td>struct statfs *buf</td>
  1394	.             <td></td>
  1395	.             <td></td>
  1396	.             <td></td>
  1397	.             <td></td>
  1398	.         </tr>
  1399	.         <tr>
  1400	.             <td>138</td>
  1401	.             <td>sys_fstatfs</td>
  1402	.             <td>unsigned int fd</td>
  1403	.             <td>struct statfs *buf</td>
  1404	.             <td></td>
  1405	.             <td></td>
  1406	.             <td></td>
  1407	.             <td></td>
  1408	.         </tr>
  1409	.         <tr>
  1410	.             <td>139</td>
  1411	.             <td>sys_sysfs</td>
  1412	.             <td>int option</td>
  1413	.             <td>unsigned long arg1</td>
  1414	.             <td>unsigned long arg2</td>
  1415	.             <td></td>
  1416	.             <td></td>
  1417	.             <td></td>
  1418	.         </tr>
  1419	.         <tr>
  1420	.             <td>140</td>
  1421	.             <td>sys_getpriority</td>
  1422	.             <td>int which</td>
  1423	.             <td>int who</td>
  1424	.             <td></td>
  1425	.             <td></td>
  1426	.             <td></td>
  1427	.             <td></td>
  1428	.         </tr>
  1429	.         <tr>
  1430	.             <td>141</td>
  1431	.             <td>sys_setpriority</td>
  1432	.             <td>int which</td>
  1433	.             <td>int who</td>
  1434	.             <td>int niceval</td>
  1435	.             <td></td>
  1436	.             <td></td>
  1437	.             <td></td>
  1438	.         </tr>
  1439	.         <tr>
  1440	.             <td>142</td>
  1441	.             <td>sys_sched_setparam</td>
  1442	.             <td>pid_t pid</td>
  1443	.             <td>struct sched_param *param</td>
  1444	.             <td></td>
  1445	.             <td></td>
  1446	.             <td></td>
  1447	.             <td></td>
  1448	.         </tr>
  1449	.         <tr>
  1450	.             <td>143</td>
  1451	.             <td>sys_sched_getparam</td>
  1452	.             <td>pid_t pid</td>
  1453	.             <td>struct sched_param *param</td>
  1454	.             <td></td>
  1455	.             <td></td>
  1456	.             <td></td>
  1457	.             <td></td>
  1458	.         </tr>
  1459	.         <tr>
  1460	.             <td>144</td>
  1461	.             <td>sys_sched_setscheduler</td>
  1462	.             <td>pid_t pid</td>
  1463	.             <td>int policy</td>
  1464	.             <td>struct sched_param *param</td>
  1465	.             <td></td>
  1466	.             <td></td>
  1467	.             <td></td>
  1468	.         </tr>
  1469	.         <tr>
  1470	.             <td>145</td>
  1471	.             <td>sys_sched_getscheduler</td>
  1472	.             <td>pid_t pid</td>
  1473	.             <td></td>
  1474	.             <td></td>
  1475	.             <td></td>
  1476	.             <td></td>
  1477	.             <td></td>
  1478	.         </tr>
  1479	.         <tr>
  1480	.             <td>146</td>
  1481	.             <td>sys_sched_get_priority_max</td>
  1482	.             <td>int policy</td>
  1483	.             <td></td>
  1484	.             <td></td>
  1485	.             <td></td>
  1486	.             <td></td>
  1487	.             <td></td>
  1488	.         </tr>
  1489	.         <tr>
  1490	.             <td>147</td>
  1491	.             <td>sys_sched_get_priority_min</td>
  1492	.             <td>int policy</td>
  1493	.             <td></td>
  1494	.             <td></td>
  1495	.             <td></td>
  1496	.             <td></td>
  1497	.             <td></td>
  1498	.         </tr>
  1499	.         <tr>
  1500	.             <td>148</td>
  1501	.             <td>sys_sched_rr_get_interval</td>
  1502	.             <td>pid_t pid</td>
  1503	.             <td>struct timespec *interval</td>
  1504	.             <td></td>
  1505	.             <td></td>
  1506	.             <td></td>
  1507	.             <td></td>
  1508	.         </tr>
  1509	.         <tr>
  1510	.             <td>149</td>
  1511	.             <td>sys_mlock</td>
  1512	.             <td>unsigned long start</td>
  1513	.             <td>size_t len</td>
  1514	.             <td></td>
  1515	.             <td></td>
  1516	.             <td></td>
  1517	.             <td></td>
  1518	.         </tr>
  1519	.         <tr>
  1520	.             <td>150</td>
  1521	.             <td>sys_munlock</td>
  1522	.             <td>unsigned long start</td>
  1523	.             <td>size_t len</td>
  1524	.             <td></td>
  1525	.             <td></td>
  1526	.             <td></td>
  1527	.             <td></td>
  1528	.         </tr>
  1529	.         <tr>
  1530	.             <td>151</td>
  1531	.             <td>sys_mlockall</td>
  1532	.             <td>int flags</td>
  1533	.             <td></td>
  1534	.             <td></td>
  1535	.             <td></td>
  1536	.             <td></td>
  1537	.             <td></td>
  1538	.         </tr>
  1539	.         <tr>
  1540	.             <td>152</td>
  1541	.             <td>sys_munlockall</td>
  1542	.             <td></td>
  1543	.             <td></td>
  1544	.             <td></td>
  1545	.             <td></td>
  1546	.             <td></td>
  1547	.             <td></td>
  1548	.         </tr>
  1549	.         <tr>
  1550	.             <td>153</td>
  1551	.             <td>sys_vhangup</td>
  1552	.             <td></td>
  1553	.             <td></td>
  1554	.             <td></td>
  1555	.             <td></td>
  1556	.             <td></td>
  1557	.             <td></td>
  1558	.         </tr>
  1559	.         <tr>
  1560	.             <td>154</td>
  1561	.             <td>sys_modify_ldt</td>
  1562	.             <td>int func</td>
  1563	.             <td>void *ptr</td>
  1564	.             <td>unsigned long bytecount</td>
  1565	.             <td></td>
  1566	.             <td></td>
  1567	.             <td></td>
  1568	.         </tr>
  1569	.         <tr>
  1570	.             <td>155</td>
  1571	.             <td>sys_pivot_root</td>
  1572	.             <td>const char *new_root</td>
  1573	.             <td>const char *put_old</td>
  1574	.             <td></td>
  1575	.             <td></td>
  1576	.             <td></td>
  1577	.             <td></td>
  1578	.         </tr>
  1579	.         <tr>
  1580	.             <td>156</td>
  1581	.             <td>sys__sysctl</td>
  1582	.             <td>struct __sysctl_args *args</td>
  1583	.             <td></td>
  1584	.             <td></td>
  1585	.             <td></td>
  1586	.             <td></td>
  1587	.             <td></td>
  1588	.         </tr>
  1589	.         <tr>
  1590	.             <td>157</td>
  1591	.             <td>sys_prctl</td>
  1592	.             <td>int option</td>
  1593	.             <td>unsigned long arg2</td>
  1594	.             <td>unsigned long arg3</td>
  1595	.             <td>unsigned long arg4</td>
  1596	.             <td></td>
  1597	.             <td>unsigned long arg5</td>
  1598	.         </tr>
  1599	.         <tr>
  1600	.             <td>158</td>
  1601	.             <td>sys_arch_prctl</td>
  1602	.             <td>struct task_struct *task</td>
  1603	.             <td>int code</td>
  1604	.             <td>unsigned long *addr</td>
  1605	.             <td></td>
  1606	.             <td></td>
  1607	.             <td></td>
  1608	.         </tr>
  1609	.         <tr>
  1610	.             <td>159</td>
  1611	.             <td>sys_adjtimex</td>
  1612	.             <td>struct timex *txc_p</td>
  1613	.             <td></td>
  1614	.             <td></td>
  1615	.             <td></td>
  1616	.             <td></td>
  1617	.             <td></td>
  1618	.         </tr>
  1619	.         <tr>
  1620	.             <td>160</td>
  1621	.             <td>sys_setrlimit</td>
  1622	.             <td>unsigned int resource</td>
  1623	.             <td>struct rlimit *rlim</td>
  1624	.             <td></td>
  1625	.             <td></td>
  1626	.             <td></td>
  1627	.             <td></td>
  1628	.         </tr>
  1629	.         <tr>
  1630	.             <td>161</td>
  1631	.             <td>sys_chroot</td>
  1632	.             <td>const char *filename</td>
  1633	.             <td></td>
  1634	.             <td></td>
  1635	.             <td></td>
  1636	.             <td></td>
  1637	.             <td></td>
  1638	.         </tr>
  1639	.         <tr>
  1640	.             <td>162</td>
  1641	.             <td>sys_sync</td>
  1642	.             <td></td>
  1643	.             <td></td>
  1644	.             <td></td>
  1645	.             <td></td>
  1646	.             <td></td>
  1647	.             <td></td>
  1648	.         </tr>
  1649	.         <tr>
  1650	.             <td>163</td>
  1651	.             <td>sys_acct</td>
  1652	.             <td>const char *name</td>
  1653	.             <td></td>
  1654	.             <td></td>
  1655	.             <td></td>
  1656	.             <td></td>
  1657	.             <td></td>
  1658	.         </tr>
  1659	.         <tr>
  1660	.             <td>164</td>
  1661	.             <td>sys_settimeofday</td>
  1662	.             <td>struct timeval *tv</td>
  1663	.             <td>struct timezone *tz</td>
  1664	.             <td></td>
  1665	.             <td></td>
  1666	.             <td></td>
  1667	.             <td></td>
  1668	.         </tr>
  1669	.         <tr>
  1670	.             <td>165</td>
  1671	.             <td>sys_mount</td>
  1672	.             <td>char *dev_name</td>
  1673	.             <td>char *dir_name</td>
  1674	.             <td>char *type</td>
  1675	.             <td>unsigned long flags</td>
  1676	.             <td>void *data</td>
  1677	.             <td></td>
  1678	.         </tr>
  1679	.         <tr>
  1680	.             <td>166</td>
  1681	.             <td>sys_umount2</td>
  1682	.             <td>const char *target</td>
  1683	.             <td>int flags</td>
  1684	.             <td></td>
  1685	.             <td></td>
  1686	.             <td></td>
  1687	.             <td></td>
  1688	.         </tr>
  1689	.         <tr>
  1690	.             <td>167</td>
  1691	.             <td>sys_swapon</td>
  1692	.             <td>const char *specialfile</td>
  1693	.             <td>int swap_flags</td>
  1694	.             <td></td>
  1695	.             <td></td>
  1696	.             <td></td>
  1697	.             <td></td>
  1698	.         </tr>
  1699	.         <tr>
  1700	.             <td>168</td>
  1701	.             <td>sys_swapoff</td>
  1702	.             <td>const char *specialfile</td>
  1703	.             <td></td>
  1704	.             <td></td>
  1705	.             <td></td>
  1706	.             <td></td>
  1707	.             <td></td>
  1708	.         </tr>
  1709	.         <tr>
  1710	.             <td>169</td>
  1711	.             <td>sys_reboot</td>
  1712	.             <td>int magic1</td>
  1713	.             <td>int magic2</td>
  1714	.             <td>unsigned int cmd</td>
  1715	.             <td>void *arg</td>
  1716	.             <td></td>
  1717	.             <td></td>
  1718	.         </tr>
  1719	.         <tr>
  1720	.             <td>170</td>
  1721	.             <td>sys_sethostname</td>
  1722	.             <td>char *name</td>
  1723	.             <td>int len</td>
  1724	.             <td></td>
  1725	.             <td></td>
  1726	.             <td></td>
  1727	.             <td></td>
  1728	.         </tr>
  1729	.         <tr>
  1730	.             <td>171</td>
  1731	.             <td>sys_setdomainname</td>
  1732	.             <td>char *name</td>
  1733	.             <td>int len</td>
  1734	.             <td></td>
  1735	.             <td></td>
  1736	.             <td></td>
  1737	.             <td></td>
  1738	.         </tr>
  1739	.         <tr>
  1740	.             <td>172</td>
  1741	.             <td>sys_iopl</td>
  1742	.             <td>unsigned int level</td>
  1743	.             <td>struct pt_regs *regs</td>
  1744	.             <td></td>
  1745	.             <td></td>
  1746	.             <td></td>
  1747	.             <td></td>
  1748	.         </tr>
  1749	.         <tr>
  1750	.             <td>173</td>
  1751	.             <td>sys_ioperm</td>
  1752	.             <td>unsigned long from</td>
  1753	.             <td>unsigned long num</td>
  1754	.             <td>int turn_on</td>
  1755	.             <td></td>
  1756	.             <td></td>
  1757	.             <td></td>
  1758	.         </tr>
  1759	.         <tr>
  1760	.             <td>174</td>
  1761	.             <td>sys_create_module</td>
  1762	.             <td>REMOVED IN Linux 2.6</td>
  1763	.             <td></td>
  1764	.             <td></td>
  1765	.             <td></td>
  1766	.             <td></td>
  1767	.             <td></td>
  1768	.         </tr>
  1769	.         <tr>
  1770	.             <td>175</td>
  1771	.             <td>sys_init_module</td>
  1772	.             <td>void *umod</td>
  1773	.             <td>unsigned long len</td>
  1774	.             <td>const char *uargs</td>
  1775	.             <td></td>
  1776	.             <td></td>
  1777	.             <td></td>
  1778	.         </tr>
  1779	.         <tr>
  1780	.             <td>176</td>
  1781	.             <td>sys_delete_module</td>
  1782	.             <td>const chat *name_user</td>
  1783	.             <td>unsigned int flags</td>
  1784	.             <td></td>
  1785	.             <td></td>
  1786	.             <td></td>
  1787	.             <td></td>
  1788	.         </tr>
  1789	.         <tr>
  1790	.             <td>177</td>
  1791	.             <td>sys_get_kernel_syms</td>
  1792	.             <td>REMOVED IN Linux 2.6</td>
  1793	.             <td></td>
  1794	.             <td></td>
  1795	.             <td></td>
  1796	.             <td></td>
  1797	.             <td></td>
  1798	.         </tr>
  1799	.         <tr>
  1800	.             <td>178</td>
  1801	.             <td>sys_query_module</td>
  1802	.             <td>REMOVED IN Linux 2.6</td>
  1803	.             <td></td>
  1804	.             <td></td>
  1805	.             <td></td>
  1806	.             <td></td>
  1807	.             <td></td>
  1808	.         </tr>
  1809	.         <tr>
  1810	.             <td>179</td>
  1811	.             <td>sys_quotactl</td>
  1812	.             <td>unsigned int cmd</td>
  1813	.             <td>const char *special</td>
  1814	.             <td>qid_t id</td>
  1815	.             <td>void *addr</td>
  1816	.             <td></td>
  1817	.             <td></td>
  1818	.         </tr>
  1819	.         <tr>
  1820	.             <td>180</td>
  1821	.             <td>sys_nfsservctl</td>
  1822	.             <td>NOT IMPLEMENTED</td>
  1823	.             <td></td>
  1824	.             <td></td>
  1825	.             <td></td>
  1826	.             <td></td>
  1827	.             <td></td>
  1828	.         </tr>
  1829	.         <tr>
  1830	.             <td>181</td>
  1831	.             <td>sys_getpmsg</td>
  1832	.             <td>NOT IMPLEMENTED</td>
  1833	.             <td></td>
  1834	.             <td></td>
  1835	.             <td></td>
  1836	.             <td></td>
  1837	.             <td></td>
  1838	.         </tr>
  1839	.         <tr>
  1840	.             <td>182</td>
  1841	.             <td>sys_putpmsg</td>
  1842	.             <td>NOT IMPLEMENTED</td>
  1843	.             <td></td>
  1844	.             <td></td>
  1845	.             <td></td>
  1846	.             <td></td>
  1847	.             <td></td>
  1848	.         </tr>
  1849	.         <tr>
  1850	.             <td>183</td>
  1851	.             <td>sys_afs_syscall</td>
  1852	.             <td>NOT IMPLEMENTED</td>
  1853	.             <td></td>
  1854	.             <td></td>
  1855	.             <td></td>
  1856	.             <td></td>
  1857	.             <td></td>
  1858	.         </tr>
  1859	.         <tr>
  1860	.             <td>184</td>
  1861	.             <td>sys_tuxcall</td>
  1862	.             <td>NOT IMPLEMENTED</td>
  1863	.             <td></td>
  1864	.             <td></td>
  1865	.             <td></td>
  1866	.             <td></td>
  1867	.             <td></td>
  1868	.         </tr>
  1869	.         <tr>
  1870	.             <td>185</td>
  1871	.             <td>sys_security</td>
  1872	.             <td>NOT IMPLEMENTED</td>
  1873	.             <td></td>
  1874	.             <td></td>
  1875	.             <td></td>
  1876	.             <td></td>
  1877	.             <td></td>
  1878	.         </tr>
  1879	.         <tr>
  1880	.             <td>186</td>
  1881	.             <td>sys_gettid</td>
  1882	.             <td></td>
  1883	.             <td></td>
  1884	.             <td></td>
  1885	.             <td></td>
  1886	.             <td></td>
  1887	.             <td></td>
  1888	.         </tr>
  1889	.         <tr>
  1890	.             <td>187</td>
  1891	.             <td>sys_readahead</td>
  1892	.             <td>int fd</td>
  1893	.             <td>loff_t offset</td>
  1894	.             <td>size_t count</td>
  1895	.             <td></td>
  1896	.             <td></td>
  1897	.             <td></td>
  1898	.         </tr>
  1899	.         <tr>
  1900	.             <td>188</td>
  1901	.             <td>sys_setxattr</td>
  1902	.             <td>const char *pathname</td>
  1903	.             <td>const char *name</td>
  1904	.             <td>const void *value</td>
  1905	.             <td>size_t size</td>
  1906	.             <td>int flags</td>
  1907	.             <td></td>
  1908	.         </tr>
  1909	.         <tr>
  1910	.             <td>189</td>
  1911	.             <td>sys_lsetxattr</td>
  1912	.             <td>const char *pathname</td>
  1913	.             <td>const char *name</td>
  1914	.             <td>const void *value</td>
  1915	.             <td>size_t size</td>
  1916	.             <td>int flags</td>
  1917	.             <td></td>
  1918	.         </tr>
  1919	.         <tr>
  1920	.             <td>190</td>
  1921	.             <td>sys_fsetxattr</td>
  1922	.             <td>int fd</td>
  1923	.             <td>const char *name</td>
  1924	.             <td>const void *value</td>
  1925	.             <td>size_t size</td>
  1926	.             <td>int flags</td>
  1927	.             <td></td>
  1928	.         </tr>
  1929	.         <tr>
  1930	.             <td>191</td>
  1931	.             <td>sys_getxattr</td>
  1932	.             <td>const char *pathname</td>
  1933	.             <td>const char *name</td>
  1934	.             <td>void *value</td>
  1935	.             <td>size_t size</td>
  1936	.             <td></td>
  1937	.             <td></td>
  1938	.         </tr>
  1939	.         <tr>
  1940	.             <td>192</td>
  1941	.             <td>sys_lgetxattr</td>
  1942	.             <td>const char *pathname</td>
  1943	.             <td>const char *name</td>
  1944	.             <td>void *value</td>
  1945	.             <td>size_t size</td>
  1946	.             <td></td>
  1947	.             <td></td>
  1948	.         </tr>
  1949	.         <tr>
  1950	.             <td>193</td>
  1951	.             <td>sys_fgetxattr</td>
  1952	.             <td>int fd</td>
  1953	.             <td>const har *name</td>
  1954	.             <td>void *value</td>
  1955	.             <td>size_t size</td>
  1956	.             <td></td>
  1957	.             <td></td>
  1958	.         </tr>
  1959	.         <tr>
  1960	.             <td>194</td>
  1961	.             <td>sys_listxattr</td>
  1962	.             <td>const char *pathname</td>
  1963	.             <td>char *list</td>
  1964	.             <td>size_t size</td>
  1965	.             <td></td>
  1966	.             <td></td>
  1967	.             <td></td>
  1968	.         </tr>
  1969	.         <tr>
  1970	.             <td>195</td>
  1971	.             <td>sys_llistxattr</td>
  1972	.             <td>const char *pathname</td>
  1973	.             <td>char *list</td>
  1974	.             <td>size_t size</td>
  1975	.             <td></td>
  1976	.             <td></td>
  1977	.             <td></td>
  1978	.         </tr>
  1979	.         <tr>
  1980	.             <td>196</td>
  1981	.             <td>sys_flistxattr</td>
  1982	.             <td>int fd</td>
  1983	.             <td>char *list</td>
  1984	.             <td>size_t size</td>
  1985	.             <td></td>
  1986	.             <td></td>
  1987	.             <td></td>
  1988	.         </tr>
  1989	.         <tr>
  1990	.             <td>197</td>
  1991	.             <td>sys_removexattr</td>
  1992	.             <td>const char *pathname</td>
  1993	.             <td>const char *name</td>
  1994	.             <td></td>
  1995	.             <td></td>
  1996	.             <td></td>
  1997	.             <td></td>
  1998	.         </tr>
  1999	.         <tr>
  2000	.             <td>198</td>
  2001	.             <td>sys_lremovexattr</td>
  2002	.             <td>const char *pathname</td>
  2003	.             <td>const char *name</td>
  2004	.             <td></td>
  2005	.             <td></td>
  2006	.             <td></td>
  2007	.             <td></td>
  2008	.         </tr>
  2009	.         <tr>
  2010	.             <td>199</td>
  2011	.             <td>sys_fremovexattr</td>
  2012	.             <td>int fd</td>
  2013	.             <td>const char *name</td>
  2014	.             <td></td>
  2015	.             <td></td>
  2016	.             <td></td>
  2017	.             <td></td>
  2018	.         </tr>
  2019	.         <tr>
  2020	.             <td>200</td>
  2021	.             <td>sys_tkill</td>
  2022	.             <td>pid_t pid</td>
  2023	.             <td>ing sig</td>
  2024	.             <td></td>
  2025	.             <td></td>
  2026	.             <td></td>
  2027	.             <td></td>
  2028	.         </tr>
  2029	.         <tr>
  2030	.             <td>201</td>
  2031	.             <td>sys_time</td>
  2032	.             <td>time_t *tloc</td>
  2033	.             <td></td>
  2034	.             <td></td>
  2035	.             <td></td>
  2036	.             <td></td>
  2037	.             <td></td>
  2038	.         </tr>
  2039	.         <tr>
  2040	.             <td>202</td>
  2041	.             <td>sys_futex</td>
  2042	.             <td>u32 *uaddr</td>
  2043	.             <td>int op</td>
  2044	.             <td>u32 val</td>
  2045	.             <td>struct timespec *utime</td>
  2046	.             <td>u32 *uaddr2</td>
  2047	.             <td>u32 val3</td>
  2048	.         </tr>
  2049	.         <tr>
  2050	.             <td>203</td>
  2051	.             <td>sys_sched_setaffinity</td>
  2052	.             <td>pid_t pid</td>
  2053	.             <td>unsigned int len</td>
  2054	.             <td>unsigned long *user_mask_ptr</td>
  2055	.             <td></td>
  2056	.             <td></td>
  2057	.             <td></td>
  2058	.         </tr>
  2059	.         <tr>
  2060	.             <td>204</td>
  2061	.             <td>sys_sched_getaffinity</td>
  2062	.             <td>pid_t pid</td>
  2063	.             <td>unsigned int len</td>
  2064	.             <td>unsigned long *user_mask_ptr</td>
  2065	.             <td></td>
  2066	.             <td></td>
  2067	.             <td></td>
  2068	.         </tr>
  2069	.         <tr>
  2070	.             <td>205</td>
  2071	.             <td>sys_set_thread_area</td>
  2072	.             <td>NOT IMPLEMENTED. Use arch_prctl</td>
  2073	.             <td></td>
  2074	.             <td></td>
  2075	.             <td></td>
  2076	.             <td></td>
  2077	.             <td></td>
  2078	.         </tr>
  2079	.         <tr>
  2080	.             <td>206</td>
  2081	.             <td>sys_io_setup</td>
  2082	.             <td>unsigned nr_events</td>
  2083	.             <td>aio_context_t *ctxp</td>
  2084	.             <td></td>
  2085	.             <td></td>
  2086	.             <td></td>
  2087	.             <td></td>
  2088	.         </tr>
  2089	.         <tr>
  2090	.             <td>207</td>
  2091	.             <td>sys_io_destroy</td>
  2092	.             <td>aio_context_t ctx</td>
  2093	.             <td></td>
  2094	.             <td></td>
  2095	.             <td></td>
  2096	.             <td></td>
  2097	.             <td></td>
  2098	.         </tr>
  2099	.         <tr>
  2100	.             <td>208</td>
  2101	.             <td>sys_io_getevents</td>
  2102	.             <td>aio_context_t ctx_id</td>
  2103	.             <td>long min_nr</td>
  2104	.             <td>long nr</td>
  2105	.             <td>struct io_event *events</td>
  2106	.             <td></td>
  2107	.             <td></td>
  2108	.         </tr>
  2109	.         <tr>
  2110	.             <td>209</td>
  2111	.             <td>sys_io_submit</td>
  2112	.             <td>aio_context_t ctx_id</td>
  2113	.             <td>long nr</td>
  2114	.             <td>struct iocb **iocbpp</td>
  2115	.             <td></td>
  2116	.             <td></td>
  2117	.             <td></td>
  2118	.         </tr>
  2119	.         <tr>
  2120	.             <td>210</td>
  2121	.             <td>sys_io_cancel</td>
  2122	.             <td>aio_context_t ctx_id</td>
  2123	.             <td>struct iocb *iocb</td>
  2124	.             <td>struct io_event *result</td>
  2125	.             <td></td>
  2126	.             <td></td>
  2127	.             <td></td>
  2128	.         </tr>
  2129	.         <tr>
  2130	.             <td>211</td>
  2131	.             <td>sys_get_thread_area</td>
  2132	.             <td>NOT IMPLEMENTED. Use arch_prctl</td>
  2133	.             <td></td>
  2134	.             <td></td>
  2135	.             <td></td>
  2136	.             <td></td>
  2137	.             <td></td>
  2138	.         </tr>
  2139	.         <tr>
  2140	.             <td>212</td>
  2141	.             <td>sys_lookup_dcookie</td>
  2142	.             <td>u64 cookie64</td>
  2143	.             <td>long buf</td>
  2144	.             <td>long len</td>
  2145	.             <td></td>
  2146	.             <td></td>
  2147	.             <td></td>
  2148	.         </tr>
  2149	.         <tr>
  2150	.             <td>213</td>
  2151	.             <td>sys_epoll_create</td>
  2152	.             <td>int size</td>
  2153	.             <td></td>
  2154	.             <td></td>
  2155	.             <td></td>
  2156	.             <td></td>
  2157	.             <td></td>
  2158	.         </tr>
  2159	.         <tr>
  2160	.             <td>214</td>
  2161	.             <td>sys_epoll_ctl_old</td>
  2162	.             <td>NOT IMPLEMENTED</td>
  2163	.             <td></td>
  2164	.             <td></td>
  2165	.             <td></td>
  2166	.             <td></td>
  2167	.             <td></td>
  2168	.         </tr>
  2169	.         <tr>
  2170	.             <td>215</td>
  2171	.             <td>sys_epoll_wait_old</td>
  2172	.             <td>NOT IMPLEMENTED</td>
  2173	.             <td></td>
  2174	.             <td></td>
  2175	.             <td></td>
  2176	.             <td></td>
  2177	.             <td></td>
  2178	.         </tr>
  2179	.         <tr>
  2180	.             <td>216</td>
  2181	.             <td>sys_remap_file_pages</td>
  2182	.             <td>unsigned long start</td>
  2183	.             <td>unsigned long size</td>
  2184	.             <td>unsigned long prot</td>
  2185	.             <td>unsigned long pgoff</td>
  2186	.             <td>unsigned long flags</td>
  2187	.             <td></td>
  2188	.         </tr>
  2189	.         <tr>
  2190	.             <td>217</td>
  2191	.             <td>sys_getdents64</td>
  2192	.             <td>unsigned int fd</td>
  2193	.             <td>struct linux_dirent64 *dirent</td>
  2194	.             <td>unsigned int count</td>
  2195	.             <td></td>
  2196	.             <td></td>
  2197	.             <td></td>
  2198	.         </tr>
  2199	.         <tr>
  2200	.             <td>218</td>
  2201	.             <td>sys_set_tid_address</td>
  2202	.             <td>int *tidptr</td>
  2203	.             <td></td>
  2204	.             <td></td>
  2205	.             <td></td>
  2206	.             <td></td>
  2207	.             <td></td>
  2208	.         </tr>
  2209	.         <tr>
  2210	.             <td>219</td>
  2211	.             <td>sys_restart_syscall</td>
  2212	.             <td></td>
  2213	.             <td></td>
  2214	.             <td></td>
  2215	.             <td></td>
  2216	.             <td></td>
  2217	.             <td></td>
  2218	.         </tr>
  2219	.         <tr>
  2220	.             <td>220</td>
  2221	.             <td>sys_semtimedop</td>
  2222	.             <td>int semid</td>
  2223	.             <td>struct sembuf *tsops</td>
  2224	.             <td>unsigned nsops</td>
  2225	.             <td>const struct timespec *timeout</td>
  2226	.             <td></td>
  2227	.             <td></td>
  2228	.         </tr>
  2229	.         <tr>
  2230	.             <td>221</td>
  2231	.             <td>sys_fadvise64</td>
  2232	.             <td>int fd</td>
  2233	.             <td>loff_t offset</td>
  2234	.             <td>size_t len</td>
  2235	.             <td>int advice</td>
  2236	.             <td></td>
  2237	.             <td></td>
  2238	.         </tr>
  2239	.         <tr>
  2240	.             <td>222</td>
  2241	.             <td>sys_timer_create</td>
  2242	.             <td>const clockid_t which_clock</td>
  2243	.             <td>struct sigevent *timer_event_spec</td>
  2244	.             <td>timer_t *created_timer_id</td>
  2245	.             <td></td>
  2246	.             <td></td>
  2247	.             <td></td>
  2248	.         </tr>
  2249	.         <tr>
  2250	.             <td>223</td>
  2251	.             <td>sys_timer_settime</td>
  2252	.             <td>timer_t timer_id</td>
  2253	.             <td>int flags</td>
  2254	.             <td>const struct itimerspec *new_setting</td>
  2255	.             <td>struct itimerspec *old_setting</td>
  2256	.             <td></td>
  2257	.             <td></td>
  2258	.         </tr>
  2259	.         <tr>
  2260	.             <td>224</td>
  2261	.             <td>sys_timer_gettime</td>
  2262	.             <td>timer_t timer_id</td>
  2263	.             <td>struct itimerspec *setting</td>
  2264	.             <td></td>
  2265	.             <td></td>
  2266	.             <td></td>
  2267	.             <td></td>
  2268	.         </tr>
  2269	.         <tr>
  2270	.             <td>225</td>
  2271	.             <td>sys_timer_getoverrun</td>
  2272	.             <td>timer_t timer_id</td>
  2273	.             <td></td>
  2274	.             <td></td>
  2275	.             <td></td>
  2276	.             <td></td>
  2277	.             <td></td>
  2278	.         </tr>
  2279	.         <tr>
  2280	.             <td>226</td>
  2281	.             <td>sys_timer_delete</td>
  2282	.             <td>timer_t timer_id</td>
  2283	.             <td></td>
  2284	.             <td></td>
  2285	.             <td></td>
  2286	.             <td></td>
  2287	.             <td></td>
  2288	.         </tr>
  2289	.         <tr>
  2290	.             <td>227</td>
  2291	.             <td>sys_clock_settime</td>
  2292	.             <td>const clockid_t which_clock</td>
  2293	.             <td>const struct timespec *tp</td>
  2294	.             <td></td>
  2295	.             <td></td>
  2296	.             <td></td>
  2297	.             <td></td>
  2298	.         </tr>
  2299	.         <tr>
  2300	.             <td>228</td>
  2301	.             <td>sys_clock_gettime</td>
  2302	.             <td>const clockid_t which_clock</td>
  2303	.             <td>struct timespec *tp</td>
  2304	.             <td></td>
  2305	.             <td></td>
  2306	.             <td></td>
  2307	.             <td></td>
  2308	.         </tr>
  2309	.         <tr>
  2310	.             <td>229</td>
  2311	.             <td>sys_clock_getres</td>
  2312	.             <td>const clockid_t which_clock</td>
  2313	.             <td>struct timespec *tp</td>
  2314	.             <td></td>
  2315	.             <td></td>
  2316	.             <td></td>
  2317	.             <td></td>
  2318	.         </tr>
  2319	.         <tr>
  2320	.             <td>230</td>
  2321	.             <td>sys_clock_nanosleep</td>
  2322	.             <td>const clockid_t which_clock</td>
  2323	.             <td>int flags</td>
  2324	.             <td>const struct timespec *rqtp</td>
  2325	.             <td>struct timespec *rmtp</td>
  2326	.             <td></td>
  2327	.             <td></td>
  2328	.         </tr>
  2329	.         <tr>
  2330	.             <td>231</td>
  2331	.             <td>sys_exit_group</td>
  2332	.             <td>int error_code</td>
  2333	.             <td></td>
  2334	.             <td></td>
  2335	.             <td></td>
  2336	.             <td></td>
  2337	.             <td></td>
  2338	.         </tr>
  2339	.         <tr>
  2340	.             <td>232</td>
  2341	.             <td>sys_epoll_wait</td>
  2342	.             <td>int epfd</td>
  2343	.             <td>struct epoll_event *events</td>
  2344	.             <td>int maxevents</td>
  2345	.             <td>int timeout</td>
  2346	.             <td></td>
  2347	.             <td></td>
  2348	.         </tr>
  2349	.         <tr>
  2350	.             <td>233</td>
  2351	.             <td>sys_epoll_ctl</td>
  2352	.             <td>int epfd</td>
  2353	.             <td>int op</td>
  2354	.             <td>int fd</td>
  2355	.             <td>struct epoll_event *event</td>
  2356	.             <td></td>
  2357	.             <td></td>
  2358	.         </tr>
  2359	.         <tr>
  2360	.             <td>234</td>
  2361	.             <td>sys_tgkill</td>
  2362	.             <td>pid_t tgid</td>
  2363	.             <td>pid_t pid</td>
  2364	.             <td>int sig</td>
  2365	.             <td></td>
  2366	.             <td></td>
  2367	.             <td></td>
  2368	.         </tr>
  2369	.         <tr>
  2370	.             <td>235</td>
  2371	.             <td>sys_utimes</td>
  2372	.             <td>char *filename</td>
  2373	.             <td>struct timeval *utimes</td>
  2374	.             <td></td>
  2375	.             <td></td>
  2376	.             <td></td>
  2377	.             <td></td>
  2378	.         </tr>
  2379	.         <tr>
  2380	.             <td>236</td>
  2381	.             <td>sys_vserver</td>
  2382	.             <td>NOT IMPLEMENTED</td>
  2383	.             <td></td>
  2384	.             <td></td>
  2385	.             <td></td>
  2386	.             <td></td>
  2387	.             <td></td>
  2388	.         </tr>
  2389	.         <tr>
  2390	.             <td>237</td>
  2391	.             <td>sys_mbind</td>
  2392	.             <td>unsigned long start</td>
  2393	.             <td>unsigned long len</td>
  2394	.             <td>unsigned long mode</td>
  2395	.             <td>unsigned long *nmask</td>
  2396	.             <td>unsigned long maxnode</td>
  2397	.             <td>unsigned flags</td>
  2398	.         </tr>
  2399	.         <tr>
  2400	.             <td>238</td>
  2401	.             <td>sys_set_mempolicy</td>
  2402	.             <td>int mode</td>
  2403	.             <td>unsigned long *nmask</td>
  2404	.             <td>unsigned long maxnode</td>
  2405	.             <td></td>
  2406	.             <td></td>
  2407	.             <td></td>
  2408	.         </tr>
  2409	.         <tr>
  2410	.             <td>239</td>
  2411	.             <td>sys_get_mempolicy</td>
  2412	.             <td>int *policy</td>
  2413	.             <td>unsigned long *nmask</td>
  2414	.             <td>unsigned long maxnode</td>
  2415	.             <td>unsigned long addr</td>
  2416	.             <td>unsigned long flags</td>
  2417	.             <td></td>
  2418	.         </tr>
  2419	.         <tr>
  2420	.             <td>240</td>
  2421	.             <td>sys_mq_open</td>
  2422	.             <td>const char *u_name</td>
  2423	.             <td>int oflag</td>
  2424	.             <td>mode_t mode</td>
  2425	.             <td>struct mq_attr *u_attr</td>
  2426	.             <td></td>
  2427	.             <td></td>
  2428	.         </tr>
  2429	.         <tr>
  2430	.             <td>241</td>
  2431	.             <td>sys_mq_unlink</td>
  2432	.             <td>const char *u_name</td>
  2433	.             <td></td>
  2434	.             <td></td>
  2435	.             <td></td>
  2436	.             <td></td>
  2437	.             <td></td>
  2438	.         </tr>
  2439	.         <tr>
  2440	.             <td>242</td>
  2441	.             <td>sys_mq_timedsend</td>
  2442	.             <td>mqd_t mqdes</td>
  2443	.             <td>const char *u_msg_ptr</td>
  2444	.             <td>size_t msg_len</td>
  2445	.             <td>unsigned int msg_prio</td>
  2446	.             <td>const stuct timespec *u_abs_timeout</td>
  2447	.             <td></td>
  2448	.         </tr>
  2449	.         <tr>
  2450	.             <td>243</td>
  2451	.             <td>sys_mq_timedreceive</td>
  2452	.             <td>mqd_t mqdes</td>
  2453	.             <td>char *u_msg_ptr</td>
  2454	.             <td>size_t msg_len</td>
  2455	.             <td>unsigned int *u_msg_prio</td>
  2456	.             <td>const struct timespec *u_abs_timeout</td>
  2457	.             <td></td>
  2458	.         </tr>
  2459	.         <tr>
  2460	.             <td>244</td>
  2461	.             <td>sys_mq_notify</td>
  2462	.             <td>mqd_t mqdes</td>
  2463	.             <td>const struct sigevent *u_notification</td>
  2464	.             <td></td>
  2465	.             <td></td>
  2466	.             <td></td>
  2467	.             <td></td>
  2468	.         </tr>
  2469	.         <tr>
  2470	.             <td>245</td>
  2471	.             <td>sys_mq_getsetattr</td>
  2472	.             <td>mqd_t mqdes</td>
  2473	.             <td>const struct mq_attr *u_mqstat</td>
  2474	.             <td>struct mq_attr *u_omqstat</td>
  2475	.             <td></td>
  2476	.             <td></td>
  2477	.             <td></td>
  2478	.         </tr>
  2479	.         <tr>
  2480	.             <td>246</td>
  2481	.             <td>sys_kexec_load</td>
  2482	.             <td>unsigned long entry</td>
  2483	.             <td>unsigned long nr_segments</td>
  2484	.             <td>struct kexec_segment *segments</td>
  2485	.             <td>unsigned long flags</td>
  2486	.             <td></td>
  2487	.             <td></td>
  2488	.         </tr>
  2489	.         <tr>
  2490	.             <td>247</td>
  2491	.             <td>sys_waitid</td>
  2492	.             <td>int which</td>
  2493	.             <td>pid_t upid</td>
  2494	.             <td>struct siginfo *infop</td>
  2495	.             <td>int options</td>
  2496	.             <td>struct rusage *ru</td>
  2497	.             <td></td>
  2498	.         </tr>
  2499	.         <tr>
  2500	.             <td>248</td>
  2501	.             <td>sys_add_key</td>
  2502	.             <td>const char *_type</td>
  2503	.             <td>const char *_description</td>
  2504	.             <td>const void *_payload</td>
  2505	.             <td>size_t plen</td>
  2506	.             <td></td>
  2507	.             <td></td>
  2508	.         </tr>
  2509	.         <tr>
  2510	.             <td>249</td>
  2511	.             <td>sys_request_key</td>
  2512	.             <td>const char *_type</td>
  2513	.             <td>const char *_description</td>
  2514	.             <td>const char *_callout_info</td>
  2515	.             <td>key_serial_t destringid</td>
  2516	.             <td></td>
  2517	.             <td></td>
  2518	.         </tr>
  2519	.         <tr>
  2520	.             <td>250</td>
  2521	.             <td>sys_keyctl</td>
  2522	.             <td>int option</td>
  2523	.             <td>unsigned long arg2</td>
  2524	.             <td>unsigned long arg3</td>
  2525	.             <td>unsigned long arg4</td>
  2526	.             <td>unsigned long arg5</td>
  2527	.             <td></td>
  2528	.         </tr>
  2529	.         <tr>
  2530	.             <td>251</td>
  2531	.             <td>sys_ioprio_set</td>
  2532	.             <td>int which</td>
  2533	.             <td>int who</td>
  2534	.             <td>int ioprio</td>
  2535	.             <td></td>
  2536	.             <td></td>
  2537	.             <td></td>
  2538	.         </tr>
  2539	.         <tr>
  2540	.             <td>252</td>
  2541	.             <td>sys_ioprio_get</td>
  2542	.             <td>int which</td>
  2543	.             <td>int who</td>
  2544	.             <td></td>
  2545	.             <td></td>
  2546	.             <td></td>
  2547	.             <td></td>
  2548	.         </tr>
  2549	.         <tr>
  2550	.             <td>253</td>
  2551	.             <td>sys_inotify_init</td>
  2552	.             <td></td>
  2553	.             <td></td>
  2554	.             <td></td>
  2555	.             <td></td>
  2556	.             <td></td>
  2557	.             <td></td>
  2558	.         </tr>
  2559	.         <tr>
  2560	.             <td>254</td>
  2561	.             <td>sys_inotify_add_watch</td>
  2562	.             <td>int fd</td>
  2563	.             <td>const char *pathname</td>
  2564	.             <td>u32 mask</td>
  2565	.             <td></td>
  2566	.             <td></td>
  2567	.             <td></td>
  2568	.         </tr>
  2569	.         <tr>
  2570	.             <td>255</td>
  2571	.             <td>sys_inotify_rm_watch</td>
  2572	.             <td>int fd</td>
  2573	.             <td>__s32 wd</td>
  2574	.             <td></td>
  2575	.             <td></td>
  2576	.             <td></td>
  2577	.             <td></td>
  2578	.         </tr>
  2579	.         <tr>
  2580	.             <td>256</td>
  2581	.             <td>sys_migrate_pages</td>
  2582	.             <td>pid_t pid</td>
  2583	.             <td>unsigned long maxnode</td>
  2584	.             <td>const unsigned long *old_nodes</td>
  2585	.             <td>const unsigned long *new_nodes</td>
  2586	.             <td></td>
  2587	.             <td></td>
  2588	.         </tr>
  2589	.         <tr>
  2590	.             <td>257</td>
  2591	.             <td>sys_openat</td>
  2592	.             <td>int dfd</td>
  2593	.             <td>const char *filename</td>
  2594	.             <td>int flags</td>
  2595	.             <td>int mode</td>
  2596	.             <td></td>
  2597	.             <td></td>
  2598	.         </tr>
  2599	.         <tr>
  2600	.             <td>258</td>
  2601	.             <td>sys_mkdirat</td>
  2602	.             <td>int dfd</td>
  2603	.             <td>const char *pathname</td>
  2604	.             <td>int mode</td>
  2605	.             <td></td>
  2606	.             <td></td>
  2607	.             <td></td>
  2608	.         </tr>
  2609	.         <tr>
  2610	.             <td>259</td>
  2611	.             <td>sys_mknodat</td>
  2612	.             <td>int dfd</td>
  2613	.             <td>const char *filename</td>
  2614	.             <td>int mode</td>
  2615	.             <td>unsigned dev</td>
  2616	.             <td></td>
  2617	.             <td></td>
  2618	.         </tr>
  2619	.         <tr>
  2620	.             <td>260</td>
  2621	.             <td>sys_fchownat</td>
  2622	.             <td>int dfd</td>
  2623	.             <td>const char *filename</td>
  2624	.             <td>uid_t user</td>
  2625	.             <td>gid_t group</td>
  2626	.             <td>int flag</td>
  2627	.             <td></td>
  2628	.         </tr>
  2629	.         <tr>
  2630	.             <td>261</td>
  2631	.             <td>sys_futimesat</td>
  2632	.             <td>int dfd</td>
  2633	.             <td>const char *filename</td>
  2634	.             <td>struct timeval *utimes</td>
  2635	.             <td></td>
  2636	.             <td></td>
  2637	.             <td></td>
  2638	.         </tr>
  2639	.         <tr>
  2640	.             <td>262</td>
  2641	.             <td>sys_newfstatat</td>
  2642	.             <td>int dfd</td>
  2643	.             <td>const char *filename</td>
  2644	.             <td>struct stat *statbuf</td>
  2645	.             <td>int flag</td>
  2646	.             <td></td>
  2647	.             <td></td>
  2648	.         </tr>
  2649	.         <tr>
  2650	.             <td>263</td>
  2651	.             <td>sys_unlinkat</td>
  2652	.             <td>int dfd</td>
  2653	.             <td>const char *pathname</td>
  2654	.             <td>int flag</td>
  2655	.             <td></td>
  2656	.             <td></td>
  2657	.             <td></td>
  2658	.         </tr>
  2659	.         <tr>
  2660	.             <td>264</td>
  2661	.             <td>sys_renameat</td>
  2662	.             <td>int oldfd</td>
  2663	.             <td>const char *oldname</td>
  2664	.             <td>int newfd</td>
  2665	.             <td>const char *newname</td>
  2666	.             <td></td>
  2667	.             <td></td>
  2668	.         </tr>
  2669	.         <tr>
  2670	.             <td>265</td>
  2671	.             <td>sys_linkat</td>
  2672	.             <td>int oldfd</td>
  2673	.             <td>const char *oldname</td>
  2674	.             <td>int newfd</td>
  2675	.             <td>const char *newname</td>
  2676	.             <td>int flags</td>
  2677	.             <td></td>
  2678	.         </tr>
  2679	.         <tr>
  2680	.             <td>266</td>
  2681	.             <td>sys_symlinkat</td>
  2682	.             <td>const char *oldname</td>
  2683	.             <td>int newfd</td>
  2684	.             <td>const char *newname</td>
  2685	.             <td></td>
  2686	.             <td></td>
  2687	.             <td></td>
  2688	.         </tr>
  2689	.         <tr>
  2690	.             <td>267</td>
  2691	.             <td>sys_readlinkat</td>
  2692	.             <td>int dfd</td>
  2693	.             <td>const char *pathname</td>
  2694	.             <td>char *buf</td>
  2695	.             <td>int bufsiz</td>
  2696	.             <td></td>
  2697	.             <td></td>
  2698	.         </tr>
  2699	.         <tr>
  2700	.             <td>268</td>
  2701	.             <td>sys_fchmodat</td>
  2702	.             <td>int dfd</td>
  2703	.             <td>const char *filename</td>
  2704	.             <td>mode_t mode</td>
  2705	.             <td></td>
  2706	.             <td></td>
  2707	.             <td></td>
  2708	.         </tr>
  2709	.         <tr>
  2710	.             <td>269</td>
  2711	.             <td>sys_faccessat</td>
  2712	.             <td>int dfd</td>
  2713	.             <td>const char *filename</td>
  2714	.             <td>int mode</td>
  2715	.             <td></td>
  2716	.             <td></td>
  2717	.             <td></td>
  2718	.         </tr>
  2719	.         <tr>
  2720	.             <td>270</td>
  2721	.             <td>sys_pselect6</td>
  2722	.             <td>int n</td>
  2723	.             <td>fd_set *inp</td>
  2724	.             <td>fd_set *outp</td>
  2725	.             <td>fd_set *exp</td>
  2726	.             <td>struct timespec *tsp</td>
  2727	.             <td>void *sig</td>
  2728	.         </tr>
  2729	.         <tr>
  2730	.             <td>271</td>
  2731	.             <td>sys_ppoll</td>
  2732	.             <td>struct pollfd *ufds</td>
  2733	.             <td>unsigned int nfds</td>
  2734	.             <td>struct timespec *tsp</td>
  2735	.             <td>const sigset_t *sigmask</td>
  2736	.             <td>size_t sigsetsize</td>
  2737	.             <td></td>
  2738	.         </tr>
  2739	.         <tr>
  2740	.             <td>272</td>
  2741	.             <td>sys_unshare</td>
  2742	.             <td>unsigned long unshare_flags</td>
  2743	.             <td></td>
  2744	.             <td></td>
  2745	.             <td></td>
  2746	.             <td></td>
  2747	.             <td></td>
  2748	.         </tr>
  2749	.         <tr>
  2750	.             <td>273</td>
  2751	.             <td>sys_set_robust_list</td>
  2752	.             <td>struct robust_list_head *head</td>
  2753	.             <td>size_t len</td>
  2754	.             <td></td>
  2755	.             <td></td>
  2756	.             <td></td>
  2757	.             <td></td>
  2758	.         </tr>
  2759	.         <tr>
  2760	.             <td>274</td>
  2761	.             <td>sys_get_robust_list</td>
  2762	.             <td>int pid</td>
  2763	.             <td>struct robust_list_head **head_ptr</td>
  2764	.             <td>size_t *len_ptr</td>
  2765	.             <td></td>
  2766	.             <td></td>
  2767	.             <td></td>
  2768	.         </tr>
  2769	.         <tr>
  2770	.             <td>275</td>
  2771	.             <td>sys_splice</td>
  2772	.             <td>int fd_in</td>
  2773	.             <td>loff_t *off_in</td>
  2774	.             <td>int fd_out</td>
  2775	.             <td>loff_t *off_out</td>
  2776	.             <td>size_t len</td>
  2777	.             <td>unsigned int flags</td>
  2778	.         </tr>
  2779	.         <tr>
  2780	.             <td>276</td>
  2781	.             <td>sys_tee</td>
  2782	.             <td>int fdin</td>
  2783	.             <td>int fdout</td>
  2784	.             <td>size_t len</td>
  2785	.             <td>unsigned int flags</td>
  2786	.             <td></td>
  2787	.             <td></td>
  2788	.         </tr>
  2789	.         <tr>
  2790	.             <td>277</td>
  2791	.             <td>sys_sync_file_range</td>
  2792	.             <td>long fd</td>
  2793	.             <td>loff_t offset</td>
  2794	.             <td>loff_t bytes</td>
  2795	.             <td>long flags</td>
  2796	.             <td></td>
  2797	.             <td></td>
  2798	.         </tr>
  2799	.         <tr>
  2800	.             <td>278</td>
  2801	.             <td>sys_vmsplice</td>
  2802	.             <td>int fd</td>
  2803	.             <td>const struct iovec *iov</td>
  2804	.             <td>unsigned long nr_segs</td>
  2805	.             <td>unsigned int flags</td>
  2806	.             <td></td>
  2807	.             <td></td>
  2808	.         </tr>
  2809	.         <tr>
  2810	.             <td>279</td>
  2811	.             <td>sys_move_pages</td>
  2812	.             <td>pid_t pid</td>
  2813	.             <td>unsigned long nr_pages</td>
  2814	.             <td>const void **pages</td>
  2815	.             <td>const int *nodes</td>
  2816	.             <td>int *status</td>
  2817	.             <td>int flags</td>
  2818	.         </tr>
  2819	.         <tr>
  2820	.             <td>280</td>
  2821	.             <td>sys_utimensat</td>
  2822	.             <td>int dfd</td>
  2823	.             <td>const char *filename</td>
  2824	.             <td>struct timespec *utimes</td>
  2825	.             <td>int flags</td>
  2826	.             <td></td>
  2827	.             <td></td>
  2828	.         </tr>
  2829	.         <tr>
  2830	.             <td>281</td>
  2831	.             <td>sys_epoll_pwait</td>
  2832	.             <td>int epfd</td>
  2833	.             <td>struct epoll_event *events</td>
  2834	.             <td>int maxevents</td>
  2835	.             <td>int timeout</td>
  2836	.             <td>const sigset_t *sigmask</td>
  2837	.             <td>size_t sigsetsize</td>
  2838	.         </tr>
  2839	.         <tr>
  2840	.             <td>282</td>
  2841	.             <td>sys_signalfd</td>
  2842	.             <td>int ufd</td>
  2843	.             <td>sigset_t *user_mask</td>
  2844	.             <td>size_t sizemask</td>
  2845	.             <td></td>
  2846	.             <td></td>
  2847	.             <td></td>
  2848	.         </tr>
  2849	.         <tr>
  2850	.             <td>283</td>
  2851	.             <td>sys_timerfd_create</td>
  2852	.             <td>int clockid</td>
  2853	.             <td>int flags</td>
  2854	.             <td></td>
  2855	.             <td></td>
  2856	.             <td></td>
  2857	.             <td></td>
  2858	.         </tr>
  2859	.         <tr>
  2860	.             <td>284</td>
  2861	.             <td>sys_eventfd</td>
  2862	.             <td>unsigned int count</td>
  2863	.             <td></td>
  2864	.             <td></td>
  2865	.             <td></td>
  2866	.             <td></td>
  2867	.             <td></td>
  2868	.         </tr>
  2869	.         <tr>
  2870	.             <td>285</td>
  2871	.             <td>sys_fallocate</td>
  2872	.             <td>long fd</td>
  2873	.             <td>long mode</td>
  2874	.             <td>loff_t offset</td>
  2875	.             <td>loff_t len</td>
  2876	.             <td></td>
  2877	.             <td></td>
  2878	.         </tr>
  2879	.         <tr>
  2880	.             <td>286</td>
  2881	.             <td>sys_timerfd_settime</td>
  2882	.             <td>int ufd</td>
  2883	.             <td>int flags</td>
  2884	.             <td>const struct itimerspec *utmr</td>
  2885	.             <td>struct itimerspec *otmr</td>
  2886	.             <td></td>
  2887	.             <td></td>
  2888	.         </tr>
  2889	.         <tr>
  2890	.             <td>287</td>
  2891	.             <td>sys_timerfd_gettime</td>
  2892	.             <td>int ufd</td>
  2893	.             <td>struct itimerspec *otmr</td>
  2894	.             <td></td>
  2895	.             <td></td>
  2896	.             <td></td>
  2897	.             <td></td>
  2898	.         </tr>
  2899	.         <tr>
  2900	.             <td>288</td>
  2901	.             <td>sys_accept4</td>
  2902	.             <td>int fd</td>
  2903	.             <td>struct sockaddr *upeer_sockaddr</td>
  2904	.             <td>int *upeer_addrlen</td>
  2905	.             <td>int flags</td>
  2906	.             <td></td>
  2907	.             <td></td>
  2908	.         </tr>
  2909	.         <tr>
  2910	.             <td>289</td>
  2911	.             <td>sys_signalfd4</td>
  2912	.             <td>int ufd</td>
  2913	.             <td>sigset_t *user_mask</td>
  2914	.             <td>size_t sizemask</td>
  2915	.             <td>int flags</td>
  2916	.             <td></td>
  2917	.             <td></td>
  2918	.         </tr>
  2919	.         <tr>
  2920	.             <td>290</td>
  2921	.             <td>sys_eventfd2</td>
  2922	.             <td>unsigned int count</td>
  2923	.             <td>int flags</td>
  2924	.             <td></td>
  2925	.             <td></td>
  2926	.             <td></td>
  2927	.             <td></td>
  2928	.         </tr>
  2929	.         <tr>
  2930	.             <td>291</td>
  2931	.             <td>sys_epoll_create1</td>
  2932	.             <td>int flags</td>
  2933	.             <td></td>
  2934	.             <td></td>
  2935	.             <td></td>
  2936	.             <td></td>
  2937	.             <td></td>
  2938	.         </tr>
  2939	.         <tr>
  2940	.             <td>292</td>
  2941	.             <td>sys_dup3</td>
  2942	.             <td>unsigned int oldfd</td>
  2943	.             <td>unsigned int newfd</td>
  2944	.             <td>int flags</td>
  2945	.             <td></td>
  2946	.             <td></td>
  2947	.             <td></td>
  2948	.         </tr>
  2949	.         <tr>
  2950	.             <td>293</td>
  2951	.             <td>sys_pipe2</td>
  2952	.             <td>int *filedes</td>
  2953	.             <td>int flags</td>
  2954	.             <td></td>
  2955	.             <td></td>
  2956	.             <td></td>
  2957	.             <td></td>
  2958	.         </tr>
  2959	.         <tr>
  2960	.             <td>294</td>
  2961	.             <td>sys_inotify_init1</td>
  2962	.             <td>int flags</td>
  2963	.             <td></td>
  2964	.             <td></td>
  2965	.             <td></td>
  2966	.             <td></td>
  2967	.             <td></td>
  2968	.         </tr>
  2969	.         <tr>
  2970	.             <td>295</td>
  2971	.             <td>sys_preadv</td>
  2972	.             <td>unsigned long fd</td>
  2973	.             <td>const struct iovec *vec</td>
  2974	.             <td>unsigned long vlen</td>
  2975	.             <td>unsigned long pos_l</td>
  2976	.             <td>unsigned long pos_h</td>
  2977	.             <td></td>
  2978	.         </tr>
  2979	.         <tr>
  2980	.             <td>296</td>
  2981	.             <td>sys_pwritev</td>
  2982	.             <td>unsigned long fd</td>
  2983	.             <td>const struct iovec *vec</td>
  2984	.             <td>unsigned long vlen</td>
  2985	.             <td>unsigned long pos_l</td>
  2986	.             <td>unsigned long pos_h</td>
  2987	.             <td></td>
  2988	.         </tr>
  2989	.         <tr>
  2990	.             <td>297</td>
  2991	.             <td>sys_rt_tgsigqueueinfo</td>
  2992	.             <td>pid_t tgid</td>
  2993	.             <td>pid_t pid</td>
  2994	.             <td>int sig</td>
  2995	.             <td>siginfo_t *uinfo</td>
  2996	.             <td></td>
  2997	.             <td></td>
  2998	.         </tr>
  2999	.         <tr>
  3000	.             <td>298</td>
  3001	.             <td>sys_perf_event_open</td>
  3002	.             <td>struct perf_event_attr *attr_uptr</td>
  3003	.             <td>pid_t pid</td>
  3004	.             <td>int cpu</td>
  3005	.             <td>int group_fd</td>
  3006	.             <td>unsigned long flags</td>
  3007	.             <td></td>
  3008	.         </tr>
  3009	.         <tr>
  3010	.             <td>299</td>
  3011	.             <td>sys_recvmmsg</td>
  3012	.             <td>int fd</td>
  3013	.             <td>struct msghdr *mmsg</td>
  3014	.             <td>unsigned int vlen</td>
  3015	.             <td>unsigned int flags</td>
  3016	.             <td>struct timespec *timeout</td>
  3017	.             <td></td>
  3018	.         </tr>
  3019	.         <tr>
  3020	.             <td>300</td>
  3021	.             <td>sys_fanotify_init</td>
  3022	.             <td>unsigned int flags</td>
  3023	.             <td>unsigned int event_f_flags</td>
  3024	.             <td></td>
  3025	.             <td></td>
  3026	.             <td></td>
  3027	.             <td></td>
  3028	.         </tr>
  3029	.         <tr>
  3030	.             <td>301</td>
  3031	.             <td>sys_fanotify_mark</td>
  3032	.             <td>long fanotify_fd</td>
  3033	.             <td>long flags</td>
  3034	.             <td>__u64 mask</td>
  3035	.             <td>long dfd</td>
  3036	.             <td>long pathname</td>
  3037	.             <td></td>
  3038	.         </tr>
  3039	.         <tr>
  3040	.             <td>302</td>
  3041	.             <td>sys_prlimit64</td>
  3042	.             <td>pid_t pid</td>
  3043	.             <td>unsigned int resource</td>
  3044	.             <td>const struct rlimit64 *new_rlim</td>
  3045	.             <td>struct rlimit64 *old_rlim</td>
  3046	.             <td></td>
  3047	.             <td></td>
  3048	.         </tr>
  3049	.         <tr>
  3050	.             <td>303</td>
  3051	.             <td>sys_name_to_handle_at</td>
  3052	.             <td>int dfd</td>
  3053	.             <td>const char *name</td>
  3054	.             <td>struct file_handle *handle</td>
  3055	.             <td>int *mnt_id</td>
  3056	.             <td>int flag</td>
  3057	.             <td></td>
  3058	.         </tr>
  3059	.         <tr>
  3060	.             <td>304</td>
  3061	.             <td>sys_open_by_handle_at</td>
  3062	.             <td>int dfd</td>
  3063	.             <td>const char *name</td>
  3064	.             <td>struct file_handle *handle</td>
  3065	.             <td>int *mnt_id</td>
  3066	.             <td>int flags</td>
  3067	.             <td></td>
  3068	.         </tr>
  3069	.         <tr>
  3070	.             <td>305</td>
  3071	.             <td>sys_clock_adjtime</td>
  3072	.             <td>clockid_t which_clock</td>
  3073	.             <td>struct timex *tx</td>
  3074	.             <td></td>
  3075	.             <td></td>
  3076	.             <td></td>
  3077	.             <td></td>
  3078	.         </tr>
  3079	.         <tr>
  3080	.             <td>306</td>
  3081	.             <td>sys_syncfs</td>
  3082	.             <td>int fd</td>
  3083	.             <td></td>
  3084	.             <td></td>
  3085	.             <td></td>
  3086	.             <td></td>
  3087	.             <td></td>
  3088	.         </tr>
  3089	.         <tr>
  3090	.             <td>307</td>
  3091	.             <td>sys_sendmmsg</td>
  3092	.             <td>int fd</td>
  3093	.             <td>struct mmsghdr *mmsg</td>
  3094	.             <td>unsigned int vlen</td>
  3095	.             <td>unsigned int flags</td>
  3096	.             <td></td>
  3097	.             <td></td>
  3098	.         </tr>
  3099	.         <tr>
  3100	.             <td>308</td>
  3101	.             <td>sys_setns</td>
  3102	.             <td>int fd</td>
  3103	.             <td>int nstype</td>
  3104	.             <td></td>
  3105	.             <td></td>
  3106	.             <td></td>
  3107	.             <td></td>
  3108	.         </tr>
  3109	.         <tr>
  3110	.             <td>309</td>
  3111	.             <td>sys_getcpu</td>
  3112	.             <td>unsigned *cpup</td>
  3113	.             <td>unsigned *nodep</td>
  3114	.             <td>struct getcpu_cache *unused</td>
  3115	.             <td></td>
  3116	.             <td></td>
  3117	.             <td></td>
  3118	.         </tr>
  3119	.         <tr>
  3120	.             <td>310</td>
  3121	.             <td>sys_process_vm_readv</td>
  3122	.             <td>pid_t pid</td>
  3123	.             <td>const struct iovec *lvec</td>
  3124	.             <td>unsigned long liovcnt</td>
  3125	.             <td>const struct iovec *rvec</td>
  3126	.             <td>unsigned long riovcnt</td>
  3127	.             <td>unsigned long flags</td>
  3128	.         </tr>
  3129	.         <tr>
  3130	.             <td>311</td>
  3131	.             <td>sys_process_vm_writev</td>
  3132	.             <td>pid_t pid</td>
  3133	.             <td>const struct iovec *lvec</td>
  3134	.             <td>unsigned long liovcnt</td>
  3135	.             <td>const struct iovcc *rvec</td>
  3136	.             <td>unsigned long riovcnt</td>
  3137	.             <td>unsigned long flags</td>
  3138	.         </tr>
  3139	.         <tr>
  3140	.             <td>312</td>
  3141	.             <td>sys_kcmp</td>
  3142	.             <td>pid_t pid1</td>
  3143	.             <td>pid_t pid2</td>
  3144	.             <td>int type</td>
  3145	.             <td>unsigned long idx1</td>
  3146	.             <td>unsigned long idx2</td>
  3147	.             <td></td>
  3148	.         </tr>
  3149	.         <tr>
  3150	.             <td>313</td>
  3151	.             <td>sys_finit_module</td>
  3152	.             <td>int fd</td>
  3153	.             <td>const char __user *uargs</td>
  3154	.             <td>int flags</td>
  3155	.             <td></td>
  3156	.             <td></td>
  3157	.             <td></td>
  3158	.         </tr>
  3159	.         <tr>
  3160	.             <td>314</td>
  3161	.             <td>sys_sched_setattr</td>
  3162	.             <td>pid_t pid</td>
  3163	.             <td>struct sched_attr __user *attr</td>
  3164	.             <td>unsigned int flags</td>
  3165	.             <td></td>
  3166	.             <td></td>
  3167	.             <td></td>
  3168	.         </tr>
  3169	.         <tr>
  3170	.             <td>315</td>
  3171	.             <td>sys_sched_getattr</td>
  3172	.             <td>pid_t pid</td>
  3173	.             <td>struct sched_attr __user *attr</td>
  3174	.             <td>unsigned int size</td>
  3175	.             <td>unsigned int flags</td>
  3176	.             <td></td>
  3177	.             <td></td>
  3178	.         </tr>
  3179	.         <tr>
  3180	.             <td>316</td>
  3181	.             <td>sys_renameat2</td>
  3182	.             <td>int olddfd</td>
  3183	.             <td>const char __user *oldname</td>
  3184	.             <td>int newdfd</td>
  3185	.             <td>const char __user *newname</td>
  3186	.             <td>unsigned int flags</td>
  3187	.             <td></td>
  3188	.         </tr>
  3189	.         <tr>
  3190	.             <td>317</td>
  3191	.             <td>sys_seccomp</td>
  3192	.             <td>unsigned int op</td>
  3193	.             <td>unsigned int flags</td>
  3194	.             <td>const char __user *uargs</td>
  3195	.             <td></td>
  3196	.             <td></td>
  3197	.             <td></td>
  3198	.         </tr>
  3199	.         <tr>
  3200	.             <td>318</td>
  3201	.             <td>sys_getrandom</td>
  3202	.             <td>char __user *buf</td>
  3203	.             <td>size_t count</td>
  3204	.             <td>unsigned int flags</td>
  3205	.             <td></td>
  3206	.             <td></td>
  3207	.             <td></td>
  3208	.         </tr>
  3209	.         <tr>
  3210	.             <td>319</td>
  3211	.             <td>sys_memfd_create</td>
  3212	.             <td>const char __user *uname_ptr</td>
  3213	.             <td>unsigned
  3214	.                 int flags</td>
  3215	.             <td></td>
  3216	.             <td></td>
  3217	.             <td></td>
  3218	.             <td></td>
  3219	.         </tr>
  3220	.         <tr>
  3221	.             <td>320</td>
  3222	.             <td>sys_kexec_file_load</td>
  3223	.             <td>int kernel_fd</td>
  3224	.             <td>int initrd_fd</td>
  3225	.             <td>unsigned long cmdline_len</td>
  3226	.             <td>const char __user *cmdline_ptr</td>
  3227	.             <td>unsigned long flags</td>
  3228	.             <td></td>
  3229	.         </tr>
  3230	.         <tr>
  3231	.             <td>321</td>
  3232	.             <td>sys_bpf</td>
  3233	.             <td>int cmd</td>
  3234	.             <td>union bpf_attr *attr</td>
  3235	.             <td>unsigned int size</td>
  3236	.             <td></td>
  3237	.             <td></td>
  3238	.             <td></td>
  3239	.         </tr>
  3240	.         <tr>
  3241	.             <td>322</td>
  3242	.             <td>stub_execveat</td>
  3243	.             <td>int dfd</td>
  3244	.             <td>const char __user *filename</td>
  3245	.             <td>const char __user *const __user *argv</td>
  3246	.             <td>const char __user *const __user *envp</td>
  3247	.             <td>int flags</td>
  3248	.             <td></td>
  3249	.         </tr>
  3250	.         <tr>
  3251	.             <td>323</td>
  3252	.             <td>userfaultfd</td>
  3253	.             <td>int flags</td>
  3254	.             <td></td>
  3255	.             <td></td>
  3256	.             <td></td>
  3257	.             <td></td>
  3258	.             <td></td>
  3259	.         </tr>
  3260	.         <tr>
  3261	.             <td>324</td>
  3262	.             <td>membarrier</td>
  3263	.             <td>int cmd</td>
  3264	.             <td>int flags</td>
  3265	.             <td></td>
  3266	.             <td></td>
  3267	.             <td></td>
  3268	.             <td></td>
  3269	.         </tr>
  3270	.         <tr>
  3271	.             <td>325</td>
  3272	.             <td>mlock2</td>
  3273	.             <td>unsigned long start</td>
  3274	.             <td>size_t len</td>
  3275	.             <td>int flags</td>
  3276	.             <td></td>
  3277	.             <td></td>
  3278	.             <td></td>
  3279	.         </tr>
  3280	.         <tr>
  3281	.             <td>326</td>
  3282	.             <td>copy_file_range</td>
  3283	.             <td>int fd_in</td>
  3284	.             <td>loff_t __user *off_in</td>
  3285	.             <td>int fd_out</td>
  3286	.             <td>loff_t __user * off_out</td>
  3287	.             <td>size_t len</td>
  3288	.             <td>unsigned int flags</td>
  3289	.         </tr>
  3290	.         <tr>
  3291	.             <td>327</td>
  3292	.             <td>preadv2</td>
  3293	.             <td>unsigned long fd</td>
  3294	.             <td>const struct iovec __user *vec</td>
  3295	.             <td>unsigned long vlen</td>
  3296	.             <td>unsigned long pos_l</td>
  3297	.             <td>unsigned long pos_h</td>
  3298	.             <td>int flags</td>
  3299	.         </tr>
  3300	.         <tr>
  3301	.             <td>328</td>
  3302	.             <td>pwritev2</td>
  3303	.             <td>unsigned long fd</td>
  3304	.             <td>const struct iovec __user *vec</td>
  3305	.             <td>unsigned long vlen</td>
  3306	.             <td>unsigned long pos_l</td>
  3307	.             <td>unsigned long pos_h</td>
  3308	.             <td>int flags</td>
  3309	.         </tr>
  3310	. 
  3311	. 
  3312	.     </tbody>
  3313	. </table>
  3314	. </body>
  3315	. </html>
FILE: END: doc/syscalls.html
FILE: START: etc/asmflags
HASH: MD5: d41d8cd98f00b204e9800998ecf8427e
FILE: END: etc/asmflags
FILE: START: etc/cppflags
HASH: MD5: af814f169fff18c6213b04971037ccb9
     1	. -nostdinc++
     2	. -Iinc
     3	. -g
     4	. -ffreestanding
     5	. -fno-exceptions
     6	. -ggdb3 -O0
     7	. -fno-stack-protector
FILE: END: etc/cppflags
FILE: START: etc/cxxflags
HASH: MD5: bbc77e61399b7ecbaa3b39d2b482aaaf
     1	. -ffreestanding
     2	. -fno-exceptions
     3	. -ggdb3 -O0
     4	. -fno-stack-protector
FILE: END: etc/cxxflags
FILE: START: etc/ld_flags
HASH: MD5: c1912cacde4961b8cc1c17f15c9e181a
     1	. -Llib
     2	. -O0
     3	. -Wl,--verbose
     4	. -ffreestanding
     5	. -fno-exceptions
     6	. -fno-stack-protector
     7	. -ggdb3
     8	. -nodefaultlibs
     9	. -nolibc
    10	. -nostartfiles
    11	. -nostdlib
    12	. -static
FILE: END: etc/ld_flags
FILE: START: inc/assert.h
HASH: MD5: d41d8cd98f00b204e9800998ecf8427e
FILE: END: inc/assert.h
FILE: START: inc/buf.hh
HASH: MD5: a171fb867f0459530e2c5289872d72ae
     1	. #ifndef buf_hh
     2	. #define buf_hh buf_hh
     3	. 
     4	. #include <dbg.hh>
     5	. #include <fmt.hh>
     6	. 
     7	. namespace buf_ns
     8	. {
     9	.   using namespace fmt;
    10	.   struct buf_t {
    11	.     int fd;
    12	.     buf_t(int fd=1)
    13	.       :fd(fd)
    14	.     {
    15	.     };
    16	.     ssize_t __write(const char *text, ssize_t len)
    17	.     {
    18	.       xassert(len>=0);
    19	.       sys::write(fd,text,len);
    20	.       return 0;
    21	.     };
    22	.     ssize_t write(const char *arg)
    23	.     {
    24	.       if(arg==0)
    25	.         arg="(null)";
    26	.       return __write(arg,strlen(arg));
    27	.     };
    28	.     ssize_t write(char &arg)
    29	.     {
    30	.       return __write(&arg,1);
    31	.     };
    32	.     ssize_t write(int arg)
    33	.     {
    34	.       if(arg<0)
    35	.         return write(true,arg);
    36	.       else
    37	.         return write(false,arg);
    38	.     };
    39	.     ssize_t write(void *ptr)
    40	.     {
    41	.       struct {
    42	.         char buf[1023];
    43	.         char end[1];
    44	.       } dat;
    45	.       char *pos=fmt_ptr(ptr,dat.buf,dat.end);
    46	.       write(pos);
    47	.       return pos-dat.buf;
    48	.     };
    49	.     ssize_t write(bool neg, unsigned long val)
    50	.     {
    51	.       struct {
    52	.         char buf[1023];
    53	.         char end[1];
    54	.       } dat;
    55	.       char *pos=fmt_dec(neg,val,dat.buf,dat.end);
    56	.       write(pos);
    57	.       return pos-dat.buf;
    58	.     };
    59	.     ssize_t println()
    60	.     {
    61	.       return write("\n");
    62	.     };
    63	.     template<typename arg0_t, typename ...argn_t>
    64	.       ssize_t println(arg0_t arg, argn_t... tail)
    65	.       {
    66	.         return print(arg,tail...,"\n");
    67	.       };
    68	.     ssize_t print()
    69	.     {
    70	.       return 0;
    71	.     };
    72	.     template<typename arg0_t, typename ...argn_t>
    73	.       ssize_t print(arg0_t arg, argn_t... tail)
    74	.       {
    75	.         return write(arg)+print(tail...);
    76	.       };
    77	.   };
    78	. 
    79	. };
    80	. #endif
FILE: END: inc/buf.hh
FILE: START: inc/c_str.hh
HASH: MD5: 15d523dbf661b75b5848044d922517c0
     1	. #ifndef c_str_hh
     2	. #define c_str_hh c_str_hh
     3	. 
     4	. #include <syscall.hh>
     5	. 
     6	. class c_str {
     7	.   struct body_t {
     8	.     char *beg;
     9	.     char *end;
    10	.     body_t(char *beg, char*end)
    11	.       :beg(beg),end(end)
    12	.     {
    13	.     };
    14	.   } body;
    15	.   static const char null_str[1];
    16	.   public:
    17	.   c_str()
    18	.     : body((char*)null_str,(char*)null_str)
    19	.   {
    20	.   };
    21	.   c_str(const char *b, const char *e = 0)
    22	.     : body((char*)b,(char*)e)
    23	.   {
    24	.     if(body.end)
    25	.       return;
    26	.     body.end=body.beg;
    27	.     while(*body.end)
    28	.       ++body.end;
    29	.   };
    30	.   c_str(char *b, char *e = 0)
    31	.     : body(b,e)
    32	.   {
    33	.     if(body.end)
    34	.       return;
    35	.     body.end=body.beg;
    36	.     while(*body.end)
    37	.       ++body.end;
    38	.   };
    39	.   c_str(const char *b, size_t l)
    40	.     : body((char*)b,(char*)(b+l))
    41	.   {
    42	.   };
    43	.   c_str(char *b, size_t l)
    44	.     : body(b,b+l)
    45	.   {
    46	.   };
    47	.   c_str(const c_str &lhs)
    48	.     : body(lhs.body.beg,lhs.body.end)
    49	.   {
    50	.   };
    51	.   size_t len() const
    52	.   {
    53	.     return body.end-body.beg;
    54	.   };
    55	.   size_t size() const {
    56	.     return body.end-body.beg;
    57	.   };
    58	.   char operator[](size_t pos) const
    59	.   {
    60	.     return body.beg[pos];
    61	.   };
    62	.   operator bool() const
    63	.   {
    64	.     return body.beg<body.end;
    65	.   }
    66	.   c_str operator++(int) 
    67	.   {
    68	.     c_str res(*this);
    69	.     if(body.beg<body.end)
    70	.       ++body.beg;
    71	.     return res;
    72	.   };
    73	.   c_str &operator++()
    74	.   {
    75	.     if(body.beg<body.end)
    76	.       ++body.beg;
    77	.     return *this;
    78	.   };
    79	.   char operator*() const {
    80	.     return *body.beg;
    81	.   };
    82	.   const char *begin() const {
    83	.     return body.beg;
    84	.   };
    85	.   char *begin() {
    86	.     return body.beg;
    87	.   };
    88	.   const char *end() const {
    89	.     return body.end;
    90	.   };
    91	.   char *end() {
    92	.     return body.end;
    93	.   };
    94	.   static int cmp(size_t lhs, size_t rhs);
    95	.   static int cmp(const c_str &lhs, const c_str &rhs);
    96	.   static const c_str colon;
    97	.   static const c_str newline;
    98	. };
    99	. #define cmp_op(x) \
   100	.   inline bool operator x(const c_str &lhs, const c_str &rhs) { \
   101	.     return c_str::cmp(lhs,rhs) x 0; \
   102	.   };
   103	. cmp_op(<);
   104	. cmp_op(>);
   105	. cmp_op(<=);
   106	. cmp_op(>=);
   107	. cmp_op(==);
   108	. cmp_op(!=);
   109	. 
   110	. inline ssize_t write(fd_t fd, const c_str &str) {
   111	.   return sys::sys_write(fd, str.begin(), str.size());
   112	. };
   113	. 
   114	. #endif
FILE: END: inc/c_str.hh
FILE: START: inc/char_traits.hh
HASH: MD5: 2ed259a762e4654de5754eb2d51aa18b
     1	. #ifndef _CHAR_TRAITS_H
     2	. #define _CHAR_TRAITS_H 1
     3	. 
     4	. 
     5	. namespace std
     6	. {
     7	.   typedef unsigned long size_t;
     8	. 
     9	.   template <typename iitr, typename oitr>
    10	.   void copy(iitr src, iitr end, oitr dst)
    11	.   {
    12	.     while(src != end)
    13	.       *dst++= *src++;
    14	.   };
    15	.   template <typename _CharT>
    16	.   struct char_traits
    17	.   {
    18	.     typedef _CharT                                   char_type;
    19	.     typedef typename _Char_types<_CharT>::int_type   int_type;
    20	.     typedef typename _Char_types<_CharT>::pos_type   pos_type;
    21	.     typedef typename _Char_types<_CharT>::off_type   off_type;
    22	.     typedef typename _Char_types<_CharT>::state_type state_type;
    23	. 
    24	.     static void assign(char_type& __c1, const char_type& __c2)
    25	.     {
    26	.       __c1= __c2;
    27	.     }
    28	. 
    29	.     static bool eq(const char_type& __c1, const char_type& __c2)
    30	.     {
    31	.       return __c1 == __c2;
    32	.     }
    33	. 
    34	.     static bool lt(const char_type& __c1, const char_type& __c2)
    35	.     {
    36	.       return __c1 < __c2;
    37	.     }
    38	. 
    39	.     static int compare(const char_type* s1,
    40	.                        const char_type* s2,
    41	.                        std::size_t      n)
    42	.     {
    43	.       for(auto i(n - n); i < n; i++)
    44	.       {
    45	.         auto d(*s1
    46	.       };
    47	.     };
    48	. 
    49	.     static std::size_t length(const char_type* __s);
    50	. 
    51	.     static const char_type* find(const char_type* __s,
    52	.                                  std::size_t      __n,
    53	.                                  const char_type& __a);
    54	. 
    55	.     static char_type* move(char_type*       __s1,
    56	.                            const char_type* __s2,
    57	.                            std::size_t      __n);
    58	. 
    59	.     static char_type* copy(char_type*       __s1,
    60	.                            const char_type* __s2,
    61	.                            std::size_t      __n);
    62	. 
    63	.     static char_type* assign(char_type*  __s,
    64	.                              std::size_t __n,
    65	.                              char_type   __a);
    66	. 
    67	.     static char_type to_char_type(const int_type& __c)
    68	.     {
    69	.       return static_cast<char_type>(__c);
    70	.     }
    71	. 
    72	.     static int_type to_int_type(const char_type& __c)
    73	.     {
    74	.       return static_cast<int_type>(__c);
    75	.     }
    76	. 
    77	.     static bool eq_int_type(const int_type& __c1, const int_type& __c2)
    78	.     {
    79	.       return __c1 == __c2;
    80	.     }
    81	. 
    82	.     static int_type eof()
    83	.     {
    84	.       return static_cast<int_type>(-1);
    85	.     }
    86	. 
    87	.     static int_type not_eof(const int_type& __c)
    88	.     {
    89	.       return !eq_int_type(__c, eof()) ? __c : to_int_type(char_type());
    90	.     }
    91	.   };
    92	. 
    93	.   template <typename _CharT>
    94	.   int char_traits<_CharT>::compare(const char_type* __s1,
    95	.                                    const char_type* __s2,
    96	.                                    std::size_t      __n)
    97	.   {
    98	.     for(std::size_t __i= 0; __i < __n; ++__i)
    99	.       if(lt(__s1[__i], __s2[__i]))
   100	.         return -1;
   101	.       else if(lt(__s2[__i], __s1[__i]))
   102	.         return 1;
   103	.     return 0;
   104	.   }
   105	. 
   106	.   template <typename _CharT>
   107	.   std::size_t char_traits<_CharT>::length(const char_type* __p)
   108	.   {
   109	.     std::size_t __i= 0;
   110	.     while(!eq(__p[__i], char_type()))
   111	.       ++__i;
   112	.     return __i;
   113	.   }
   114	. 
   115	.   template <typename _CharT>
   116	.   const typename char_traits<_CharT>::char_type* char_traits<_CharT>::find(
   117	.            const char_type* __s, std::size_t __n, const char_type& __a)
   118	.   {
   119	.     for(std::size_t __i= 0; __i < __n; ++__i)
   120	.       if(eq(__s[__i], __a))
   121	.         return __s + __i;
   122	.     return 0;
   123	.   }
   124	. 
   125	.   template <typename _CharT>
   126	.   typename char_traits<_CharT>::char_type* char_traits<_CharT>::move(
   127	.            char_type* __s1, const char_type* __s2, std::size_t __n)
   128	.   {
   129	.     if(__n == 0)
   130	.       return __s1;
   131	.     return static_cast<_CharT*>(
   132	.              __builtin_memmove(__s1, __s2, __n * sizeof(char_type)));
   133	.   }
   134	. 
   135	.   template <typename _CharT>
   136	.   typename char_traits<_CharT>::char_type* char_traits<_CharT>::copy(
   137	.            char_type* __s1, const char_type* __s2, std::size_t __n)
   138	.   {
   139	.     // NB: Inline std::copy so no recursive dependencies.
   140	.     std::copy(__s2, __s2 + __n, __s1);
   141	.     return __s1;
   142	.   }
   143	. 
   144	.   template <typename itr_t, typename val_t>
   145	.   void fill(itr_t dst, itr_t end, const val_t& val)
   146	.   {
   147	.     while(dst != end)
   148	.       *dst++= val;
   149	.   };
   150	.   template <typename itr_t, typename val_t>
   151	.   void fill_n(itr_t dst, size_t num, const val_t& val)
   152	.   {
   153	.     fill(dst, dst + num, val);
   154	.   };
   155	.   template <typename _CharT>
   156	.   typename char_traits<_CharT>::char_type* char_traits<_CharT>::assign(
   157	.            char_type* __s, std::size_t __n, char_type __a)
   158	.   {
   159	.     // NB: Inline std::fill_n so no recursive dependencies.
   160	.     std::fill_n(__s, __n, __a);
   161	.     return __s;
   162	.   }
   163	. 
   164	. } // namespace std
   165	. 
   166	. //   namespace std _GLIBCXX_VISIBILITY(default)
   167	. //   {
   168	. //     _GLIBCXX_BEGIN_NAMESPACE_VERSION
   169	. //
   170	. //
   171	. //
   172	. //     /// 21.1.3.1  char_traits specializations
   173	. //     template <>
   174	. //     struct char_traits<char>
   175	. //     {
   176	. //       typedef char      char_type;
   177	. //       typedef int       int_type;
   178	. //       typedef streampos pos_type;
   179	. //       typedef streamoff off_type;
   180	. //       typedef mbstate_t state_type;
   181	. //
   182	. //       static _GLIBCXX17_CONSTEXPR void assign(
   183	. //                char_type& __c1, const char_type& __c2) _GLIBCXX_NOEXCEPT
   184	. //       {
   185	. //         __c1= __c2;
   186	. //       }
   187	. //
   188	. //       static  bool eq(const char_type& __c1,
   189	. //                                         const char_type& __c2)
   190	. //                _GLIBCXX_NOEXCEPT
   191	. //       {
   192	. //         return __c1 == __c2;
   193	. //       }
   194	. //
   195	. //       static  bool lt(const char_type& __c1,
   196	. //                                         const char_type& __c2)
   197	. //                _GLIBCXX_NOEXCEPT
   198	. //       {
   199	. //         // LWG 467.
   200	. //         return (static_cast<unsigned char>(__c1) <
   201	. //                 static_cast<unsigned char>(__c2));
   202	. //       }
   203	. //
   204	. //       static _GLIBCXX17_CONSTEXPR int compare(const char_type* __s1,
   205	. //                                               const char_type* __s2,
   206	. //                                               size_t           __n)
   207	. //       {
   208	. //   #if __cplusplus > 201402
   209	. //         if(__builtin_constant_p(__n) && __constant_char_array_p(__s1,
   210	. //         __n) &&
   211	. //            __constant_char_array_p(__s2, __n))
   212	. //           return __gnu_cxx::char_traits<char_type>::compare(__s1, __s2,
   213	. //           __n);
   214	. //   #endif
   215	. //         if(__n == 0)
   216	. //           return 0;
   217	. //         return __builtin_memcmp(__s1, __s2, __n);
   218	. //       }
   219	. //
   220	. //       static _GLIBCXX17_CONSTEXPR size_t length(const char_type* __s)
   221	. //       {
   222	. //   #if __cplusplus > 201402
   223	. //         if(__constant_string_p(__s))
   224	. //           return __gnu_cxx::char_traits<char_type>::length(__s);
   225	. //   #endif
   226	. //         return __builtin_strlen(__s);
   227	. //       }
   228	. //
   229	. //       static _GLIBCXX17_CONSTEXPR const char_type* find(const char_type*
   230	. //       __s,
   231	. //                                                         size_t __n,
   232	. //                                                         const char_type&
   233	. //                                                         __a)
   234	. //       {
   235	. //   #if __cplusplus > 201402
   236	. //         if(__builtin_constant_p(__n) && __builtin_constant_p(__a) &&
   237	. //            __constant_char_array_p(__s, __n))
   238	. //           return __gnu_cxx::char_traits<char_type>::find(__s, __n, __a);
   239	. //   #endif
   240	. //         if(__n == 0)
   241	. //           return 0;
   242	. //         return static_cast<const char_type*>(
   243	. //                  __builtin_memchr(__s, __a, __n));
   244	. //       }
   245	. //
   246	. //       static char_type* move(char_type*       __s1,
   247	. //                              const char_type* __s2,
   248	. //                              size_t           __n)
   249	. //       {
   250	. //         if(__n == 0)
   251	. //           return __s1;
   252	. //         return static_cast<char_type*>(__builtin_memmove(__s1, __s2,
   253	. //         __n));
   254	. //       }
   255	. //
   256	. //       static char_type* copy(char_type*       __s1,
   257	. //                              const char_type* __s2,
   258	. //                              size_t           __n)
   259	. //       {
   260	. //         if(__n == 0)
   261	. //           return __s1;
   262	. //         return static_cast<char_type*>(__builtin_memcpy(__s1, __s2,
   263	. //         __n));
   264	. //       }
   265	. //
   266	. //       static char_type* assign(char_type* __s, size_t __n, char_type
   267	. //       __a)
   268	. //       {
   269	. //         if(__n == 0)
   270	. //           return __s;
   271	. //         return static_cast<char_type*>(__builtin_memset(__s, __a, __n));
   272	. //       }
   273	. //
   274	. //       static  char_type to_char_type(const int_type& __c)
   275	. //                _GLIBCXX_NOEXCEPT
   276	. //       {
   277	. //         return static_cast<char_type>(__c);
   278	. //       }
   279	. //
   280	. //       // To keep both the byte 0xff and the eof symbol 0xffffffff
   281	. //       // from ending up as 0xffffffff.
   282	. //       static  int_type to_int_type(const char_type& __c)
   283	. //                _GLIBCXX_NOEXCEPT
   284	. //       {
   285	. //         return static_cast<int_type>(static_cast<unsigned char>(__c));
   286	. //       }
   287	. //
   288	. //       static  bool eq_int_type(
   289	. //                const int_type& __c1, const int_type& __c2)
   290	. //                _GLIBCXX_NOEXCEPT
   291	. //       {
   292	. //         return __c1 == __c2;
   293	. //       }
   294	. //
   295	. //       static  int_type eof() _GLIBCXX_NOEXCEPT
   296	. //       {
   297	. //         return static_cast<int_type>(_GLIBCXX_STDIO_EOF);
   298	. //       }
   299	. //
   300	. //       static  int_type not_eof(const int_type& __c)
   301	. //                _GLIBCXX_NOEXCEPT
   302	. //       {
   303	. //         return (__c == eof()) ? 0 : __c;
   304	. //       }
   305	. //     };
   306	. //
   307	. //
   308	. //   #ifdef _GLIBCXX_USE_WCHAR_T
   309	. //     /// 21.1.3.2  char_traits specializations
   310	. //     template <>
   311	. //     struct char_traits<wchar_t>
   312	. //     {
   313	. //       typedef wchar_t    char_type;
   314	. //       typedef wint_t     int_type;
   315	. //       typedef streamoff  off_type;
   316	. //       typedef wstreampos pos_type;
   317	. //       typedef mbstate_t  state_type;
   318	. //
   319	. //       static _GLIBCXX17_CONSTEXPR void assign(
   320	. //                char_type& __c1, const char_type& __c2) _GLIBCXX_NOEXCEPT
   321	. //       {
   322	. //         __c1= __c2;
   323	. //       }
   324	. //
   325	. //       static  bool eq(const char_type& __c1,
   326	. //                                         const char_type& __c2)
   327	. //                _GLIBCXX_NOEXCEPT
   328	. //       {
   329	. //         return __c1 == __c2;
   330	. //       }
   331	. //
   332	. //       static  bool lt(const char_type& __c1,
   333	. //                                         const char_type& __c2)
   334	. //                _GLIBCXX_NOEXCEPT
   335	. //       {
   336	. //         return __c1 < __c2;
   337	. //       }
   338	. //
   339	. //       static _GLIBCXX17_CONSTEXPR int compare(const char_type* __s1,
   340	. //                                               const char_type* __s2,
   341	. //                                               size_t           __n)
   342	. //       {
   343	. //   #if __cplusplus > 201402
   344	. //         if(__builtin_constant_p(__n) && __constant_char_array_p(__s1,
   345	. //         __n) &&
   346	. //            __constant_char_array_p(__s2, __n))
   347	. //           return __gnu_cxx::char_traits<char_type>::compare(__s1, __s2,
   348	. //           __n);
   349	. //   #endif
   350	. //         if(__n == 0)
   351	. //           return 0;
   352	. //         else
   353	. //           return wmemcmp(__s1, __s2, __n);
   354	. //       }
   355	. //
   356	. //       static _GLIBCXX17_CONSTEXPR size_t length(const char_type* __s)
   357	. //       {
   358	. //   #if __cplusplus > 201402
   359	. //         if(__constant_string_p(__s))
   360	. //           return __gnu_cxx::char_traits<char_type>::length(__s);
   361	. //         else
   362	. //   #endif
   363	. //           return wcslen(__s);
   364	. //       }
   365	. //
   366	. //       static _GLIBCXX17_CONSTEXPR const char_type* find(const char_type*
   367	. //       __s,
   368	. //                                                         size_t __n,
   369	. //                                                         const char_type&
   370	. //                                                         __a)
   371	. //       {
   372	. //   #if __cplusplus > 201402
   373	. //         if(__builtin_constant_p(__n) && __builtin_constant_p(__a) &&
   374	. //            __constant_char_array_p(__s, __n))
   375	. //           return __gnu_cxx::char_traits<char_type>::find(__s, __n, __a);
   376	. //   #endif
   377	. //         if(__n == 0)
   378	. //           return 0;
   379	. //         else
   380	. //           return wmemchr(__s, __a, __n);
   381	. //       }
   382	. //
   383	. //       static char_type* move(char_type*       __s1,
   384	. //                              const char_type* __s2,
   385	. //                              size_t           __n)
   386	. //       {
   387	. //         if(__n == 0)
   388	. //           return __s1;
   389	. //         return wmemmove(__s1, __s2, __n);
   390	. //       }
   391	. //
   392	. //       static char_type* copy(char_type*       __s1,
   393	. //                              const char_type* __s2,
   394	. //                              size_t           __n)
   395	. //       {
   396	. //         if(__n == 0)
   397	. //           return __s1;
   398	. //         return wmemcpy(__s1, __s2, __n);
   399	. //       }
   400	. //
   401	. //       static char_type* assign(char_type* __s, size_t __n, char_type
   402	. //       __a)
   403	. //       {
   404	. //         if(__n == 0)
   405	. //           return __s;
   406	. //         return wmemset(__s, __a, __n);
   407	. //       }
   408	. //
   409	. //       static char_type to_char_type(const int_type& __c)
   410	. //       {
   411	. //         return char_type(__c);
   412	. //       }
   413	. //
   414	. //       static int_type to_int_type(const char_type& __c)
   415	. //       {
   416	. //         return int_type(__c);
   417	. //       }
   418	. //
   419	. //       static bool eq_int_type(const int_type& __c1, const int_type&
   420	. //       __c2)
   421	. //       {
   422	. //         return __c1 == __c2;
   423	. //       }
   424	. //
   425	. //       static int_type eof()
   426	. //       {
   427	. //         return static_cast<int_type>(WEOF);
   428	. //       }
   429	. //
   430	. //       static int_type not_eof(const int_type& __c)
   431	. //       {
   432	. //         return eq_int_type(__c, eof()) ? 0 : __c;
   433	. //       }
   434	. //     };
   435	. //   #endif //_
   436	. //
   437	. //   } // namespace )
   438	. 
   439	. #endif // _CHAR_TRAITS_H
FILE: END: inc/char_traits.hh
FILE: START: inc/cxxabi.hh
HASH: MD5: eb42b100068244ab160e8dbb7797b67e
     1	. // ABI Support -*- C++ -*-
     2	. 
     3	. // Copyright (C) 2000-2019 Free Software Foundation, Inc.
     4	. //
     5	. // This file is part of GCC.
     6	. //
     7	. // GCC is free software; you can redistribute it and/or modify
     8	. // it under the terms of the GNU General Public License as published by
     9	. // the Free Software Foundation; either version 3, or (at your option)
    10	. // any later version.
    11	. //
    12	. // GCC is distributed in the hope that it will be useful,
    13	. // but WITHOUT ANY WARRANTY; without even the implied warranty of
    14	. // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    15	. // GNU General Public License for more details.
    16	. //
    17	. // Under Section 7 of GPL version 3, you are granted additional
    18	. // permissions described in the GCC Runtime Library Exception, version
    19	. // 3.1, as published by the Free Software Foundation.
    20	. 
    21	. // You should have received a copy of the GNU General Public License and
    22	. // a copy of the GCC Runtime Library Exception along with this program;
    23	. // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
    24	. // <http://www.gnu.org/licenses/>.
    25	. 
    26	. // Written by Nathan Sidwell, Codesourcery LLC, <nathan@codesourcery.com>
    27	. 
    28	. /* This file declares the new abi entry points into the runtime. It is not
    29	.    normally necessary for user programs to include this header, or use the
    30	.    entry points directly. However, this header is available should that be
    31	.    needed.
    32	. 
    33	.    Some of the entry points are intended for both C and C++, thus this header
    34	.    is includable from both C and C++. Though the C++ specific parts are not
    35	.    available in C, naturally enough.  */
    36	. 
    37	. /** @file cxxabi.h
    38	.  *  The header provides an interface to the C++ ABI.
    39	.  */
    40	. 
    41	. #ifndef _CXXABI_H
    42	. #define _CXXABI_H 1
    43	. 
    44	. #pragma GCC system_header
    45	. 
    46	. #pragma GCC visibility push(default)
    47	. #include <syscall.hh>
    48	. 
    49	. typedef int __guard __attribute__((mode (__DI__)));
    50	. //#include <stddef.h>
    51	. //#include <bits/c++config.h>
    52	. //#include <bits/cxxabi_tweaks.h>
    53	. //#include <bits/cxxabi_forced.h>
    54	. //#include <bits/cxxabi_init_exception.h>
    55	. 
    56	. #ifdef __cplusplus
    57	. namespace __cxxabiv1
    58	. {
    59	.   extern "C"
    60	.   {
    61	. #endif
    62	. 
    63	.   typedef void (*__cxa_cdtor_type)(void *);
    64	. 
    65	.   // Allocate array.
    66	.   void*
    67	.   __cxa_vec_new(size_t __element_count, size_t __element_size,
    68	. 		size_t __padding_size, __cxa_cdtor_type __constructor,
    69	. 		__cxa_cdtor_type __destructor);
    70	. 
    71	.   void*
    72	.   __cxa_vec_new2(size_t __element_count, size_t __element_size,
    73	. 		 size_t __padding_size, __cxa_cdtor_type __constructor,
    74	. 		 __cxa_cdtor_type __destructor, void *(*__alloc) (size_t),
    75	. 		 void (*__dealloc) (void*));
    76	. 
    77	.   void*
    78	.   __cxa_vec_new3(size_t __element_count, size_t __element_size,
    79	. 		 size_t __padding_size, __cxa_cdtor_type __constructor,
    80	. 		 __cxa_cdtor_type __destructor, void *(*__alloc) (size_t),
    81	. 		 void (*__dealloc) (void*, size_t));
    82	. 
    83	.   // Construct array.
    84	.   void
    85	.   __cxa_vec_ctor(void* __array_address, size_t __element_count,
    86	. 		 size_t __element_size, __cxa_cdtor_type __constructor,
    87	. 		 __cxa_cdtor_type __destructor);
    88	. 
    89	.   void
    90	.   __cxa_vec_cctor(void* __dest_array, void* __src_array,
    91	. 		  size_t __element_count, size_t __element_size,
    92	. 		  void (*__constructor) (void*, void*),
    93	. 		  __cxa_cdtor_type __destructor);
    94	. 
    95	.   // Destruct array.
    96	.   void
    97	.   __cxa_vec_dtor(void* __array_address, size_t __element_count,
    98	. 		 size_t __element_size, __cxa_cdtor_type __destructor);
    99	. 
   100	.   void
   101	.   __cxa_vec_cleanup(void* __array_address, size_t __element_count, size_t __s,
   102	. 		    __cxa_cdtor_type __destructor) ;
   103	. 
   104	.   // Destruct and release array.
   105	.   void
   106	.   __cxa_vec_delete(void* __array_address, size_t __element_size,
   107	. 		   size_t __padding_size, __cxa_cdtor_type __destructor);
   108	. 
   109	.   void
   110	.   __cxa_vec_delete2(void* __array_address, size_t __element_size,
   111	. 		    size_t __padding_size, __cxa_cdtor_type __destructor,
   112	. 		    void (*__dealloc) (void*));
   113	. 
   114	.   void
   115	.   __cxa_vec_delete3(void* __array_address, size_t __element_size,
   116	. 		    size_t __padding_size, __cxa_cdtor_type __destructor,
   117	. 		    void (*__dealloc) (void*, size_t));
   118	. 
   119	.   int
   120	.   __cxa_guard_acquire(__guard*);
   121	. 
   122	.   void
   123	.   __cxa_guard_release(__guard*) ;
   124	. 
   125	.   void
   126	.   __cxa_guard_abort(__guard*) ;
   127	. 
   128	.   // DSO destruction.
   129	.   int
   130	.   __cxa_atexit(void (*)(void*), void*, void*) ;
   131	. 
   132	.   int
   133	.   __cxa_finalize(void*);
   134	. 
   135	.   // TLS destruction.
   136	.   int
   137	.   __cxa_thread_atexit(void (*)(void*), void*, void *) ;
   138	. 
   139	.   // Pure virtual functions.
   140	.   void
   141	.   __cxa_pure_virtual(void) __attribute__ ((__noreturn__));
   142	. 
   143	.   void
   144	.   __cxa_deleted_virtual(void) __attribute__ ((__noreturn__));
   145	. 
   146	.   // Exception handling auxiliary.
   147	.   void 
   148	.   __cxa_bad_cast() __attribute__((__noreturn__));
   149	. 
   150	.   void 
   151	.   __cxa_bad_typeid() __attribute__((__noreturn__));
   152	. 
   153	.   void
   154	.   __cxa_throw_bad_array_new_length() __attribute__((__noreturn__));
   155	. 
   156	.   /**
   157	.    *  @brief Demangling routine.
   158	.    *  ABI-mandated entry point in the C++ runtime library for demangling.
   159	.    *
   160	.    *  @param __mangled_name A NUL-terminated character string
   161	.    *  containing the name to be demangled.
   162	.    *
   163	.    *  @param __output_buffer A region of memory, allocated with
   164	.    *  malloc, of @a *__length bytes, into which the demangled name is
   165	.    *  stored.  If @a __output_buffer is not long enough, it is
   166	.    *  expanded using realloc.  @a __output_buffer may instead be NULL;
   167	.    *  in that case, the demangled name is placed in a region of memory
   168	.    *  allocated with malloc.
   169	.    *
   170	.    *  @param __length If @a __length is non-null, the length of the
   171	.    *  buffer containing the demangled name is placed in @a *__length.
   172	.    *
   173	.    *  @param __status If @a __status is non-null, @a *__status is set to
   174	.    *  one of the following values:
   175	.    *   0: The demangling operation succeeded.
   176	.    *  -1: A memory allocation failure occurred.
   177	.    *  -2: @a mangled_name is not a valid name under the C++ ABI mangling rules.
   178	.    *  -3: One of the arguments is invalid.
   179	.    *
   180	.    *  @return A pointer to the start of the NUL-terminated demangled
   181	.    *  name, or NULL if the demangling fails.  The caller is
   182	.    *  responsible for deallocating this memory using @c free.
   183	.    *
   184	.    *  The demangling is performed using the C++ ABI mangling rules,
   185	.    *  with GNU extensions. For example, this function is used in
   186	.    *  __gnu_cxx::__verbose_terminate_handler.
   187	.    *
   188	.    *  See https://gcc.gnu.org/onlinedocs/libstdc++/manual/ext_demangling.html
   189	.    *  for other examples of use.
   190	.    *
   191	.    *  @note The same demangling functionality is available via
   192	.    *  libiberty (@c <libiberty/demangle.h> and @c libiberty.a) in GCC
   193	.    *  3.1 and later, but that requires explicit installation (@c
   194	.    *  --enable-install-libiberty) and uses a different API, although
   195	.    *  the ABI is unchanged.
   196	.    */
   197	.   char*
   198	.   __cxa_demangle(const char* __mangled_name, char* __output_buffer,
   199	. 		 size_t* __length, int* __status);
   200	. 
   201	. #ifdef __cplusplus
   202	.   }
   203	. } // namespace __cxxabiv1
   204	. #endif
   205	. 
   206	. #ifdef __cplusplus
   207	. 
   208	. #include <typeinfo.hh>
   209	. 
   210	. namespace __cxxabiv1
   211	. {
   212	.   // Type information for int, float etc.
   213	.   class __fundamental_type_info : public std::type_info
   214	.   {
   215	.   public:
   216	.     explicit
   217	.     __fundamental_type_info(const char* __n) : std::type_info(__n) { }
   218	. 
   219	.     virtual
   220	.     ~__fundamental_type_info();
   221	.   };
   222	. 
   223	.   // Type information for array objects.
   224	.   class __array_type_info : public std::type_info
   225	.   {
   226	.   public:
   227	.     explicit
   228	.     __array_type_info(const char* __n) : std::type_info(__n) { }
   229	. 
   230	.     virtual
   231	.     ~__array_type_info();
   232	.   };
   233	. 
   234	.   // Type information for functions (both member and non-member).
   235	.   class __function_type_info : public std::type_info
   236	.   {
   237	.   public:
   238	.     explicit
   239	.     __function_type_info(const char* __n) : std::type_info(__n) { }
   240	. 
   241	.     virtual
   242	.     ~__function_type_info();
   243	. 
   244	.   protected:
   245	.     // Implementation defined member function.
   246	.     virtual bool
   247	.     __is_function_p() const;
   248	.   };
   249	. 
   250	.   // Type information for enumerations.
   251	.   class __enum_type_info : public std::type_info
   252	.   {
   253	.   public:
   254	.     explicit
   255	.     __enum_type_info(const char* __n) : std::type_info(__n) { }
   256	. 
   257	.     virtual
   258	.     ~__enum_type_info();
   259	.   };
   260	. 
   261	.   // Common type information for simple pointers and pointers to member.
   262	.   class __pbase_type_info : public std::type_info
   263	.   {
   264	.   public:
   265	.     unsigned int 		__flags; // Qualification of the target object.
   266	.     const std::type_info* 	__pointee; // Type of pointed to object.
   267	. 
   268	.     explicit
   269	.     __pbase_type_info(const char* __n, int __quals,
   270	. 		      const std::type_info* __type)
   271	.     : std::type_info(__n), __flags(__quals), __pointee(__type)
   272	.     { }
   273	. 
   274	.     virtual
   275	.     ~__pbase_type_info();
   276	. 
   277	.     // Implementation defined type.
   278	.     enum __masks
   279	.       {
   280	. 	__const_mask = 0x1,
   281	. 	__volatile_mask = 0x2,
   282	. 	__restrict_mask = 0x4,
   283	. 	__incomplete_mask = 0x8,
   284	. 	__incomplete_class_mask = 0x10,
   285	. 	__transaction_safe_mask = 0x20,
   286	. 	__noexcept_mask = 0x40
   287	.       };
   288	. 
   289	.   protected:
   290	.     __pbase_type_info(const __pbase_type_info&);
   291	. 
   292	.     __pbase_type_info&
   293	.     operator=(const __pbase_type_info&);
   294	. 
   295	.     // Implementation defined member functions.
   296	.     virtual bool
   297	.     __do_catch(const std::type_info* __thr_type, void** __thr_obj,
   298	. 	       unsigned int __outer) const;
   299	. 
   300	.     inline virtual bool
   301	.     __pointer_catch(const __pbase_type_info* __thr_type, void** __thr_obj,
   302	. 		    unsigned __outer) const;
   303	.   };
   304	. 
   305	.   inline bool __pbase_type_info::
   306	.   __pointer_catch (const __pbase_type_info *thrown_type,
   307	. 		   void **thr_obj,
   308	. 		   unsigned outer) const
   309	.   {
   310	.     return __pointee->__do_catch (thrown_type->__pointee, thr_obj, outer + 2);
   311	.   }
   312	. 
   313	.   // Type information for simple pointers.
   314	.   class __pointer_type_info : public __pbase_type_info
   315	.   {
   316	.   public:
   317	.     explicit
   318	.     __pointer_type_info(const char* __n, int __quals,
   319	. 			const std::type_info* __type)
   320	.     : __pbase_type_info (__n, __quals, __type) { }
   321	. 
   322	. 
   323	.     virtual
   324	.     ~__pointer_type_info();
   325	. 
   326	.   protected:
   327	.     // Implementation defined member functions.
   328	.     virtual bool
   329	.     __is_pointer_p() const;
   330	. 
   331	.     virtual bool
   332	.     __pointer_catch(const __pbase_type_info* __thr_type, void** __thr_obj,
   333	. 		    unsigned __outer) const;
   334	.   };
   335	. 
   336	.   class __class_type_info;
   337	. 
   338	.   // Type information for a pointer to member variable.
   339	.   class __pointer_to_member_type_info : public __pbase_type_info
   340	.   {
   341	.   public:
   342	.     __class_type_info* __context;   // Class of the member.
   343	. 
   344	.     explicit
   345	.     __pointer_to_member_type_info(const char* __n, int __quals,
   346	. 				  const std::type_info* __type,
   347	. 				  __class_type_info* __klass)
   348	.     : __pbase_type_info(__n, __quals, __type), __context(__klass) { }
   349	. 
   350	.     virtual
   351	.     ~__pointer_to_member_type_info();
   352	. 
   353	.   protected:
   354	.     __pointer_to_member_type_info(const __pointer_to_member_type_info&);
   355	. 
   356	.     __pointer_to_member_type_info&
   357	.     operator=(const __pointer_to_member_type_info&);
   358	. 
   359	.     // Implementation defined member function.
   360	.     virtual bool
   361	.     __pointer_catch(const __pbase_type_info* __thr_type, void** __thr_obj,
   362	. 		    unsigned __outer) const;
   363	.   };
   364	. 
   365	.   // Helper class for __vmi_class_type.
   366	.   class __base_class_type_info
   367	.   {
   368	.   public:
   369	.     const __class_type_info* 	__base_type;  // Base class type.
   370	. #ifdef _GLIBCXX_LLP64
   371	.     long long			__offset_flags;  // Offset and info.
   372	. #else
   373	.     long 			__offset_flags;  // Offset and info.
   374	. #endif
   375	. 
   376	.     enum __offset_flags_masks
   377	.       {
   378	. 	__virtual_mask = 0x1,
   379	. 	__public_mask = 0x2,
   380	. 	__hwm_bit = 2,
   381	. 	__offset_shift = 8          // Bits to shift offset.
   382	.       };
   383	. 
   384	.     // Implementation defined member functions.
   385	.     bool
   386	.     __is_virtual_p() const
   387	.     { return __offset_flags & __virtual_mask; }
   388	. 
   389	.     bool
   390	.     __is_public_p() const
   391	.     { return __offset_flags & __public_mask; }
   392	. 
   393	.     ptrdiff_t
   394	.     __offset() const
   395	.     {
   396	.       // This shift, being of a signed type, is implementation
   397	.       // defined. GCC implements such shifts as arithmetic, which is
   398	.       // what we want.
   399	.       return static_cast<ptrdiff_t>(__offset_flags) >> __offset_shift;
   400	.     }
   401	.   };
   402	. 
   403	.   // Type information for a class.
   404	.   class __class_type_info : public std::type_info
   405	.   {
   406	.   public:
   407	.     explicit
   408	.     __class_type_info (const char *__n) : type_info(__n) { }
   409	. 
   410	.     virtual
   411	.     ~__class_type_info ();
   412	. 
   413	.     // Implementation defined types.
   414	.     // The type sub_kind tells us about how a base object is contained
   415	.     // within a derived object. We often do this lazily, hence the
   416	.     // UNKNOWN value. At other times we may use NOT_CONTAINED to mean
   417	.     // not publicly contained.
   418	.     enum __sub_kind
   419	.       {
   420	. 	// We have no idea.
   421	. 	__unknown = 0,
   422	. 
   423	. 	// Not contained within us (in some circumstances this might
   424	. 	// mean not contained publicly)
   425	. 	__not_contained,
   426	. 
   427	. 	// Contained ambiguously.
   428	. 	__contained_ambig,
   429	. 
   430	. 	// Via a virtual path.
   431	. 	__contained_virtual_mask = __base_class_type_info::__virtual_mask,
   432	. 
   433	. 	// Via a public path.
   434	. 	__contained_public_mask = __base_class_type_info::__public_mask,
   435	. 
   436	. 	// Contained within us.
   437	. 	__contained_mask = 1 << __base_class_type_info::__hwm_bit,
   438	. 
   439	. 	__contained_private = __contained_mask,
   440	. 	__contained_public = __contained_mask | __contained_public_mask
   441	.       };
   442	. 
   443	.     struct __upcast_result;
   444	.     struct __dyncast_result;
   445	. 
   446	.   protected:
   447	.     // Implementation defined member functions.
   448	.     virtual bool
   449	.     __do_upcast(const __class_type_info* __dst_type, void**__obj_ptr) const;
   450	. 
   451	.     virtual bool
   452	.     __do_catch(const type_info* __thr_type, void** __thr_obj,
   453	. 	       unsigned __outer) const;
   454	. 
   455	.   public:
   456	.     // Helper for upcast. See if DST is us, or one of our bases.
   457	.     // Return false if not found, true if found.
   458	.     virtual bool
   459	.     __do_upcast(const __class_type_info* __dst, const void* __obj,
   460	. 		__upcast_result& __restrict __result) const;
   461	. 
   462	.     // Indicate whether SRC_PTR of type SRC_TYPE is contained publicly
   463	.     // within OBJ_PTR. OBJ_PTR points to a base object of our type,
   464	.     // which is the destination type. SRC2DST indicates how SRC
   465	.     // objects might be contained within this type.  If SRC_PTR is one
   466	.     // of our SRC_TYPE bases, indicate the virtuality. Returns
   467	.     // not_contained for non containment or private containment.
   468	.     inline __sub_kind
   469	.     __find_public_src(ptrdiff_t __src2dst, const void* __obj_ptr,
   470	. 		      const __class_type_info* __src_type,
   471	. 		      const void* __src_ptr) const;
   472	. 
   473	.     // Helper for dynamic cast. ACCESS_PATH gives the access from the
   474	.     // most derived object to this base. DST_TYPE indicates the
   475	.     // desired type we want. OBJ_PTR points to a base of our type
   476	.     // within the complete object. SRC_TYPE indicates the static type
   477	.     // started from and SRC_PTR points to that base within the most
   478	.     // derived object. Fill in RESULT with what we find. Return true
   479	.     // if we have located an ambiguous match.
   480	.     virtual bool
   481	.     __do_dyncast(ptrdiff_t __src2dst, __sub_kind __access_path,
   482	. 		 const __class_type_info* __dst_type, const void* __obj_ptr,
   483	. 		 const __class_type_info* __src_type, const void* __src_ptr,
   484	. 		 __dyncast_result& __result) const;
   485	. 
   486	.     // Helper for find_public_subobj. SRC2DST indicates how SRC_TYPE
   487	.     // bases are inherited by the type started from -- which is not
   488	.     // necessarily the current type. The current type will be a base
   489	.     // of the destination type.  OBJ_PTR points to the current base.
   490	.     virtual __sub_kind
   491	.     __do_find_public_src(ptrdiff_t __src2dst, const void* __obj_ptr,
   492	. 			 const __class_type_info* __src_type,
   493	. 			 const void* __src_ptr) const;
   494	.   };
   495	. 
   496	.   // Type information for a class with a single non-virtual base.
   497	.   class __si_class_type_info : public __class_type_info
   498	.   {
   499	.   public:
   500	.     const __class_type_info* __base_type;
   501	. 
   502	.     explicit
   503	.     __si_class_type_info(const char *__n, const __class_type_info *__base)
   504	.     : __class_type_info(__n), __base_type(__base) { }
   505	. 
   506	.     virtual
   507	.     ~__si_class_type_info();
   508	. 
   509	.   protected:
   510	.     __si_class_type_info(const __si_class_type_info&);
   511	. 
   512	.     __si_class_type_info&
   513	.     operator=(const __si_class_type_info&);
   514	. 
   515	.     // Implementation defined member functions.
   516	.     virtual bool
   517	.     __do_dyncast(ptrdiff_t __src2dst, __sub_kind __access_path,
   518	. 		 const __class_type_info* __dst_type, const void* __obj_ptr,
   519	. 		 const __class_type_info* __src_type, const void* __src_ptr,
   520	. 		 __dyncast_result& __result) const;
   521	. 
   522	.     virtual __sub_kind
   523	.     __do_find_public_src(ptrdiff_t __src2dst, const void* __obj_ptr,
   524	. 			 const __class_type_info* __src_type,
   525	. 			 const void* __sub_ptr) const;
   526	. 
   527	.     virtual bool
   528	.     __do_upcast(const __class_type_info*__dst, const void*__obj,
   529	. 		__upcast_result& __restrict __result) const;
   530	.   };
   531	. 
   532	.   // Type information for a class with multiple and/or virtual bases.
   533	.   class __vmi_class_type_info : public __class_type_info
   534	.   {
   535	.   public:
   536	.     unsigned int 		__flags;  // Details about the class hierarchy.
   537	.     unsigned int 		__base_count;  // Number of direct bases.
   538	. 
   539	.     // The array of bases uses the trailing array struct hack so this
   540	.     // class is not constructable with a normal constructor. It is
   541	.     // internally generated by the compiler.
   542	.     __base_class_type_info 	__base_info[1];  // Array of bases.
   543	. 
   544	.     explicit
   545	.     __vmi_class_type_info(const char* __n, int ___flags)
   546	.     : __class_type_info(__n), __flags(___flags), __base_count(0) { }
   547	. 
   548	.     virtual
   549	.     ~__vmi_class_type_info();
   550	. 
   551	.     // Implementation defined types.
   552	.     enum __flags_masks
   553	.       {
   554	. 	__non_diamond_repeat_mask = 0x1, // Distinct instance of repeated base.
   555	. 	__diamond_shaped_mask = 0x2, // Diamond shaped multiple inheritance.
   556	. 	__flags_unknown_mask = 0x10
   557	.       };
   558	. 
   559	.   protected:
   560	.     // Implementation defined member functions.
   561	.     virtual bool
   562	.     __do_dyncast(ptrdiff_t __src2dst, __sub_kind __access_path,
   563	. 		 const __class_type_info* __dst_type, const void* __obj_ptr,
   564	. 		 const __class_type_info* __src_type, const void* __src_ptr,
   565	. 		 __dyncast_result& __result) const;
   566	. 
   567	.     virtual __sub_kind
   568	.     __do_find_public_src(ptrdiff_t __src2dst, const void* __obj_ptr,
   569	. 			 const __class_type_info* __src_type,
   570	. 			 const void* __src_ptr) const;
   571	. 
   572	.     virtual bool
   573	.     __do_upcast(const __class_type_info* __dst, const void* __obj,
   574	. 		__upcast_result& __restrict __result) const;
   575	.   };
   576	. 
   577	.   // Exception handling forward declarations.
   578	.   struct __cxa_exception;
   579	.   struct __cxa_refcounted_exception;
   580	.   struct __cxa_dependent_exception;
   581	.   struct __cxa_eh_globals;
   582	. 
   583	.   extern "C"
   584	.   {
   585	.   // Dynamic cast runtime.
   586	. 
   587	.   // src2dst has the following possible values
   588	.   //  >-1: src_type is a unique public non-virtual base of dst_type
   589	.   //       dst_ptr + src2dst == src_ptr
   590	.   //   -1: unspecified relationship
   591	.   //   -2: src_type is not a public base of dst_type
   592	.   //   -3: src_type is a multiple public non-virtual base of dst_type
   593	.   void*
   594	.   __dynamic_cast(const void* __src_ptr, // Starting object.
   595	. 		 const __class_type_info* __src_type, // Static type of object.
   596	. 		 const __class_type_info* __dst_type, // Desired target type.
   597	. 		 ptrdiff_t __src2dst); // How src and dst are related.
   598	. 
   599	. 
   600	.   // Exception handling runtime.
   601	. 
   602	.   // The __cxa_eh_globals for the current thread can be obtained by using
   603	.   // either of the following functions.  The "fast" version assumes at least
   604	.   // one prior call of __cxa_get_globals has been made from the current
   605	.   // thread, so no initialization is necessary.
   606	.   __cxa_eh_globals*
   607	.   __cxa_get_globals()  __attribute__ ((__const__));
   608	. 
   609	.   __cxa_eh_globals*
   610	.   __cxa_get_globals_fast()  __attribute__ ((__const__));
   611	. 
   612	.   // Free the space allocated for the primary exception.
   613	.   void 
   614	.   __cxa_free_exception(void*) ;
   615	. 
   616	.   // Throw the exception.
   617	. 
   618	.   void
   619	.   __cxa_throw(void*, std::type_info*, void (*) (void *))
   620	.   __attribute__((__noreturn__));
   621	. 
   622	.   // Used to implement exception handlers.
   623	.   void*
   624	.   __cxa_get_exception_ptr(void*)  __attribute__ ((__pure__));
   625	. 
   626	.   void*
   627	.   __cxa_begin_catch(void*) ;
   628	. 
   629	.   void 
   630	.   __cxa_end_catch();
   631	. 
   632	.   void 
   633	.   __cxa_rethrow() __attribute__((__noreturn__));
   634	. 
   635	.   // Returns the type_info for the currently handled exception [15.3/8], or
   636	.   // null if there is none.
   637	.   std::type_info*
   638	.   __cxa_current_exception_type()  __attribute__ ((__pure__));
   639	. 
   640	.   // GNU Extensions.
   641	. 
   642	.   // Allocate memory for a dependent exception.
   643	.   __cxa_dependent_exception*
   644	.   __cxa_allocate_dependent_exception() ;
   645	. 
   646	.   // Free the space allocated for the dependent exception.
   647	.   void
   648	.   __cxa_free_dependent_exception(__cxa_dependent_exception*) ;
   649	. 
   650	.   } // extern "C"
   651	. 
   652	.   // A magic placeholder class that can be caught by reference
   653	.   // to recognize foreign exceptions.
   654	.   class __foreign_exception
   655	.   {
   656	.     virtual ~__foreign_exception() throw();
   657	.     virtual void __pure_dummy() = 0; // prevent catch by value
   658	.   };
   659	. 
   660	. } // namespace __cxxabiv1
   661	. 
   662	. /** @namespace abi
   663	.  *  @brief The cross-vendor C++ Application Binary Interface. A
   664	.  *  namespace alias to __cxxabiv1, but user programs should use the
   665	.  *  alias 'abi'.
   666	.  *
   667	.  *  A brief overview of an ABI is given in the libstdc++ FAQ, question
   668	.  *  5.8 (you may have a copy of the FAQ locally, or you can view the online
   669	.  *  version at http://gcc.gnu.org/onlinedocs/libstdc++/faq.html#5_8 ).
   670	.  *
   671	.  *  GCC subscribes to a cross-vendor ABI for C++, sometimes
   672	.  *  called the IA64 ABI because it happens to be the native ABI for that
   673	.  *  platform.  It is summarized at http://www.codesourcery.com/cxx-abi/
   674	.  *  along with the current specification.
   675	.  *
   676	.  *  For users of GCC greater than or equal to 3.x, entry points are
   677	.  *  available in <cxxabi.h>, which notes, <em>'It is not normally
   678	.  *  necessary for user programs to include this header, or use the
   679	.  *  entry points directly.  However, this header is available should
   680	.  *  that be needed.'</em>
   681	. */
   682	. namespace abi = __cxxabiv1;
   683	. 
   684	. //   namespace __gnu_cxx
   685	. //   {
   686	. //     /**
   687	. //      *  @brief Exception thrown by __cxa_guard_acquire.
   688	. //      *  @ingroup exceptions
   689	. //      *
   690	. //      *  C++ 2011 6.7 [stmt.dcl]/4: If control re-enters the declaration
   691	. //      *  recursively while the variable is being initialized, the behavior
   692	. //      *  is undefined.
   693	. //      *
   694	. //      *  Since we already have a library function to handle locking, we might
   695	. //      *  as well check for this situation and throw an exception.
   696	. //      *  We use the second byte of the guard variable to remember that we're
   697	. //      *  in the middle of an initialization.
   698	. //      */
   699	. //     class recursive_init_error: public std::exception
   700	. //     {
   701	. //     public:
   702	. //       recursive_init_error() ;
   703	. //       virtual ~recursive_init_error() ;
   704	. //     };
   705	. //   }
   706	. #endif // __cplusplus
   707	. 
   708	. #pragma GCC visibility pop
   709	. 
   710	. #endif // __CXXABI_H
FILE: END: inc/cxxabi.hh
FILE: START: inc/dbg.hh
HASH: MD5: 2a8c4053b51e7bb44e120db68bcfacf4
     1	. #define NDEBUG
     2	. #include <assert.h>
     3	. 
     4	. #ifndef debug_hh
     5	. #define debug_hh debug_hh
     6	. 
     7	. //#include <iostream>
     8	. //#include <exception>
     9	. //#include <typeinfo>
    10	. 
    11	. //using std::ostream;
    12	. //using std::exception;
    13	. //using std::type_info;
    14	. //ostream &operator(ostream &lhs, const exception &rhs);
    15	. //ostream &operator(ostream &lhs, const type_info &rhs);
    16	. 
    17	. namespace dbg {
    18	.   struct runtime_error
    19	.   {
    20	.   };
    21	.   template<typename ...arg_t>
    22	.     void __xthrow(arg_t ... args);
    23	.   void __xassert(const char *cond);
    24	. };
    25	. 
    26	. #define nop()
    27	. #define macwrap(x,y)  do{ x; y; }while(0)
    28	. #define xsrcpos() __FILE__ , ":" , __LINE__ , ":  "
    29	. #define xtrace2(x,y)  macwrap( log(xscrpos(),x,"\n");
    30	. #define xtrace(x)     xtrace2(x,nop())
    31	. #define xcomment(x)   xtrace2(x,nop())
    32	. #define xexpose(x)    xtrace2(  #x , " => " ,  x,  nop()  )
    33	. #define xcarp(x)      xtrace2(  "warning:             "      ,  x,  nop()        )
    34	. #define xcroak(x)     xtrace2(  "error:               "      ,  x,  abort()      )
    35	. #define xconfess(x)   xtrace2(  "confess:             "        x,  dump(true)   )
    36	. #define xcluck(x)     xtrace2(  "cluck:               "        x,  dump(false)  )
    37	. #define xcheckin()    xtrace2(  __PRETTY_FUNCTION__,  nop()  )
    38	. #define xassert(x)    if(!(x)) { dbg::__xassert( #x ); }
    39	. #define xnv(x) #x   " => "  (x)
    40	. #define dbg() __FILE__  ":"  __LINE__  ":"
    41	. #define  xthrow(x,y) do{ dbg::__xthrow(x,y); }while(false)
    42	. //#define  xthrowre(y) xthrow(runtime_error,y)
    43	. #define  xthrowre(y) xthrow(runtime_error,y)
    44	. 
    45	. #endif //debug_hh
FILE: END: inc/dbg.hh
FILE: START: inc/errno.hh
HASH: MD5: 9b1d75725b672a0c7beae3225b64a46c
     1	. #ifndef errno_hh
     2	. #define errno_hh errno_hh
     3	. 
     4	. #include <types.hh>
     5	. 
     6	. #define	EPERM		 1	/* Operation not permitted */
     7	. #define	ENOENT		 2	/* No such file or directory */
     8	. #define	ESRCH		 3	/* No such process */
     9	. #define	EINTR		 4	/* Interrupted system call */
    10	. #define	EIO		 5	/* I/O error */
    11	. #define	ENXIO		 6	/* No such device or address */
    12	. #define	E2BIG		 7	/* Argument list too long */
    13	. #define	ENOEXEC		 8	/* Exec format error */
    14	. #define	EBADF		 9	/* Bad file number */
    15	. #define	ECHILD		10	/* No child processes */
    16	. #define	EAGAIN		11	/* Try again */
    17	. #define	ENOMEM		12	/* Out of memory */
    18	. #define	EACCES		13	/* Permission denied */
    19	. #define	EFAULT		14	/* Bad address */
    20	. #define	ENOTBLK		15	/* Block device required */
    21	. #define	EBUSY		16	/* Device or resource busy */
    22	. #define	EEXIST		17	/* File exists */
    23	. #define	EXDEV		18	/* Cross-device link */
    24	. #define	ENODEV		19	/* No such device */
    25	. #define	ENOTDIR		20	/* Not a directory */
    26	. #define	EISDIR		21	/* Is a directory */
    27	. #define	EINVAL		22	/* Invalid argument */
    28	. #define	ENFILE		23	/* File table overflow */
    29	. #define	EMFILE		24	/* Too many open files */
    30	. #define	ENOTTY		25	/* Not a typewriter */
    31	. #define	ETXTBSY		26	/* Text file busy */
    32	. #define	EFBIG		27	/* File too large */
    33	. #define	ENOSPC		28	/* No space left on device */
    34	. #define	ESPIPE		29	/* Illegal seek */
    35	. #define	EROFS		30	/* Read-only file system */
    36	. #define	EMLINK		31	/* Too many links */
    37	. #define	EPIPE		32	/* Broken pipe */
    38	. #define	EDOM		33	/* Math argument out of domain of func */
    39	. #define	ERANGE		34	/* Math result not representable */
    40	. 
    41	. 
    42	. struct c_str;
    43	. namespace sys {
    44	.   typedef long errno_t;
    45	.   extern errno_t errno;
    46	.   ssize_t set_errno(errno_t err);
    47	.   const c_str &strerror(errno_t err=errno);
    48	.   void perror(const c_str &msg1, const c_str &msg2);
    49	.   void pexit(const c_str &msg1, const c_str &msg2);
    50	.   void perror(const c_str &msg1);
    51	.   void pexit(const c_str &msg1);
    52	. };
    53	. 
    54	. #endif
FILE: END: inc/errno.hh
FILE: START: inc/fmt.hh
HASH: MD5: bb1b3a79550ee9fc1ca3a51060ef716d
     1	. #ifndef fmt_hh
     2	. #define fmt_hh
     3	. 
     4	. #include <syscall.hh>
     5	. #include <c_str.hh>
     6	. #if 1
     7	. #define AAI __attribute__((__always_inline__))
     8	. #else
     9	. #define AAI
    10	. #endif
    11	. 
    12	. 
    13	. typedef unsigned fd_t;
    14	. namespace fmt {
    15	.   struct hex_t {
    16	.     size_t val;
    17	.     size_t size;
    18	.     template<typename val_t>
    19	.       hex_t(val_t val)
    20	.       : val(val), size(sizeof(val))
    21	.       {
    22	.       };
    23	.   };
    24	.   static inline char hex_dig(int val) {
    25	.     constexpr char digs[] = "0123456789abcdef";
    26	.     return digs[val & 0xf];
    27	.   };
    28	.   inline char *fmt_hex(unsigned long val, char *beg, char *end) {
    29	.     for (int i = 0; i < 2 * sizeof(val); i++) {
    30	.       *--end = hex_dig(val);
    31	.       val /= 0x10;
    32	.     };
    33	.     return end;
    34	.   };
    35	.   inline char *fmt_ptr(void *val, char *beg, char *end) {
    36	.     *--end = ']';
    37	.     end = fmt_hex(size_t(val), beg, end);
    38	.     *--end = 'x';
    39	.     *--end = '0';
    40	.     *--end = '[';
    41	.     return end;
    42	.   };
    43	.   inline char *fmt_dec(bool neg, unsigned long val, char *beg, char *end, int width = 0) {
    44	.     char *max = (width ? end - width : 0);
    45	.     if (val) {
    46	.       while (val) {
    47	.         *--end = hex_dig(val % 10);
    48	.         val /= 10;
    49	.       };
    50	.     } else {
    51	.       *--end = '0';
    52	.     };
    53	.     if (max)
    54	.       while (end > max)
    55	.         *--end = ' ';
    56	.     return end;
    57	.   };
    58	.   using sys::write;
    59	.   inline int write_dec(fd_t fd, size_t val) {
    60	.     char buf[sizeof(val) * 4];
    61	.     return write(fd, fmt::fmt_dec(false,val, buf, &buf[sizeof(buf) - 1]));
    62	.   };
    63	.   inline int write_hex(fd_t fd, size_t hex) {
    64	.     char buf[sizeof(hex) * 4];
    65	.     return write(fd, fmt::fmt_hex(hex, buf, &buf[sizeof(buf) - 1]));
    66	.   };
    67	.   inline int write_ptr(fd_t fd, void *ptr) {
    68	.     char buf[sizeof(ptr) * 4];
    69	.     return write(fd, fmt::fmt_ptr((void *)ptr, buf, &buf[sizeof(buf) - 1]));
    70	.   };
    71	.   inline int write_tm(fd_t fd, timeval &tm) {
    72	.     char buf[(sizeof(tm.tv_sec) + sizeof(tm.tv_nsec)) * 4 + 16];
    73	.     char *const end = &buf[sizeof(buf) - 1];
    74	.     char *pos = end;
    75	.     *--pos = '}';
    76	.     pos = fmt::fmt_dec(false,tm.tv_nsec, buf, pos);
    77	.     *--pos = ',';
    78	.     pos = fmt::fmt_dec(false,tm.tv_sec, buf, pos);
    79	.     *--pos = '{';
    80	.     return write(fd, pos, end);
    81	.   };
    82	.   inline int write_tm(fd_t fd, timespec &tm) {
    83	.     char buf[(sizeof(tm.tv_sec) + sizeof(tm.tv_nsec)) * 4 + 16];
    84	.     char *const end = &buf[sizeof(buf) - 1];
    85	.     char *pos = end;
    86	.     *--pos = '}';
    87	.     pos = fmt::fmt_dec(false,tm.tv_nsec, buf, pos);
    88	.     *--pos = ',';
    89	.     pos = fmt::fmt_dec(false,tm.tv_sec, buf, pos);
    90	.     *--pos = '{';
    91	.     return write(fd, pos, end);
    92	.   };
    93	.   inline int atoi(const char *a) {
    94	.     int i = 0;
    95	.     char ch;
    96	.     while ((ch = *a++)) {
    97	.       switch (ch) {
    98	.         case '1':
    99	.         case '2':
   100	.         case '3':
   101	.         case '4':
   102	.         case '5':
   103	.         case '6':
   104	.         case '7':
   105	.         case '8':
   106	.         case '9':
   107	.         case '0':
   108	.           i *= 10;
   109	.           i += (ch - '0');
   110	.           break;
   111	.         default:
   112	.           write(2, "err!");
   113	.           sys::exit(1);
   114	.       };
   115	.     };
   116	.     return i;
   117	.   };
   118	. #define show_val(x) do_show_val(L(#x),(x))
   119	. #define show_dec(x)                                                            \
   120	.   do {                                                                         \
   121	.     write(2, L(#x " => "));                                                    \
   122	.     write_dec(2, (x));                                                         \
   123	.     write(2, L("\n"));                                                         \
   124	.   } while (false);
   125	. #define show_ptr(x)                                                            \
   126	.   do {                                                                         \
   127	.     write(2, L(#x " => "));                                                    \
   128	.     write_ptr(2, (x));                                                         \
   129	.     write(2, L("\n"));                                                         \
   130	.   } while (false);
   131	. #define show_hex(x)                                                            \
   132	.   do {                                                                         \
   133	.     write(2, L(#x " => "));                                                    \
   134	.     write_hex(2, (x));                                                         \
   135	.     write(2, L("\n"));                                                         \
   136	.   } while (false);
   137	. #undef AAI
   138	. 
   139	.   struct fmt_t
   140	.   {
   141	.     enum { n = 64 };
   142	.     char buf[n-1];
   143	.     char end[1];
   144	.     char pos;
   145	.     static char hex_dig[17];
   146	.     void fmt(int val) {
   147	.       char old_pos=pos;
   148	.       if(val<0) {
   149	.         pos=fmt_dec(false,-val, buf, buf+pos)-buf;
   150	.         buf[--pos]='-';
   151	.       } else {
   152	.         pos=fmt_dec(false,val,buf,buf+pos)-buf;
   153	.       };
   154	.     };
   155	.     void fmt(long val){
   156	.       if(val<0) {
   157	.         pos=fmt_dec(false,-val, buf, buf+pos)-buf;
   158	.         buf[--pos]='-';
   159	.       } else {
   160	.         pos=fmt_dec(false,val,buf,buf+pos)-buf;
   161	.       };
   162	.     };
   163	.     void fmt(long long val){
   164	.       if(val<0) {
   165	.         pos=fmt_dec(false,-val, buf, buf+pos)-buf;
   166	.         buf[--pos]='-';
   167	.       } else {
   168	.         pos=fmt_dec(false,val,buf,buf+pos)-buf;
   169	.       };
   170	.     };
   171	.     int fmt(unsigned long val){
   172	.       return pos=fmt_dec(false,val, buf, buf+pos)-buf;
   173	.     };
   174	.     int fmt(unsigned long long val){
   175	.       return pos=fmt_dec(false,val, buf, buf+pos)-buf;
   176	.     };
   177	.     int fmt(unsigned val){
   178	.       return pos=fmt_dec(false,val, buf, buf+pos)-buf;
   179	.     };
   180	.     int fmt(float val);
   181	.     int fmt(double val);
   182	.     int fmt(long double val);
   183	.     int fmt(void *vp)
   184	.     {
   185	.       return pos=fmt_ptr(vp, buf, buf+pos)-buf;
   186	.     };
   187	.     int fmt(const hex_t &val)
   188	.     {
   189	.       return pos=fmt_hex(val.val, buf, buf+pos)-buf;
   190	.     };
   191	.     template<typename val_t>
   192	.       explicit fmt_t( val_t val )
   193	.       : pos(end-buf)
   194	.       {
   195	.         buf[pos--]=0;
   196	.         fmt(val);
   197	.       };
   198	.     c_str get() const
   199	.     {
   200	.       static size_t maxlen=0;
   201	.       c_str res(&buf[pos], &end[0]);
   202	.       if( maxlen < res.len() )
   203	.         maxlen=res.len();
   204	.       return res;
   205	.     };
   206	.   };
   207	. }; // namespace fmt
   208	. #endif
FILE: END: inc/fmt.hh
FILE: START: inc/getopt.hh
HASH: MD5: 2f98ad2ff07a21c9a9364054a2896e5d
     1	. /*******************************************************************************
     2	.  * Copyright (c) 2012-2017, Kim Grasman <kim.grasman@gmail.com>
     3	.  * All rights reserved.
     4	.  *
     5	.  * Redistribution and use in source and binary forms, with or without
     6	.  * modification, are permitted provided that the following conditions are met:
     7	.  *   * Redistributions of source code must retain the above copyright
     8	.  *     notice, this list of conditions and the following disclaimer.
     9	.  *   * Redistributions in binary form must reproduce the above copyright
    10	.  *     notice, this list of conditions and the following disclaimer in the
    11	.  *     documentation and/or other materials provided with the distribution.
    12	.  *   * Neither the name of Kim Grasman nor the
    13	.  *     names of contributors may be used to endorse or promote products
    14	.  *     derived from this software without specific prior written permission.
    15	.  *
    16	.  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
    17	.  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    18	.  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
    19	.  * ARE DISCLAIMED. IN NO EVENT SHALL KIM GRASMAN BE LIABLE FOR ANY
    20	.  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
    21	.  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
    22	.  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
    23	.  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
    24	.  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    25	.  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    26	.  *
    27	.  ******************************************************************************/
    28	. 
    29	. #ifndef INCLUDED_GETOPT_PORT_H
    30	. #define INCLUDED_GETOPT_PORT_H
    31	. 
    32	. #if defined(__cplusplus)
    33	. extern "C" {
    34	. #endif
    35	. 
    36	. #define no_argument 1
    37	. #define required_argument 2
    38	. #define optional_argument 3
    39	. 
    40	. extern char* optarg;
    41	. extern int optind, opterr, optopt;
    42	. 
    43	. struct option {
    44	.   const char* name;
    45	.   int has_arg;
    46	.   int* flag;
    47	.   int val;
    48	. };
    49	. 
    50	. int getopt(int argc, char* const argv[], const char* optstring);
    51	. 
    52	. int getopt_long(int argc, char* const argv[],
    53	.   const char* optstring, const struct option* longopts, int* longindex);
    54	. 
    55	. #if defined(__cplusplus)
    56	. }
    57	. #endif
    58	. 
    59	. #endif // INCLUDED_GETOPT_PORT_H
FILE: END: inc/getopt.hh
FILE: START: inc/new.hh
HASH: MD5: fa779b31e23c39413042dc34e7e16779
     1	. #include <syscall.hh>
     2	. 
     3	. void* operator new(size_t sz);
     4	. void* operator new(size_t size, std::align_val_t align);
     5	. void* operator new[](size_t size);
     6	. void* operator new[](size_t size, std::align_val_t align);
     7	. 
     8	. void operator delete(void* ptr) noexcept;
     9	. void operator delete[](void *ptr);
    10	. void operator delete(void* ptr, size_t size);
    11	. namespace std {
    12	. 	new_handler set_new_handler (new_handler handler) throw();
    13	. 	new_handler get_new_handler () noexcept;
    14	. }
    15	. 
FILE: END: inc/new.hh
FILE: START: inc/reverse_iterator.hh
HASH: MD5: 1268bc05de4201bb4cbafb842bd65a0e
     1	. #ifndef reverse_iterator_hh
     2	. #define reverse_itreator_hh
     3	. namespace std
     4	. {
     5	.   typedef decltype(((char*)0)-((char*)0)) ptrdiff_t;
     6	. 
     7	.   template<typename _Tp>
     8	.     inline constexpr _Tp*
     9	.     __addressof(_Tp& __r) noexcept
    10	.     { return __builtin_addressof(__r); }
    11	.   template<typename...>
    12	.     using void_t=void;
    13	. 
    14	.   template<typename _Iterator, typename = void_t<>>
    15	.     struct iterator_traits { };
    16	. 
    17	.   template<typename _Category, typename _Tp, typename _Distance = ptrdiff_t,
    18	.            typename _Pointer = _Tp*, typename _Reference = _Tp&>
    19	.     struct iterator
    20	.     {
    21	. 
    22	.       typedef _Category iterator_category;
    23	. 
    24	.       typedef _Tp value_type;
    25	. 
    26	.       typedef _Distance difference_type;
    27	. 
    28	.       typedef _Pointer pointer;
    29	. 
    30	.       typedef _Reference reference;
    31	.     };
    32	.   template<typename _Iterator>
    33	.     struct iterator_traits<_Iterator,
    34	.         void_t<typename _Iterator::iterator_category,
    35	.           typename _Iterator::value_type,
    36	.           typename _Iterator::difference_type,
    37	.           typename _Iterator::pointer,
    38	.           typename _Iterator::reference>>
    39	.     {
    40	.       typedef typename _Iterator::iterator_category iterator_category;
    41	.       typedef typename _Iterator::value_type value_type;
    42	.       typedef typename _Iterator::difference_type difference_type;
    43	.       typedef typename _Iterator::pointer pointer;
    44	.       typedef typename _Iterator::reference reference;
    45	.     };
    46	.   template <typename _Iterator>
    47	.   class reverse_iterator
    48	.       : public iterator<
    49	.                  typename iterator_traits<_Iterator>::iterator_category,
    50	.                  typename iterator_traits<_Iterator>::value_type,
    51	.                  typename iterator_traits<_Iterator>::difference_type,
    52	.                  typename iterator_traits<_Iterator>::pointer,
    53	.                  typename iterator_traits<_Iterator>::reference>
    54	.   {
    55	.   protected:
    56	.     _Iterator current;
    57	. 
    58	.     typedef iterator_traits<_Iterator> traits_type;
    59	. 
    60	.   public:
    61	.     typedef _Iterator                               iterator_type;
    62	.     typedef typename traits_type::difference_type difference_type;
    63	.     typedef typename traits_type::pointer         pointer;
    64	.     typedef typename traits_type::reference       reference;
    65	. 
    66	.     constexpr reverse_iterator()
    67	.         : current()
    68	.     {
    69	.     }
    70	. 
    71	. 
    72	.     explicit constexpr reverse_iterator(iterator_type __x)
    73	.         : current(__x)
    74	.     {
    75	.     }
    76	. 
    77	. 
    78	.     constexpr reverse_iterator(const reverse_iterator& __x)
    79	.         : current(__x.current)
    80	.     {
    81	.     }
    82	. 
    83	. 
    84	.     template <typename _Iter>
    85	.     constexpr reverse_iterator(const reverse_iterator<_Iter>& __x)
    86	.         : current(__x.base())
    87	.     {
    88	.     }
    89	. 
    90	. 
    91	.     constexpr iterator_type base() const
    92	.     {
    93	.       return current;
    94	.     }
    95	. 
    96	.     constexpr reference operator*() const
    97	.     {
    98	.       _Iterator __tmp= current;
    99	.       return *--__tmp;
   100	.     }
   101	. 
   102	.     constexpr pointer operator->() const
   103	.     {
   104	.       return std::__addressof(operator*());
   105	.     }
   106	. 
   107	. 
   108	.     constexpr reverse_iterator& operator++()
   109	.     {
   110	.       --current;
   111	.       return *this;
   112	.     }
   113	. 
   114	. 
   115	.     constexpr reverse_iterator operator++(int)
   116	.     {
   117	.       reverse_iterator __tmp= *this;
   118	.       --current;
   119	.       return __tmp;
   120	.     }
   121	. 
   122	. 
   123	.     constexpr reverse_iterator& operator--()
   124	.     {
   125	.       ++current;
   126	.       return *this;
   127	.     }
   128	. 
   129	. 
   130	.     constexpr reverse_iterator operator--(int)
   131	.     {
   132	.       reverse_iterator __tmp= *this;
   133	.       ++current;
   134	.       return __tmp;
   135	.     }
   136	. 
   137	. 
   138	.     constexpr reverse_iterator operator+(difference_type __n) const
   139	.     {
   140	.       return reverse_iterator(current - __n);
   141	.     }
   142	. 
   143	. 
   144	.     constexpr reverse_iterator& operator+=(difference_type __n)
   145	.     {
   146	.       current-= __n;
   147	.       return *this;
   148	.     }
   149	. 
   150	. 
   151	.     constexpr reverse_iterator operator-(difference_type __n) const
   152	.     {
   153	.       return reverse_iterator(current + __n);
   154	.     }
   155	. 
   156	. 
   157	.     constexpr reverse_iterator& operator-=(difference_type __n)
   158	.     {
   159	.       current+= __n;
   160	.       return *this;
   161	.     }
   162	. 
   163	. 
   164	.     constexpr reference operator[](difference_type __n) const
   165	.     {
   166	.       return *(*this + __n);
   167	.     }
   168	.   };
   169	. 
   170	.   template <typename _Iterator>
   171	.   inline constexpr bool operator==(const reverse_iterator<_Iterator>& __x,
   172	.                                    const reverse_iterator<_Iterator>& __y)
   173	.   {
   174	.     return __x.base() == __y.base();
   175	.   }
   176	. 
   177	.   template <typename _Iterator>
   178	.   inline constexpr bool operator<(const reverse_iterator<_Iterator>& __x,
   179	.                                   const reverse_iterator<_Iterator>& __y)
   180	.   {
   181	.     return __y.base() < __x.base();
   182	.   }
   183	. 
   184	.   template <typename _Iterator>
   185	.   inline constexpr bool operator!=(const reverse_iterator<_Iterator>& __x,
   186	.                                    const reverse_iterator<_Iterator>& __y)
   187	.   {
   188	.     return !(__x == __y);
   189	.   }
   190	. 
   191	.   template <typename _Iterator>
   192	.   inline constexpr bool operator>(const reverse_iterator<_Iterator>& __x,
   193	.                                   const reverse_iterator<_Iterator>& __y)
   194	.   {
   195	.     return __y < __x;
   196	.   }
   197	. 
   198	.   template <typename _Iterator>
   199	.   inline constexpr bool operator<=(const reverse_iterator<_Iterator>& __x,
   200	.                                    const reverse_iterator<_Iterator>& __y)
   201	.   {
   202	.     return !(__y < __x);
   203	.   }
   204	. 
   205	.   template <typename _Iterator>
   206	.   inline constexpr bool operator>=(const reverse_iterator<_Iterator>& __x,
   207	.                                    const reverse_iterator<_Iterator>& __y)
   208	.   {
   209	.     return !(__x < __y);
   210	.   }
   211	. 
   212	. 
   213	.   template <typename _IteratorL, typename _IteratorR>
   214	.   inline constexpr bool operator==(const reverse_iterator<_IteratorL>& __x,
   215	.                                    const reverse_iterator<_IteratorR>& __y)
   216	.   {
   217	.     return __x.base() == __y.base();
   218	.   }
   219	. 
   220	.   template <typename _IteratorL, typename _IteratorR>
   221	.   inline constexpr bool operator<(const reverse_iterator<_IteratorL>& __x,
   222	.                                   const reverse_iterator<_IteratorR>& __y)
   223	.   {
   224	.     return __y.base() < __x.base();
   225	.   }
   226	. 
   227	.   template <typename _IteratorL, typename _IteratorR>
   228	.   inline constexpr bool operator!=(const reverse_iterator<_IteratorL>& __x,
   229	.                                    const reverse_iterator<_IteratorR>& __y)
   230	.   {
   231	.     return !(__x == __y);
   232	.   }
   233	. 
   234	.   template <typename _IteratorL, typename _IteratorR>
   235	.   inline constexpr bool operator>(const reverse_iterator<_IteratorL>& __x,
   236	.                                   const reverse_iterator<_IteratorR>& __y)
   237	.   {
   238	.     return __y < __x;
   239	.   }
   240	. 
   241	.   template <typename _IteratorL, typename _IteratorR>
   242	.   inline constexpr bool operator<=(const reverse_iterator<_IteratorL>& __x,
   243	.                                    const reverse_iterator<_IteratorR>& __y)
   244	.   {
   245	.     return !(__y < __x);
   246	.   }
   247	. 
   248	.   template <typename _IteratorL, typename _IteratorR>
   249	.   inline constexpr bool operator>=(const reverse_iterator<_IteratorL>& __x,
   250	.                                    const reverse_iterator<_IteratorR>& __y)
   251	.   {
   252	.     return !(__x < __y);
   253	.   }
   254	. 
   255	.   template <typename _IteratorL, typename _IteratorR>
   256	.   inline constexpr auto operator-(const reverse_iterator<_IteratorL>& __x,
   257	.                                   const reverse_iterator<_IteratorR>& __y)
   258	.            -> decltype(__y.base() - __x.base())
   259	.   {
   260	.     return __y.base() - __x.base();
   261	.   }
   262	. 
   263	. #if 0
   264	.   template <typename _Iterator>
   265	.   inline constexpr reverse_iterator<_Iterator> operator+(
   266	.            typename reverse_iterator<_Iterator>::difference_type __n,
   267	.            const reverse_iterator<_Iterator>&                    __x)
   268	.   {
   269	.     return reverse_iterator<_Iterator>(__x.base() - __n);
   270	.   }
   271	. 
   272	. 
   273	.   template <typename _Iterator>
   274	.   inline constexpr reverse_iterator<_Iterator> __make_reverse_iterator(
   275	.            _Iterator __i)
   276	.   {
   277	.     return reverse_iterator<_Iterator>(__i);
   278	.   }
   279	. 
   280	. 
   281	.   template <typename _Iterator>
   282	.   inline constexpr reverse_iterator<_Iterator> make_reverse_iterator(
   283	.            _Iterator __i)
   284	.   {
   285	.     return reverse_iterator<_Iterator>(__i);
   286	.   }
   287	. 
   288	. 
   289	.   template <typename _Iterator>
   290	.   auto __niter_base(reverse_iterator<_Iterator> __it)
   291	.            -> decltype(__make_reverse_iterator(__niter_base(__it.base())))
   292	.   {
   293	.     return __make_reverse_iterator(__niter_base(__it.base()));
   294	.   }
   295	. 
   296	.   template <typename _Iterator>
   297	.   struct __is_move_iterator<reverse_iterator<_Iterator>>
   298	.       : __is_move_iterator<_Iterator>
   299	.   {
   300	.   };
   301	. 
   302	.   template <typename _Iterator>
   303	.   auto __miter_base(reverse_iterator<_Iterator> __it)
   304	.            -> decltype(__make_reverse_iterator(__miter_base(__it.base())))
   305	.   {
   306	.     return __make_reverse_iterator(__miter_base(__it.base()));
   307	.   }
   308	. #endif
   309	. }; // namespace std
   310	. #endif
FILE: END: inc/reverse_iterator.hh
FILE: START: inc/stdlib.hh
HASH: MD5: ffb30b56cf09b14ab309b62a8f275aca
     1	. #ifndef stdlib_hh
     2	. #define stdlib_hh stdlib_hh
     3	. 
     4	. #include <types.hh>
     5	. extern "C"
     6	. {
     7	.   extern void*  malloc(size_t);
     8	.   extern void   free(void*);
     9	.   extern void*  realloc(void* ptr, size_t size);
    10	.   inline void*  sbrk(intptr_t increment) AAI;
    11	.   inline int    strcmp(const char* s1, const char* s2) AAI;
    12	.   inline void*  memset(void* s, int c, size_t n) AAI;
    13	.   inline void*  memcpy(void* dst, const void* src, size_t n) AAI;
    14	.   inline int    memcmp(const void* dst, const void* src, size_t n) AAI;
    15	.   inline void*  memmove(void* dst, const void* src, size_t n) AAI;
    16	.   inline void*  memchr(const void* _mem, int c, size_t n) AAI;
    17	.   inline char*  strcpy(char* d, const char* s) AAI;
    18	.   inline char*  strncpy(char* dst, const char* src, size_t n) AAI;
    19	.   inline char*  strncpy(char* dst, const char* src, size_t n) AAI;
    20	.   inline size_t strlen(const char* s) AAI;
    21	.   inline void*  memmove(void* _dst, const void* _src, size_t n)
    22	.   {
    23	.     char*       dst((char*)_dst);
    24	.     const char* src((const char*)_src);
    25	.     if(dst < src || dst > src + n)
    26	.       return memcpy(dst, src, n);
    27	.     while(n--)
    28	.       dst[n]= src[n];
    29	.     return dst;
    30	.   }
    31	.   void         exit(int res);
    32	.   inline void* memchr(const void* _mem, int c, size_t n)
    33	.   {
    34	.     const char* mem= (const char*)_mem;
    35	.     for(size_t i= 0; i < n; i++)
    36	.       if(mem[i] == c)
    37	.         return (void*)&mem[i];
    38	.     return nullptr;
    39	.   };
    40	.   inline size_t strcspn(const char* s, const char* reject)
    41	.   {
    42	.     char rej[256];
    43	.     memset(rej, 0, sizeof(rej));
    44	.     while(*reject)
    45	.       rej[*reject++]= 1;
    46	.     rej[0]  = 1;
    47	.     size_t i= 0;
    48	.     while(!rej[s[i]])
    49	.       ++i;
    50	.     return i;
    51	.   };
    52	.   inline char* strchr(const char* s, int c)
    53	.   {
    54	.     char ch;
    55	.     while((ch= *s++) != c)
    56	.     {
    57	.       if(!ch)
    58	.         return nullptr;
    59	.     }
    60	.     return (char*)s;
    61	.   };
    62	.   inline int strncmp(const char* lhs, const char* rhs, size_t n)
    63	.   {
    64	.     for(int i= 0; i < n; i++)
    65	.     {
    66	.       int res= lhs[i] - rhs[i];
    67	.       if(res)
    68	.         return res;
    69	.       if(!lhs[i])
    70	.         break;
    71	.     };
    72	.     return 0;
    73	.   };
    74	.   inline size_t strlen(const char* s)
    75	.   {
    76	.     const char* p(s);
    77	.     while(*p)
    78	.       ++p;
    79	.     return p - s;
    80	.   };
    81	.   inline int strcmp(const char* s1, const char* s2)
    82	.   {
    83	.     for(;;)
    84	.     {
    85	.       int d= *s1 - *s2;
    86	.       if(d)
    87	.         return d < 0 ? -1 : 1;
    88	.       if(!*s1)
    89	.         return 0;
    90	.       ++s1, ++s2;
    91	.     };
    92	.   };
    93	.   inline void* memset(void* s, int c, size_t n)
    94	.   {
    95	.     char* b= (char*)s;
    96	.     for(int i= 0; i < n; i++)
    97	.       b[i]= c;
    98	.     return s;
    99	.   };
   100	.   inline void* memcpy(void* dest, const void* src, size_t n)
   101	.   {
   102	.     char *d((char*)dest), *s((char*)src);
   103	.     for(int i= 0; i < n; i++)
   104	.       d[i]= s[i];
   105	.     return dest;
   106	.   };
   107	.   inline int memcmp(const void* _s1, const void* _s2, size_t n)
   108	.   {
   109	.     int         res= 0;
   110	.     const char* s1 = (const char*)_s1;
   111	.     const char* s2 = (const char*)_s2;
   112	.     for(size_t i= 0; i < n; i++)
   113	.     {
   114	.       if((res= s1[i] - s2[i]))
   115	.         break;
   116	.     };
   117	.     return res;
   118	.   };
   119	.   inline char* strcpy(char* d, const char* s)
   120	.   {
   121	.     size_t p= 0;
   122	.     for(;;)
   123	.     {
   124	.       if(not(d[p]= s[p]))
   125	.         return d;
   126	.       ++p;
   127	.     };
   128	.   };
   129	.   inline char* strncpy(char* dst, const char* src, size_t n)
   130	.   {
   131	.     size_t i;
   132	. 
   133	.     for(i= 0; i < n && src[i] != '\0'; i++)
   134	.       dst[i]= src[i];
   135	.     for(; i < n; i++)
   136	.       dst[i]= '\0';
   137	. 
   138	.     return dst;
   139	.   }
   140	. }
   141	. 
   142	. #endif
FILE: END: inc/stdlib.hh
FILE: START: inc/string_view.hh
HASH: MD5: c0e476b813dac2cad952b93ed7c85892
     1	. #ifndef _GLIBCXX_STRING_VIEW
     2	. #define _GLIBCXX_STRING_VIEW 1
     3	. 
     4	. namespace str
     5	. {
     6	. #define min(x,y) (y<x?y:x)
     7	.   void __xassert(bool val, const char *cont);
     8	. #define xassert(x) __xassert((x),#x)
     9	. 
    10	.   void exit(int res) __attribute__ ((__noreturn__));
    11	.   inline void abort() __attribute__ ((__noreturn__));
    12	.   inline void abort() { asm("int3"); exit(1); };
    13	.   typedef unsigned long size_t;
    14	.   class string_view
    15	.   {
    16	.   public:
    17	.     // types
    18	.     typedef char                    _CharT;
    19	.     typedef char                    value_type;
    20	. 
    21	.     using pointer                  = const _CharT*;
    22	.     using const_pointer            = const _CharT*;
    23	.     using reference                = const _CharT&;
    24	.     using const_reference          = const _CharT&;
    25	.     using const_iterator           = const _CharT*;
    26	.     using iterator                 = const_iterator;
    27	. //    using const_reverse_iterator   = reverse_iterator<const_iterator>;
    28	. //    using reverse_iterator         = const_reverse_iterator;
    29	.     typedef size_t size_type;
    30	.     typedef long difference_type;
    31	.     static constexpr size_type npos= size_type(-1);
    32	. 
    33	.     // [string.view.cons], construct/copy
    34	. 
    35	.     constexpr string_view() noexcept
    36	.         : _M_len{ 0 }
    37	.         , _M_str{ nullptr }
    38	.     {
    39	.     }
    40	. 
    41	.     constexpr string_view(const string_view&) noexcept=
    42	.              default;
    43	. 
    44	.     static size_t strlen(const char*str)
    45	.     {
    46	.       const char *pos(str);
    47	.       while(*pos)
    48	.         ++pos;
    49	.       return pos-str;
    50	.     };
    51	.     constexpr string_view(const _CharT* __str) noexcept
    52	.         : _M_len{ __str == nullptr ? 0 : strlen(__str) }
    53	.         , _M_str{ __str }
    54	.     {
    55	.     }
    56	. 
    57	.     constexpr string_view(const _CharT* __str,
    58	.                                 size_type     __len) noexcept
    59	.         : _M_len{ __len }
    60	.         , _M_str{ __str }
    61	.     {
    62	.     }
    63	. 
    64	.     constexpr string_view& operator      =(
    65	.              const string_view&) noexcept= default;
    66	. 
    67	.     // [string.view.iterators], iterators
    68	. 
    69	.     constexpr const_iterator begin() const noexcept
    70	.     {
    71	.       return this->_M_str;
    72	.     }
    73	. 
    74	.     constexpr const_iterator end() const noexcept
    75	.     {
    76	.       return this->_M_str + this->_M_len;
    77	.     }
    78	. 
    79	.     constexpr const_iterator cbegin() const noexcept
    80	.     {
    81	.       return this->_M_str;
    82	.     }
    83	. 
    84	.     constexpr const_iterator cend() const noexcept
    85	.     {
    86	.       return this->_M_str + this->_M_len;
    87	.     }
    88	. #if 0
    89	.     constexpr const_reverse_iterator rbegin() const noexcept
    90	.     {
    91	.       return const_reverse_iterator(this->end());
    92	.     }
    93	. 
    94	.     constexpr const_reverse_iterator rend() const noexcept
    95	.     {
    96	.       return const_reverse_iterator(this->begin());
    97	.     }
    98	. 
    99	.     constexpr const_reverse_iterator crbegin() const noexcept
   100	.     {
   101	.       return const_reverse_iterator(this->end());
   102	.     }
   103	. 
   104	.     constexpr const_reverse_iterator crend() const noexcept
   105	.     {
   106	.       return const_reverse_iterator(this->begin());
   107	.     }
   108	. 
   109	.     // [string.view.capacity], capacity
   110	. #endif
   111	.     constexpr size_type size() const noexcept
   112	.     {
   113	.       return this->_M_len;
   114	.     }
   115	. 
   116	.     constexpr size_type length() const noexcept
   117	.     {
   118	.       return _M_len;
   119	.     }
   120	. 
   121	.     constexpr size_type max_size() const noexcept
   122	.     {
   123	.       return (npos - sizeof(size_type) - sizeof(void*)) /
   124	.              sizeof(value_type) / 4;
   125	.     }
   126	. 
   127	.     [[nodiscard]] constexpr bool empty() const noexcept
   128	.     {
   129	.       return this->_M_len == 0;
   130	.     }
   131	. 
   132	.     // [string.view.access], element access
   133	. 
   134	.     constexpr const _CharT& operator[](size_type __pos) const noexcept
   135	.     {
   136	.       // TODO: Assert to restore in a way compatible with the constexpr.
   137	.       // __glibcxx_assert(__pos < this->_M_len);
   138	.       return *(this->_M_str + __pos);
   139	.     }
   140	. 
   141	.     constexpr const _CharT& at(size_type __pos) const
   142	.     {
   143	.       return *(this->_M_str + __pos);
   144	.     }
   145	. 
   146	.     constexpr const _CharT& front() const noexcept
   147	.     {
   148	.       // TODO: Assert to restore in a way compatible with the constexpr.
   149	.       // __glibcxx_assert(this->_M_len > 0);
   150	.       return *this->_M_str;
   151	.     }
   152	. 
   153	.     constexpr const _CharT& back() const noexcept
   154	.     {
   155	.       // TODO: Assert to restore in a way compatible with the constexpr.
   156	.       // __glibcxx_assert(this->_M_len > 0);
   157	.       return *(this->_M_str + this->_M_len - 1);
   158	.     }
   159	. 
   160	.     constexpr const _CharT* data() const noexcept
   161	.     {
   162	.       return this->_M_str;
   163	.     }
   164	. 
   165	.     // [string.view.modifiers], modifiers:
   166	. 
   167	.     constexpr void remove_prefix(size_type __n) noexcept
   168	.     {
   169	.       this->_M_str+= __n;
   170	.       this->_M_len-= __n;
   171	.     }
   172	. 
   173	.     constexpr void remove_suffix(size_type __n) noexcept
   174	.     {
   175	.       this->_M_len-= __n;
   176	.     }
   177	. 
   178	.     constexpr void swap(string_view& __sv) noexcept
   179	.     {
   180	.       auto __tmp= *this;
   181	.       *this     = __sv;
   182	.       __sv      = __tmp;
   183	.     }
   184	. 
   185	. 
   186	.     // [string.view.ops], string operations:
   187	. 
   188	.     constexpr string_view substr(size_type __pos= 0,
   189	.                                        size_type __n  = npos) const
   190	.              noexcept(false)
   191	.     {
   192	.       __pos                 = _M_check(__pos, "string_view::substr");
   193	.       const size_type __rlen= min(__n, _M_len - __pos);
   194	.       return string_view{ _M_str + __pos, __rlen };
   195	.     }
   196	. 
   197	.     static constexpr int compare(const char *lb, const char *rb, size_t n)
   198	.     {
   199	.       auto le(lb+n);
   200	.       while(lb!=le)
   201	.       {
   202	.         int res(*lb-*rb);
   203	.         if(res)
   204	.           return res;
   205	.         ++lb; ++rb;
   206	.       };
   207	.       return 0;
   208	.     };
   209	.     static constexpr int compare(long lhs, long rhs)
   210	.     {
   211	.       return (rhs-lhs);
   212	.     };
   213	.     constexpr int compare(string_view __str) const noexcept
   214	.     {
   215	.       const size_type __rlen= min(this->_M_len, __str._M_len);
   216	. 
   217	.       int __ret= compare(this->_M_str, __str._M_str, __rlen);
   218	.       if(__ret == 0)
   219	.         __ret= compare(this->_M_len, __str._M_len);
   220	.       return __ret;
   221	.     }
   222	. 
   223	.     constexpr int compare(size_type         __pos1,
   224	.                           size_type         __n1,
   225	.                           string_view __str) const
   226	.     {
   227	.       return this->substr(__pos1, __n1).compare(__str);
   228	.     }
   229	. 
   230	.     constexpr int compare(size_type         __pos1,
   231	.                           size_type         __n1,
   232	.                           string_view __str,
   233	.                           size_type         __pos2,
   234	.                           size_type         __n2) const
   235	.     {
   236	.       return this->substr(__pos1, __n1)
   237	.                .compare(__str.substr(__pos2, __n2));
   238	.     }
   239	. 
   240	.     constexpr int compare(const _CharT* __str) const noexcept
   241	.     {
   242	.       return this->compare(string_view{ __str });
   243	.     }
   244	. 
   245	.     constexpr int compare(size_type     __pos1,
   246	.                           size_type     __n1,
   247	.                           const _CharT* __str) const
   248	.     {
   249	.       return this->substr(__pos1, __n1)
   250	.                .compare(string_view{ __str });
   251	.     }
   252	. 
   253	.     constexpr int compare(size_type     __pos1,
   254	.                           size_type     __n1,
   255	.                           const _CharT* __str,
   256	.                           size_type     __n2) const noexcept(false)
   257	.     {
   258	.       return this->substr(__pos1, __n1)
   259	.                .compare(string_view(__str, __n2));
   260	.     }
   261	. 
   262	.     static size_type length(const char *str)
   263	.     {
   264	.       const char *beg(str);
   265	.       while(*str)
   266	.         ++str;
   267	.       return str-beg;
   268	.     };
   269	. 
   270	.     constexpr size_type find(string_view v, size_type p) const
   271	.     {
   272	.       if(v.size()>size())
   273	.         return npos;
   274	.       size_type n(size()-v.size());
   275	.       for(size_type i=p;i<n;i++)
   276	.       {
   277	.         if(!string_view(_M_str,v.size()).compare(v))
   278	.           return i;
   279	.       };
   280	.       return npos;
   281	.     };
   282	. #if 0
   283	.     constexpr size_type rfind(string_view __str,
   284	.                               size_type         __pos= npos) const noexcept
   285	.     {
   286	.       return this->rfind(__str._M_str, __pos, __str._M_len);
   287	.     }
   288	. 
   289	.     constexpr size_type rfind(_CharT    __c,
   290	.                               size_type __pos= npos) const noexcept;
   291	. 
   292	.     constexpr size_type rfind(const _CharT* __str,
   293	.                               size_type     __pos,
   294	.                               size_type     __n) const noexcept;
   295	. 
   296	.     constexpr size_type rfind(const _CharT* __str,
   297	.                               size_type     __pos= npos) const noexcept
   298	.     {
   299	.       return this->rfind(__str, __pos, length(__str));
   300	.     }
   301	. 
   302	.     constexpr size_type find_first_of(string_view __str,
   303	.                                       size_type __pos= 0) const noexcept
   304	.     {
   305	.       return this->find_first_of(__str._M_str, __pos, __str._M_len);
   306	.     }
   307	. #endif
   308	.     constexpr size_type find(char c, size_type p) const noexcept
   309	.     {
   310	.       const size_type n(size());
   311	.       for(size_type i(p);i<n;i++) {
   312	.         if(_M_str[i]==c)
   313	.           return i;
   314	.       };
   315	.       return npos;
   316	.     };
   317	. #if 0
   318	.     constexpr size_type find_first_of(_CharT    __c,
   319	.                                       size_type __pos= 0) const noexcept
   320	.     {
   321	.       return this->find(__c, __pos);
   322	.     }
   323	. 
   324	.     constexpr size_type find_first_of(const _CharT* __str,
   325	.                                       size_type     __pos,
   326	.                                       size_type     __n) const noexcept;
   327	. 
   328	.     constexpr size_type find_first_of(const _CharT* __str,
   329	.                                       size_type __pos= 0) const noexcept
   330	.     {
   331	.       return this->find_first_of(__str, __pos, length(__str));
   332	.     }
   333	. 
   334	.     constexpr size_type find_last_of(string_view __str,
   335	.                                      size_type __pos= npos) const noexcept
   336	.     {
   337	.       return this->find_last_of(__str._M_str, __pos, __str._M_len);
   338	.     }
   339	. 
   340	.     constexpr size_type find_last_of(_CharT    __c,
   341	.                                      size_type __pos= npos) const noexcept
   342	.     {
   343	.       return this->rfind(__c, __pos);
   344	.     }
   345	. 
   346	.     constexpr size_type find_last_of(const _CharT* __str,
   347	.                                      size_type     __pos,
   348	.                                      size_type     __n) const noexcept;
   349	. 
   350	.     constexpr size_type find_last_of(const _CharT* __str,
   351	.                                      size_type __pos= npos) const noexcept
   352	.     {
   353	.       return this->find_last_of(__str, __pos, length(__str));
   354	.     }
   355	. 
   356	.     constexpr size_type find_first_not_of(
   357	.              string_view __str, size_type __pos= 0) const noexcept
   358	.     {
   359	.       return this->find_first_not_of(__str._M_str, __pos, __str._M_len);
   360	.     }
   361	. 
   362	.     constexpr size_type find_first_not_of(
   363	.              _CharT __c, size_type __pos= 0) const noexcept;
   364	. 
   365	.     constexpr size_type find_first_not_of(const _CharT* __str,
   366	.                                           size_type     __pos,
   367	.                                           size_type __n) const noexcept;
   368	. 
   369	.     constexpr size_type find_first_not_of(
   370	.              const _CharT* __str, size_type __pos= 0) const noexcept
   371	.     {
   372	.       return this->find_first_not_of(
   373	.                __str, __pos, length(__str));
   374	.     }
   375	. 
   376	.     constexpr size_type find_last_not_of(
   377	.              string_view __str, size_type __pos= npos) const noexcept
   378	.     {
   379	.       return this->find_last_not_of(__str._M_str, __pos, __str._M_len);
   380	.     }
   381	. 
   382	.     constexpr size_type find_last_not_of(
   383	.              _CharT __c, size_type __pos= npos) const noexcept;
   384	. 
   385	.     constexpr size_type find_last_not_of(const _CharT* __str,
   386	.                                          size_type     __pos,
   387	.                                          size_type     __n) const noexcept;
   388	. 
   389	.     constexpr size_type find_last_not_of(
   390	.              const _CharT* __str, size_type __pos= npos) const noexcept
   391	.     {
   392	.       return this->find_last_not_of(
   393	.                __str, __pos, length(__str));
   394	.     }
   395	. #endif
   396	.     constexpr size_type _M_check(size_type __pos, const char* __s) const
   397	.              noexcept(false)
   398	.     {
   399	.       if(__pos > this->size())
   400	.         abort();
   401	.       return __pos;
   402	.     }
   403	.     // NB: _M_limit doesn't check for a bad __pos value.
   404	.     constexpr size_type _M_limit(size_type __pos,
   405	.                                  size_type __off) const noexcept
   406	.     {
   407	.       const bool __testoff= __off < this->size() - __pos;
   408	.       return __testoff ? __off : this->size() - __pos;
   409	.     }
   410	.   private:
   411	. 
   412	.     size_t        _M_len;
   413	.     const _CharT* _M_str;
   414	.   };
   415	. 
   416	.   // [string.view.comparison], non-member string_view comparison
   417	.   // function
   418	. 
   419	.   constexpr bool operator==(
   420	.            string_view __x, string_view __y) noexcept
   421	.   {
   422	.     return __x.size() == __y.size() && __x.compare(__y) == 0;
   423	.   }
   424	. 
   425	. #if 0
   426	.   template <typename _CharT, typename _Traits>
   427	.   constexpr bool operator==(
   428	.            string_view __x,
   429	.            string_view
   430	.                     __y) noexcept
   431	.   {
   432	.     return __x.size() == __y.size() && __x.compare(__y) == 0;
   433	.   }
   434	.   template <typename _CharT, typename _Traits>
   435	.   constexpr bool operator==(
   436	.            string_view __x,
   437	.            string_view __y) noexcept
   438	.   {
   439	.     return __x.size() == __y.size() && __x.compare(__y) == 0;
   440	.   }
   441	. #endif
   442	. 
   443	.   constexpr bool operator!=(
   444	.            string_view __x,
   445	.            string_view __y) noexcept
   446	.   {
   447	.     return !(__x == __y);
   448	.   }
   449	. 
   450	. 
   451	.   constexpr bool operator<(string_view __x,
   452	.                            string_view __y) noexcept
   453	.   {
   454	.     return __x.compare(__y) < 0;
   455	.   }
   456	. 
   457	. 
   458	. 
   459	.   constexpr bool operator>(string_view __x,
   460	.                            string_view __y) noexcept
   461	.   {
   462	.     return __x.compare(__y) > 0;
   463	.   }
   464	. 
   465	. 
   466	. 
   467	.   constexpr bool operator<=(
   468	.            string_view __x,
   469	.            string_view __y) noexcept
   470	.   {
   471	.     return __x.compare(__y) <= 0;
   472	.   }
   473	. 
   474	. 
   475	.   constexpr bool operator>=(
   476	.            string_view __x,
   477	.            string_view __y) noexcept
   478	.   {
   479	.     return __x.compare(__y) >= 0;
   480	.   }
   481	. 
   482	. } // namespace str
   483	. 
   484	. 
   485	. #endif // _GLIBCXX_EXPERIMENTAL_STRING_VIEW
FILE: END: inc/string_view.hh
FILE: START: inc/syscall.hh
HASH: MD5: 713f3560bfd3791b386d827516d398c1
     1	. #ifndef syscall_hh
     2	. #define syscall_hh syscall_hh
     3	. 
     4	. #include <errno.hh>
     5	. #include <types.hh>
     6	. 
     7	. #if 1
     8	. #define AAI __attribute__((__always_inline__))
     9	. #define NOR  __attribute__((__noreturn__))
    10	. #else
    11	. #define AAI
    12	. #endif
    13	. 
    14	. namespace sys
    15	. {
    16	. #define linux_dirent64 linux_dirent
    17	.   enum open_mode
    18	.   {
    19	.     o_default= 0664
    20	.   };
    21	.   enum open_flags
    22	.   {
    23	.     o_rdonly   = 0000,
    24	.     o_wronly   = 0001,
    25	.     o_rdwr     = 0002,
    26	.     o_mask     = 0003,
    27	.     o_creat    = 00000100,
    28	.     o_excl     = 00000200,
    29	.     o_noctty   = 00000400,
    30	.     o_trunc    = 00001000,
    31	.     o_append   = 00002000,
    32	.     o_nonblock = 00004000,
    33	.     o_dsync    = 00010000,
    34	.     o_fasync   = 00020000,
    35	.     o_direct   = 00040000,
    36	.     o_largefile= 00100000,
    37	.     o_directory= 00200000,
    38	.     o_nofollow = 00400000,
    39	.     o_noatime  = 01000000,
    40	.     o_cloexec  = 02000000,
    41	.   };
    42	.   inline open_flags operator|(open_flags lhs, open_flags rhs)
    43	.   {
    44	.     return open_flags(int(lhs) | int(rhs));
    45	.   }
    46	.   inline open_flags operator&(open_flags lhs, open_flags rhs)
    47	.   {
    48	.     return open_flags(int(lhs) & int(rhs));
    49	.   }
    50	. } // namespace sys
    51	. 
    52	. #include <stdlib.hh>
    53	. #define chk_return2(val, cast)                                            \
    54	.   return (cast)(val < 0 ? set_errno(val) : val)
    55	. #define chk_return(val) return (val < 0 ? set_errno(val) : val)
    56	. namespace sys
    57	. {
    58	.   extern "C"
    59	.   {
    60	.     inline int     nanosleep(timespec_p rqtp, timespec_p rmtp) AAI;
    61	.     inline int     close(fd_t fd) AAI;
    62	.     inline int     stat(const char* pathname, struct stat* statbuf) AAI;
    63	.     inline fd_t    open(const char* pathname,
    64	.                         open_flags  flags,
    65	.                         open_mode   mode) AAI;
    66	.     inline time_t  time(time_t*) AAI;
    67	.     inline ssize_t getdents(fd_t fd, linux_dirent64* buf, size_t len) AAI;
    68	.     inline ssize_t read(fd_t fd, char* buf, size_t len) AAI;
    69	.     inline ssize_t sys_write(fd_t fd, const char* buf, size_t len) AAI;
    70	.   }
    71	.   inline void    exit(int res) NOR;
    72	. 
    73	.   // __NR_read=0
    74	.   inline ssize_t read(fd_t fd, char* buf, size_t len)
    75	.   {
    76	.     long res;
    77	.     asm("syscall"
    78	.         : "=a"(res)
    79	.         : "a"(0), "D"(fd), "S"(buf), "d"(len)
    80	.         : "rcx", "r11", "memory");
    81	.     chk_return(res);
    82	.   }
    83	.   // __NR_write=1
    84	.   inline ssize_t sys_write(fd_t fd, const char* buf, size_t len)
    85	.   {
    86	.     long res;
    87	.     if(!buf) {
    88	.       buf="<null>";
    89	.       len=6;
    90	.     };
    91	.     asm("syscall\n"
    92	.         : "=a"(res)
    93	.         : "a"(1), "D"(fd), "S"(buf), "d"(len)
    94	.         : "rcx", "r11", "memory");
    95	.     chk_return(res);
    96	.   }
    97	.   // __NR_open=2
    98	.   inline fd_t open(const char* pathname,
    99	.                    open_flags  flags,
   100	.                    open_mode   mode= o_default)
   101	.   {
   102	.     int fd= -1;
   103	.     asm("syscall\n"
   104	.         : "=a"(fd)
   105	.         : "0"(2), "D"(pathname), "S"(flags), "d"(mode)
   106	.         : "rcx", "r11", "memory");
   107	.     chk_return(fd);
   108	.   }
   109	.   // __NR_close=3
   110	.   inline int close(fd_t fd)
   111	.   {
   112	.     asm("syscall\n"
   113	.         : "=a"(fd) 
   114	.         : "0"(3), "D"(fd) 
   115	.         : "rcx", "r11", "memory");
   116	.     chk_return(fd);
   117	.   }
   118	.   // __NR_stat=4
   119	.   inline int stat(const char* pathname, struct stat* statbuf)
   120	.   {
   121	.     int res= -1;
   122	.     asm("syscall\n"
   123	.         : "=a"(res)
   124	.         : "a"(4), "D"(pathname), "S"(statbuf)
   125	.         : "rcx", "r11", "memory");
   126	.     chk_return(res);
   127	.   }
   128	.   // __NR__ lseek = 8
   129	.   // inline int lseek(fd_t fd, off_t offset, unsigned origin)
   130	.   enum origin_t
   131	.   {
   132	.     set= 0,
   133	.     cur= 1,
   134	.     end= 2
   135	.   };
   136	.   inline off_t lseek(fd_t fd, off_t off, origin_t origin)
   137	.   {
   138	.     off_t res;
   139	.     asm("syscall\n"
   140	.         : "=a"(res)
   141	.         : "0"(8), "D"(fd), "S"(off), "d"(origin)
   142	.         : "rcx", "r11", "memory");
   143	.     chk_return(res);
   144	.   }
   145	. 
   146	. 
   147	.   enum mmap_prot_t
   148	.   {
   149	.     // For MMAP.
   150	.     prot_none = 0x0,
   151	.     prot_read = 0x1,
   152	.     prot_write= 0x2,
   153	.     prot_exec = 0x4,
   154	.   };
   155	. 
   156	. 
   157	.   enum mmap_flag_t
   158	.   {
   159	.     map_private  = 0x02,
   160	.     map_shared   = 0x01,
   161	.     map_fixed    = 0x10,
   162	.     map_anon     = 0x20,
   163	.     map_anonymous= map_anon,
   164	.     map_growsdown= 0x00100,
   165	.     map_noreserve= 0x04000,
   166	.     map_nonblock = 0x10000,
   167	.     map_populate = 0x08000,
   168	.     map_stack    = 0x20000,
   169	.   };
   170	.   // __NR_mmap=9
   171	.   inline char* mmap(void*  addr,
   172	.                     size_t length,
   173	.                     int    prot,
   174	.                     int    flags,
   175	.                     fd_t   fd,
   176	.                     off_t  off)
   177	.   {
   178	. 
   179	.     uint64_t res;
   180	. 
   181	.     __asm__ volatile(
   182	.              "\tmovq %5,%%r10 ;\n"
   183	.              "\tmovq %6,%%r8 ;\n"
   184	.              "\tmovq %7, %%r9; \n"
   185	.              "\tsyscall;\n"
   186	.              : "=a"(res)
   187	.              : "0"(9),
   188	.                "D"(addr),
   189	.                "S"(length),
   190	.                "d"(prot),
   191	.                "g"(flags),
   192	.                "g"(long(fd)),
   193	.                "g"(long(off))
   194	.              : "r11", "rcx", "memory", "r10", "r8", "r9");
   195	. 
   196	.     chk_return2(res, char*);
   197	.   }
   198	.   // __NR_sigaction = 13
   199	.   inline int rt_sigaction(int sig, sigaction_p act, sigaction_p oact)
   200	.   {
   201	. 
   202	.     uint64_t res;
   203	. 
   204	.     asm("\tmovq %5,%%r10 ;\n"
   205	.         "\tsyscall;\n"
   206	.         : "=a"(res)
   207	.         : "0"(13), "D"(sig), "S"(act), "d"(oact), "g"(sizeof(sigset_t))
   208	.         : "r11", "rcx", "memory");
   209	. 
   210	.     chk_return(res);
   211	.   }
   212	.   // __NR_sigprocmask=14
   213	.   inline int rt_sigprocmask(int how, sigset_p nset, sigset_p oset)
   214	.   {
   215	.     int res= -1;
   216	.     asm("\tmovq %5,%%r10 ;\n"
   217	.         "\tsyscall;\n"
   218	.         : "=a"(res)
   219	.         : "0"(14), "D"(how), "S"(nset), "d"(oset), "g"(sizeof(sigset_t))
   220	.         : "r11", "rcx", "memory");
   221	. 
   222	.     chk_return(res);
   223	.   }
   224	.   // __NR_sigreturn=15
   225	.   inline void rt_sigreturn()
   226	.   {
   227	.     int res= -1;
   228	.     asm("syscall\n" : "=a"(res) : "0"(15) : "rcx", "r11", "memory");
   229	.     if(res < 0)
   230	.       set_errno(res);
   231	.   }
   232	.   // __NR__ pipe = 22 
   233	. 
   234	.   inline int pipe(fd_p fds)
   235	.   {
   236	.     time_t res= -1;
   237	.     asm("syscall\n"
   238	.         : "=a"(res)
   239	.         : "a"(22), "D"(fds)
   240	.         : "rcx", "r11", "memory");
   241	.     chk_return(res);
   242	.   }
   243	.   //     }
   244	.   //     inline char *mmap(
   245	.   //         void *addr, size_t length, int prot, int flags, fd_t fd, off_t
   246	.   //         off
   247	.   //         )
   248	.   // __NR__ select = 23
   249	.   inline int select(int       n,
   250	.                     fd_set_p  inp,
   251	.                     fd_set_p  outp,
   252	.                     fd_set_p  exp,
   253	.                     timeval_p tvp= 0)
   254	.   {
   255	. 
   256	.     uint64_t res;
   257	. 
   258	.     __asm__ volatile(
   259	.              "\tsyscall;\n"
   260	.              : "=a"(res)
   261	.              : "0"(23), "D"(n), "S"(inp), "d"(outp), "g"(exp), "g"(tvp)
   262	.              : "rcx", "memory", "r8", "r9");
   263	. 
   264	.     chk_return(res);
   265	.   }
   266	. 
   267	.   // __NR_dup = 32
   268	.   inline int dup(fd_t fd)
   269	.   {
   270	.     int res= -1;
   271	.     asm("syscall\n"
   272	.         : "=a"(res)
   273	.         : "0"(32), "D"(fd)
   274	.         : "rcx", "r11", "memory");
   275	.     chk_return(res);
   276	.   }
   277	. 
   278	.   // __NR_dup = 33
   279	.   inline int dup2(fd_t ofd, fd_t nfd)
   280	.   {
   281	.     int res= -1;
   282	.     asm("syscall\n"
   283	.         : "=a"(res)
   284	.         : "a"(33), "D"(ofd), "S"(nfd)
   285	.         : "rcx", "r11", "memory");
   286	.     chk_return(res);
   287	.   }
   288	.   // __NR_nanosleep = 35
   289	.   inline int nanosleep(timespec_p rqtp, timespec_p rmtp)
   290	.   {
   291	.     uint64_t res= 0xfeebdaed;
   292	.     asm("\tsyscall;\n"
   293	.         : "=a"(res)
   294	.         : "0"(35), "D"(rqtp), "S"(rmtp)
   295	.         : "rcx", "r11", "memory");
   296	.     chk_return(res);
   297	.   }
   298	. 
   299	.   inline int sleep(time_t secs)
   300	.   {
   301	.     uint64_t res= 0xfeebdaed;
   302	.     timespec_t rqtp, rmtp;
   303	. 
   304	.     rqtp.tv_sec=secs;
   305	.     rqtp.tv_nsec=0;
   306	.     rmtp.tv_sec=0;
   307	.     rmtp.tv_nsec=0;
   308	.     asm("\tsyscall;\n"
   309	.         : "=a"(res)
   310	.         : "0"(35), "D"(&rqtp), "S"(&rmtp)
   311	.         : "rcx", "r11", "memory");
   312	.     chk_return(res);
   313	.   }
   314	.   // __NR_alarm = 37
   315	.   inline int alarm(unsigned long delay)
   316	.   {
   317	.     int res= -1;
   318	.     asm("syscall\n"
   319	.         : "=a"(res)
   320	.         : "0"(37), "D"(delay)
   321	.         : "rcx", "r11", "memory");
   322	.     chk_return(res);
   323	.   }
   324	.   // __NR_getpid = 39
   325	.   inline int getpid()
   326	.   {
   327	.     int res= -1;
   328	.     asm("syscall\n" : "=a"(res) : "0"(39) : "rcx", "r11", "memory");
   329	.     chk_return(res);
   330	.   }
   331	.   // __NR__ fork = 57 
   332	.   inline int fork()
   333	.   {
   334	.     int res= -1;
   335	.     asm("syscall\n" : "=a"(res) : "0"(57) : "rcx", "r11", "memory");
   336	.     chk_return(res);
   337	.   }
   338	.   // __NO__ execve = 59
   339	.   inline int execve(const char * fn, char *const * argv, char *const * envp)
   340	.   {
   341	.     long res;
   342	.     asm("syscall"
   343	.         : "=a"(res)
   344	.         : "a"(59), "D"(fn), "S"(argv), "d"(envp)
   345	.         : "rcx", "r11", "memory");
   346	.     chk_return(res);
   347	. 
   348	.   }
   349	.   // __NR_exit = 60
   350	.   inline void exit(int res)
   351	.   {
   352	.     int exit_val;
   353	.     exit_val= res & 0xff;
   354	.     asm("syscall\n"
   355	.         : "=a"(res)
   356	.         : "a"(60), "D"(exit_val)
   357	.         : "rcx", "r11", "memory");
   358	.     while(1)
   359	.       sleep(1);
   360	.   }
   361	. 
   362	.   // __NR__ wait4 = 61 
   363	. 
   364	.   inline int wait4(pid_t upid, int32_p stat_p, int opt, rusage_p ru)
   365	.   {
   366	. 
   367	.     uint64_t res;
   368	. 
   369	.     __asm__ volatile(
   370	.              "\tsyscall;\n"
   371	.              : "=a"(res)
   372	.              : "0"(61), "D"(upid), "S"(stat_p), "d"(opt), "g"(ru)
   373	.              : "rcx", "memory", "r8", "r9");
   374	. 
   375	.     chk_return(res);
   376	.   }
   377	.   inline int waitpid(pid_t pid, int32_p wstat, int opt)
   378	.   {
   379	.     return wait4(pid,wstat,opt,NULL);
   380	.   }
   381	.   inline int wait(int32_p wstat)
   382	.   {
   383	.     return waitpid(-1,wstat,0);
   384	.   }
   385	. 
   386	.   // __NR__ kill=62
   387	.   inline int kill(pid_t pid, int sig)
   388	.   {
   389	.     uint64_t res= 0xfeebdaed;
   390	.     asm("\tsyscall;\n"
   391	.         : "=a"(res)
   392	.         : "0"(62), "D"(pid), "S"(sig)
   393	.         : "rcx", "r11", "memory");
   394	.     chk_return(res);
   395	.   }
   396	. 
   397	.   // __NR__ uname = 63 
   398	. 
   399	.   inline int uname(utsname_p name)
   400	.   {
   401	.     time_t res= -1;
   402	.     asm("syscall\n"
   403	.         : "=a"(res)
   404	.         : "a"(63), "D"(name)
   405	.         : "rcx", "r11", "memory");
   406	.     chk_return(res);
   407	.   }
   408	. 
   409	.   // __NR__ rename = 82
   410	.   inline int rename(istr_t oldname, istr_t newname)
   411	.   {
   412	.     uint64_t res= 0xfeebdaed;
   413	.     asm("\tsyscall;\n"
   414	.         : "=a"(res)
   415	.         : "0"(82), "D"(oldname), "S"(newname)
   416	.         : "rcx", "r11", "memory");
   417	.     chk_return(res);
   418	.   }
   419	.   //#define __NR_time 201
   420	.   inline time_t time(time_t* buf)
   421	.   {
   422	.     time_t res= -1;
   423	.     asm("syscall\n"
   424	.         : "=a"(res)
   425	.         : "a"(201), "D"(buf)
   426	.         : "rcx", "r11", "memory");
   427	.     chk_return(res);
   428	.   }
   429	.   // __NR_getdents = 217
   430	.   inline ssize_t getdents(fd_t fd, linux_dirent64* buf, size_t len)
   431	.   {
   432	.     long res;
   433	.     asm("syscall"
   434	.         : "=a"(res)
   435	.         : "a"(217), "D"(fd), "S"(buf), "d"(len)
   436	.         : "rcx", "r11", "memory");
   437	.     chk_return(res);
   438	.   }
   439	.   // __NR__ pipe2 = 293 
   440	. 
   441	.   inline int pipe2(fd_p fds, int flags)
   442	.   {
   443	.     uint64_t res= 0xfeebdaed;
   444	.     asm("\tsyscall;\n"
   445	.         : "=a"(res)
   446	.         : "0"(293), "D"(fds), "S"(flags)
   447	.         : "rcx", "r11", "memory");
   448	.     chk_return(res);
   449	.   }
   450	. } // namespace sys
   451	. 
   452	. namespace sys
   453	. {
   454	. 
   455	.   inline ssize_t write(int fd, const char* buf, size_t len) AAI;
   456	.   inline ssize_t write(int fd, const char* buf, const char* end) AAI;
   457	.   inline ssize_t write(fd_t fd, const char* buf) AAI;
   458	. 
   459	.   inline ssize_t write(int fd, const char* buf, size_t len)
   460	.   {
   461	.     return sys_write(fd, buf, len);
   462	.   }
   463	.   inline ssize_t write(int fd, const char* buf, const char* end)
   464	.   {
   465	.     return sys_write(fd, buf, end - buf);
   466	.   }
   467	. 
   468	.   inline ssize_t write(fd_t fd, const char* buf)
   469	.   {
   470	.     const char* end= buf;
   471	.     while(*end)
   472	.       ++end;
   473	.     return sys_write(fd, buf, end - buf);
   474	.   }
   475	. 
   476	.   inline ssize_t full_write(int fd, const char* const beg, size_t len)
   477	.     AAI;
   478	.   inline const char* full_write(int               fd,
   479	.                                 const char* const beg,
   480	.                                 const char*       end)
   481	.     AAI;
   482	. 
   483	.   inline const char* full_write(int               fd,
   484	.                                 const char* const beg,
   485	.                                 const char*       end)
   486	.   {
   487	.     const char* pos= beg;
   488	.     while(pos != end)
   489	.     {
   490	.       ssize_t res= sys_write(fd, pos, end - pos);
   491	.       if(res < 0)
   492	.         return nullptr;
   493	.       pos+= res;
   494	.     }
   495	.     return pos;
   496	.   }
   497	.   inline ssize_t full_write(int fd, const char* const beg, size_t len)
   498	.   {
   499	.     return full_write(fd, beg, beg + len) - beg;
   500	.   }
   501	. } // namespace sys
   502	. 
   503	. #define L(x) x, sizeof(x) - 1
   504	. 
   505	. 
   506	. namespace std
   507	. {
   508	.   void        abort() __attribute__((__noreturn__));
   509	.   inline void abort()
   510	.   {
   511	.     do
   512	.     {
   513	.       asm("int3");
   514	.     } while(true);
   515	.   }
   516	.   void terminate() noexcept __attribute__((__noreturn__));
   517	.   using ::free;
   518	.   using ::malloc;
   519	.   using ::memset;
   520	.   using ::realloc;
   521	.   using ::size_t;
   522	.   enum nothrow_t
   523	.   {
   524	.   };
   525	.   extern const nothrow_t nothrow;
   526	.   typedef void (*new_handler)();
   527	. }
   528	. extern "C"
   529	. {
   530	.   void        abort() __attribute__((__noreturn__));
   531	.   inline void abort()
   532	.   {
   533	.     do
   534	.     {
   535	.       asm("int3");
   536	.     } while(true);
   537	.   }
   538	. }
   539	. 
   540	. #undef AAI
   541	. #define _GLIBCXX_NOEXCEPT noexcept
   542	. #ifndef _GLIBCXX_NOTHROW
   543	. #define _GLIBCXX_NOTHROW
   544	. #endif
   545	. #endif
FILE: END: inc/syscall.hh
FILE: START: inc/tinfo.hh
HASH: MD5: a60dcbe2960222aa5c9adfb7e5ad36f2
     1	. // RTTI support internals for -*- C++ -*-
     2	. // Copyright (C) 1994-2019 Free Software Foundation, Inc.
     3	. 
     4	. // This file is part of GCC.
     5	. //
     6	. // GCC is free software; you can redistribute it and/or modify
     7	. // it under the terms of the GNU General Public License as published by
     8	. // the Free Software Foundation; either version 3, or (at your option)
     9	. // any later version.
    10	. 
    11	. // GCC is distributed in the hope that it will be useful,
    12	. // but WITHOUT ANY WARRANTY; without even the implied warranty of
    13	. // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    14	. // GNU General Public License for more details.
    15	. 
    16	. // Under Section 7 of GPL version 3, you are granted additional
    17	. // permissions described in the GCC Runtime Library Exception, version
    18	. // 3.1, as published by the Free Software Foundation.
    19	. 
    20	. // You should have received a copy of the GNU General Public License and
    21	. // a copy of the GCC Runtime Library Exception along with this program;
    22	. // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
    23	. // <http://www.gnu.org/licenses/>.
    24	. 
    25	. #include <syscall.hh>
    26	. #include <typeinfo.hh>
    27	. //#include <cstddef>
    28	. 
    29	. // Class declarations shared between the typeinfo implementation files.
    30	. 
    31	. #include <cxxabi.hh>
    32	. 
    33	. namespace __cxxabiv1 {
    34	. 
    35	. namespace {
    36	. 
    37	. using namespace std;
    38	. using namespace abi;
    39	. using std::ptrdiff_t;
    40	. 
    41	. // Initial part of a vtable, this structure is used with offsetof, so we don't
    42	. // have to keep alignments consistent manually.
    43	. struct vtable_prefix 
    44	. {
    45	.   // Offset to most derived object.
    46	.   ptrdiff_t whole_object;
    47	. 
    48	.   // Additional padding if necessary.
    49	. #ifdef _GLIBCXX_VTABLE_PADDING
    50	.   ptrdiff_t padding1;               
    51	. #endif
    52	. 
    53	.   // Pointer to most derived type_info.
    54	.   const __class_type_info *whole_type;  
    55	. 
    56	.   // Additional padding if necessary.
    57	. #ifdef _GLIBCXX_VTABLE_PADDING
    58	.   ptrdiff_t padding2;               
    59	. #endif
    60	. 
    61	.   // What a class's vptr points to.
    62	.   const void *origin;               
    63	. };
    64	. 
    65	. template <typename T>
    66	. inline const T *
    67	. adjust_pointer (const void *base, ptrdiff_t offset)
    68	. {
    69	.   return reinterpret_cast <const T *>
    70	.     (reinterpret_cast <const char *> (base) + offset);
    71	. }
    72	. 
    73	. // ADDR is a pointer to an object.  Convert it to a pointer to a base,
    74	. // using OFFSET. IS_VIRTUAL is true, if we are getting a virtual base.
    75	. inline void const *
    76	. convert_to_base (void const *addr, bool is_virtual, ptrdiff_t offset)
    77	. {
    78	.   if (is_virtual)
    79	.     {
    80	.       const void *vtable = *static_cast <const void *const *> (addr);
    81	.       
    82	.       offset = *adjust_pointer<ptrdiff_t> (vtable, offset);
    83	.     }
    84	. 
    85	.   return adjust_pointer<void> (addr, offset);
    86	. }
    87	. 
    88	. // some predicate functions for __class_type_info::__sub_kind
    89	. inline bool contained_p (__class_type_info::__sub_kind access_path)
    90	. {
    91	.   return access_path >= __class_type_info::__contained_mask;
    92	. }
    93	. inline bool public_p (__class_type_info::__sub_kind access_path)
    94	. {
    95	.   return access_path & __class_type_info::__contained_public_mask;
    96	. }
    97	. inline bool virtual_p (__class_type_info::__sub_kind access_path)
    98	. {
    99	.   return (access_path & __class_type_info::__contained_virtual_mask);
   100	. }
   101	. inline bool contained_public_p (__class_type_info::__sub_kind access_path)
   102	. {
   103	.   return ((access_path & __class_type_info::__contained_public)
   104	.           == __class_type_info::__contained_public);
   105	. }
   106	. inline bool contained_nonpublic_p (__class_type_info::__sub_kind access_path)
   107	. {
   108	.   return ((access_path & __class_type_info::__contained_public)
   109	.           == __class_type_info::__contained_mask);
   110	. }
   111	. inline bool contained_nonvirtual_p (__class_type_info::__sub_kind access_path)
   112	. {
   113	.   return ((access_path & (__class_type_info::__contained_mask
   114	.                           | __class_type_info::__contained_virtual_mask))
   115	.           == __class_type_info::__contained_mask);
   116	. }
   117	. 
   118	. static const __class_type_info *const nonvirtual_base_type =
   119	.     static_cast <const __class_type_info *> (0) + 1;
   120	. 
   121	. } // namespace
   122	. 
   123	. // __upcast_result is used to hold information during traversal of a class
   124	. // hierarchy when catch matching.
   125	. struct __class_type_info::__upcast_result
   126	. {
   127	.   const void *dst_ptr;        // pointer to caught object
   128	.   __sub_kind part2dst;        // path from current base to target
   129	.   int src_details;            // hints about the source type hierarchy
   130	.   const __class_type_info *base_type; // where we found the target,
   131	.                               // if in vbase the __class_type_info of vbase
   132	.                               // if a non-virtual base then 1
   133	.                               // else nullptr
   134	.   __upcast_result (int d)
   135	.     :dst_ptr (nullptr), part2dst (__unknown), src_details (d), base_type (nullptr)
   136	.     {}
   137	. };
   138	. 
   139	. // __dyncast_result is used to hold information during traversal of a class
   140	. // hierarchy when dynamic casting.
   141	. struct __class_type_info::__dyncast_result
   142	. {
   143	.   const void *dst_ptr;        // pointer to target object or nullptr
   144	.   __sub_kind whole2dst;       // path from most derived object to target
   145	.   __sub_kind whole2src;       // path from most derived object to sub object
   146	.   __sub_kind dst2src;         // path from target to sub object
   147	.   int whole_details;          // details of the whole class hierarchy
   148	.   
   149	.   __dyncast_result (int details_ = __vmi_class_type_info::__flags_unknown_mask)
   150	.     :dst_ptr (nullptr), whole2dst (__unknown),
   151	.      whole2src (__unknown), dst2src (__unknown),
   152	.      whole_details (details_)
   153	.     {}
   154	. 
   155	. protected:
   156	.   __dyncast_result(const __dyncast_result&);
   157	.   
   158	.   __dyncast_result&
   159	.   operator=(const __dyncast_result&);
   160	. };
   161	. 
   162	. inline __class_type_info::__sub_kind __class_type_info::
   163	. __find_public_src (ptrdiff_t src2dst,
   164	.                    const void *obj_ptr,
   165	.                    const __class_type_info *src_type,
   166	.                    const void *src_ptr) const
   167	. {
   168	.   if (src2dst >= 0)
   169	.     return adjust_pointer <void> (obj_ptr, src2dst) == src_ptr
   170	.             ? __contained_public : __not_contained;
   171	.   if (src2dst == -2)
   172	.     return __not_contained;
   173	.   return __do_find_public_src (src2dst, obj_ptr, src_type, src_ptr);
   174	. }
   175	. 
   176	. }
FILE: END: inc/tinfo.hh
FILE: START: inc/typeinfo.hh
HASH: MD5: fbbd5bb80c39eadd91d5781d94b50c36
     1	. // RTTI support for -*- C++ -*-
     2	. // Copyright (C) 1994-2019 Free Software Foundation, Inc.
     3	. //
     4	. // This file is part of GCC.
     5	. //
     6	. // GCC is free software; you can redistribute it and/or modify
     7	. // it under the terms of the GNU General Public License as published by
     8	. // the Free Software Foundation; either version 3, or (at your option)
     9	. // any later version.
    10	. //
    11	. // GCC is distributed in the hope that it will be useful,
    12	. // but WITHOUT ANY WARRANTY; without even the implied warranty of
    13	. // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    14	. // GNU General Public License for more details.
    15	. //
    16	. // Under Section 7 of GPL version 3, you are granted additional
    17	. // permissions described in the GCC Runtime Library Exception, version
    18	. // 3.1, as published by the Free Software Foundation.
    19	. 
    20	. // You should have received a copy of the GNU General Public License and
    21	. // a copy of the GCC Runtime Library Exception along with this program;
    22	. // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
    23	. // <http://www.gnu.org/licenses/>.
    24	. 
    25	. /** @file typeinfo
    26	.  *  This is a Standard C++ Library header.
    27	.  */
    28	. 
    29	. #ifndef _TYPEINFO
    30	. #define _TYPEINFO
    31	. 
    32	. #pragma GCC system_header
    33	. #include <syscall.hh>
    34	. // RFP added this ifdef
    35	. #ifdef EXCEPTIONS_ENABLED
    36	. #include <bits/exception.h>
    37	. #endif
    38	. 
    39	. // RFP added this ifdef
    40	. #ifdef USE_HASH_BYTES
    41	. #if __cplusplus >= 201103L
    42	. #include <bits/hash_bytes.h>
    43	. #endif
    44	. #endif
    45	. 
    46	. #pragma GCC visibility push(default)
    47	. 
    48	. extern "C++" {
    49	. 
    50	. 	namespace __cxxabiv1
    51	. 	{
    52	. 		class __class_type_info;
    53	. 	}
    54	. 
    55	. 	namespace std
    56	. 	{
    57	. 		class type_info
    58	. 		{
    59	. 			public:
    60	. 				virtual ~type_info();
    61	. 
    62	. 				const char* name() const
    63	. 				{
    64	. 					return __name[0] == '*' ? __name + 1 : __name;
    65	. 				}
    66	. 
    67	. 				bool before(const type_info& __arg) const ;
    68	. 				bool operator==(const type_info& __arg) const ;
    69	. 
    70	. 				bool operator!=(const type_info& __arg) const 
    71	. 				{ return !operator==(__arg); }
    72	. 
    73	. 				size_t hash_code() const noexcept
    74	. 				{
    75	. 					return reinterpret_cast<size_t>(__name);
    76	. 				}
    77	. 
    78	. 				// Return true if this is a pointer type of some kind
    79	. 				virtual bool __is_pointer_p() const;
    80	. 
    81	. 				// Return true if this is a function type
    82	. 				virtual bool __is_function_p() const;
    83	. 
    84	. 				// Try and catch a thrown type. Store an adjusted pointer to the
    85	. 				// caught type in THR_OBJ. If THR_TYPE is not a pointer type, then
    86	. 				// THR_OBJ points to the thrown object. If THR_TYPE is a pointer
    87	. 				// type, then THR_OBJ is the pointer itself. OUTER indicates the
    88	. 				// number of outer pointers, and whether they were const
    89	. 				// qualified.
    90	. 				virtual bool __do_catch(const type_info *__thr_type, void **__thr_obj,
    91	. 						unsigned __outer) const;
    92	. 
    93	. 				// Internally used during catch matching
    94	. 				virtual bool __do_upcast(const __cxxabiv1::__class_type_info *__target,
    95	. 						void **__obj_ptr) const;
    96	. 
    97	. 			protected:
    98	. 				const char * const __name;
    99	. 
   100	. 				explicit type_info(const char *__n): __name(__n) { }
   101	. 
   102	. 			private:
   103	. 				/// Assigning type_info is not supported.
   104	. 				type_info& operator=(const type_info&);
   105	. 				type_info(const type_info&);
   106	. 		};
   107	. #ifdef EXCEPTIONS_ENABLED
   108	. 		/**
   109	. 		 *  @brief  Thrown during incorrect typecasting.
   110	. 		 *  @ingroup exceptions
   111	. 		 *
   112	. 		 *  If you attempt an invalid @c dynamic_cast expression, an instance of
   113	. 		 *  this class (or something derived from this class) is thrown.  */
   114	. 		class bad_cast : public exception
   115	. 		{
   116	. 			public:
   117	. 				bad_cast() _GLIBCXX_USE_NOEXCEPT { }
   118	. 
   119	. 				// This declaration is not useless:
   120	. 				// http://gcc.gnu.org/onlinedocs/gcc-3.0.2/gcc_6.html#SEC118
   121	. 				virtual ~bad_cast() _GLIBCXX_USE_NOEXCEPT;
   122	. 
   123	. 				// See comment in eh_exception.cc.
   124	. 				virtual const char* what() const _GLIBCXX_USE_NOEXCEPT;
   125	. 		};
   126	. 
   127	. 		/**
   128	. 		 *  @brief Thrown when a NULL pointer in a @c typeid expression is used.
   129	. 		 *  @ingroup exceptions
   130	. 		 */
   131	. 		class bad_typeid : public exception
   132	. 		{
   133	. 			public:
   134	. 				bad_typeid () _GLIBCXX_USE_NOEXCEPT { }
   135	. 
   136	. 				// This declaration is not useless:
   137	. 				// http://gcc.gnu.org/onlinedocs/gcc-3.0.2/gcc_6.html#SEC118
   138	. 				virtual ~bad_typeid() _GLIBCXX_USE_NOEXCEPT;
   139	. 
   140	. 				// See comment in eh_exception.cc.
   141	. 				virtual const char* what() const _GLIBCXX_USE_NOEXCEPT;
   142	. 		};
   143	. #endif
   144	. 	} // namespace std
   145	. 
   146	. } // extern "C++"
   147	. 
   148	. #pragma GCC visibility pop
   149	. 
   150	. #endif
FILE: END: inc/typeinfo.hh
FILE: START: inc/types.hh
HASH: MD5: 23de9862aac3542d5be4405ecf2b8c94
     1	. #ifndef types_hh
     2	. #define types_hh types_hh
     3	. 
     4	. typedef char* ostr_t;
     5	. typedef const char* istr_t;
     6	. typedef istr_t istr_v[];
     7	. typedef signed char int8_t;
     8	. typedef unsigned char uint8_t;
     9	. typedef int   int32_t;
    10	. typedef int32_t* int32_p;
    11	. typedef long  int64_t;
    12	. typedef unsigned uint32_t;
    13	. typedef uint32_t* uint32_p;
    14	. typedef unsigned long uint64_t;
    15	. typedef uint64_t* uint64_p;
    16	. typedef unsigned short int uint16_t;
    17	. typedef void* void_p;
    18	. 
    19	. struct iocb;
    20	. typedef long int __fd_mask;
    21	. struct fd_set
    22	. {
    23	.   __fd_mask fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];
    24	. };
    25	. typedef fd_set* fd_set_p;
    26	. struct sigaction_t {
    27	. 	void (*sa_handler) (int);
    28	. 	unsigned long sa_flags;
    29	. 	void (*sa_restorer) (void);
    30	. 	unsigned long sa_mask;
    31	. };
    32	. struct stat_t {
    33	.   uint64_t  st_dev;
    34	.   uint64_t  st_ino;
    35	.   uint32_t  st_mode;
    36	.   uint32_t  st_nlink;
    37	.   uint32_t  st_uid;
    38	.   uint32_t  st_gid;
    39	.   uint64_t  st_rdev;
    40	.   uint64_t  __pad1;
    41	.   int64_t   st_size;
    42	.   int32_t   st_blksize;
    43	.   int32_t   __pad2;
    44	.   int64_t   st_blocks;
    45	.   int64_t   st_atime;
    46	.   uint64_t  st_atime_nsec;
    47	.   int64_t   st_mtime;
    48	.   uint64_t  st_mtime_nsec;
    49	.   int64_t   st_ctime;
    50	.   uint64_t  st_ctime_nsec;
    51	.   uint32_t  __unused4;
    52	.   uint32_t  __unused5;
    53	. };
    54	. typedef sigaction_t* sigaction_p;
    55	. typedef uint64_t sigset_t;
    56	. typedef sigset_t *sigset_p;
    57	. struct iovec;
    58	. typedef iovec* iovec_p;
    59	. struct timeval;
    60	. typedef timeval* timeval_p;
    61	. struct sockaddr;
    62	. typedef sockaddr* sockaddr_p;
    63	. struct shmid_ds;
    64	. typedef shmid_ds* shmid_ds_p;
    65	. struct itimerval;
    66	. typedef itimerval* itimerval_p;
    67	. struct msghdr;
    68	. typedef msghdr* msghdr_p;
    69	. struct rusage;
    70	. typedef rusage* rusage_p;
    71	. struct utsname;
    72	. struct utsname
    73	. {
    74	.   char sysname[65];
    75	.   char nodename[65];
    76	.   char release[65];
    77	.   char version[65];
    78	.   char machine[65];
    79	.   char domainname[65];
    80	. };
    81	. typedef utsname* utsname_p;
    82	. struct sembuf;
    83	. typedef sembuf* sembuf_p;
    84	. struct msgbuf;
    85	. typedef msgbuf* msgbuf_p;
    86	. 
    87	. struct msqid_ds;
    88	. typedef msqid_ds* msqid_ds_p;
    89	. typedef int qid_t;
    90	. struct linux_dirent;
    91	. typedef linux_dirent* linux_dirent_p;
    92	. struct linux_dirent64;
    93	. typedef linux_dirent64* linux_dirent64_p;
    94	. struct sigevent;
    95	. typedef sigevent* sigevent_p;
    96	. struct timer_t;
    97	. typedef timer_t* timer_p;
    98	. struct timezone;
    99	. typedef timezone* timezone_p;
   100	. struct rlimit;
   101	. typedef rlimit* rlimit_p;
   102	. struct rlimit64;
   103	. struct file_handle;
   104	. typedef file_handle* file_handle_p;
   105	. typedef rlimit64* rlimit64_p;
   106	. struct sysinfo;
   107	. struct cap_user_header;
   108	. struct siginfo_t;
   109	. typedef siginfo_t* siginfo_p;
   110	. struct stack_t;
   111	. typedef stack_t* stack_p;
   112	. struct utimbuf;
   113	. typedef utimbuf* utimbuf_p;
   114	. struct cap_user_data;
   115	. struct ustat;
   116	. typedef ustat* ustat_p;
   117	. struct statfs;
   118	. struct bpf_attr;
   119	. typedef bpf_attr* bpf_attr_p;
   120	. struct sched_attr;
   121	. typedef sched_attr* sched_attr_p;
   122	. struct sched_param;
   123	. typedef sched_param* sched_param_p;
   124	. struct sysctl_args;
   125	. typedef sysctl_args* sysctl_args_p;
   126	. struct task_struct;
   127	. typedef task_struct* task_struct_p;
   128	. struct timex;
   129	. typedef timex* timex_p;
   130	. struct vptr_t;
   131	. struct pt_regs;
   132	. typedef pt_regs* pt_regs_p;
   133	. struct aio_context_t;
   134	. typedef aio_context_t* aio_context_p;
   135	. struct io_event;
   136	. typedef io_event* io_event_p;
   137	. struct iocb;
   138	. struct itimerspec;
   139	. typedef itimerspec* itimerspec_p;
   140	. struct epoll_event;
   141	. typedef epoll_event* epoll_event_p;
   142	. struct mq_attr;
   143	. typedef mq_attr* mq_attr_p;
   144	. struct stat;
   145	. struct pollfd;
   146	. typedef pollfd* pollfd_p;
   147	. typedef stat* stat_p;
   148	. typedef iocb* iocb_p;
   149	. typedef cap_user_header* cap_user_header_t;
   150	. typedef int mqd_t;
   151	. typedef cap_user_data* cap_user_data_t;
   152	. typedef sysinfo* sysinfo_p;
   153	. typedef statfs* statfs_p;
   154	. typedef int key_t;
   155	. typedef key_t* key_p;
   156	. typedef int sig_t;
   157	. typedef sig_t* sig_p;
   158	. typedef int uid_t;
   159	. typedef uid_t* uid_p;
   160	. typedef int gid_t;
   161	. typedef gid_t* gid_p;
   162	. typedef int umode_t;
   163	. struct kexec_segment;
   164	. typedef kexec_segment* kexec_segment_p;
   165	. struct robust_list_head;
   166	. typedef robust_list_head* robust_list_head_p;
   167	. //   typedef int64_t quad_t;
   168	. //   typedef char_ptr caddr_t;
   169	. //   typedef int32_t daddr_t;
   170	. typedef int32_t key_t;
   171	. typedef int32_t pid_t;
   172	. //   typedef int32_t sig_atomic_t;
   173	. //   typedef int64_t blkcnt64_t;
   174	. //   typedef int64_t blkcnt_t;
   175	. //   typedef int64_t blksize_t;
   176	. //   typedef int64_t fsword_t;
   177	. //   typedef int64_t intmax_t;
   178	. typedef long errno_t;
   179	. typedef int64_t intptr_t;
   180	. typedef uint64_t uintptr_t;
   181	. typedef int64_t off64_t;
   182	. typedef uint32_t fd_t;
   183	. typedef fd_t* fd_p;
   184	. struct pollfd_t {
   185	.   fd_t   fd;
   186	.   short events;
   187	.   short revents;
   188	. };
   189	. typedef int64_t clock_t;
   190	. typedef int64_t off_t;
   191	. typedef off_t* off_p;
   192	. struct perf_event_attr;
   193	. typedef perf_event_attr* perf_event_attr_p;
   194	. typedef int64_t suseconds_t;
   195	. typedef int64_t syscall_slong_t;
   196	. typedef int32_t clockid_t;
   197	. typedef int64_t time_t;
   198	. typedef time_t* time_p;
   199	. namespace std {
   200	. typedef int64_t ptrdiff_t;
   201	. };
   202	. using std::ptrdiff_t;
   203	. typedef uint32_t mode_t;
   204	. typedef uint64_t size_t;
   205	. typedef uint64_t* size_p;
   206	. typedef int64_t ssize_t;
   207	. typedef uint64_t ino64_t;
   208	. struct timeval
   209	. {
   210	.   time_t tv_sec;
   211	.   int64_t tv_nsec;
   212	. };
   213	. struct timespec
   214	. {
   215	.   time_t tv_sec;
   216	.   int64_t tv_nsec;
   217	. };
   218	. typedef timespec timespec_t;
   219	. enum ftype_t {
   220	. 	DT_UNKNOWN = 0,
   221	. 	DT_FIFO = 1,
   222	. 	DT_CHR = 2,
   223	. 	DT_DIR = 4,
   224	. 	DT_BLK = 6,
   225	. 	DT_REG = 8,
   226	. 	DT_LNK = 10,
   227	. 	DT_SOCK = 12,
   228	. 	DT_WHT = 14
   229	. };
   230	. struct linux_dirent {
   231	. 	ino64_t        d_ino;    /* 64-bit inode number */
   232	. 	off64_t        d_off;    /* 64-bit offset to next structure */
   233	. 	unsigned short d_reclen; /* Size of this dirent */
   234	. 	unsigned char  d_type;   /* File type */
   235	. 	char           d_name[]; /* Filename (null-terminated) */
   236	. 
   237	. 	linux_dirent *next() {
   238	. 		return (linux_dirent*)(((char*)this)+this->d_reclen);
   239	. 	};
   240	. };
   241	. struct iovec {
   242	. 	void  *iov_base;
   243	. 	size_t iov_len;
   244	. };
   245	. 
   246	. typedef timespec* timespec_p;
   247	. 
   248	. #define NULL nullptr
   249	. //#define offsetof(type, field)	((long) &((type *)0)->field)
   250	. #define offsetof(TYPE, MEMBER) __builtin_offsetof (TYPE, MEMBER)
   251	. 
   252	. #endif
FILE: END: inc/types.hh
FILE: START: inc/write_buf.hh
HASH: MD5: 30f638e7e32a6d0e05c8f7dea543c31a
     1	. #ifndef write_buf_hh
     2	. #define write_buf_hh write_buf_ff
     3	. 
     4	. #include <c_str.hh>
     5	. #include <fmt.hh>
     6	. 
     7	. void check_print(const c_str& str);
     8	. void call_write(fd_t fd, const c_str& str);
     9	. template<typename val_t>
    10	. void swap( val_t &lhs, val_t &rhs)
    11	. {
    12	.   val_t tmp(lhs);
    13	.   lhs=rhs;
    14	.   rhs=tmp;
    15	. };
    16	. template <size_t pages= 1, size_t page_size= 4096>
    17	. struct write_buf
    18	. {
    19	.   typedef fmt::fmt_t fmt_t;
    20	.   enum
    21	.   {
    22	.     size= pages * page_size
    23	.   };
    24	.   fd_t   fd;
    25	.   size_t pos;
    26	.   size_t tot;
    27	.   char   buf[size - 1];
    28	.   char   end[1];
    29	. 
    30	.   write_buf(int fd)
    31	.       : fd(fd)
    32	.       , pos(0)
    33	.       , tot(0)
    34	.   {
    35	.     memset(buf, 0, end - buf);
    36	.   };
    37	.   ~write_buf()
    38	.   {
    39	.     close();
    40	.   };
    41	.   void close()
    42	.   {
    43	.     flush();
    44	.     fd_t tmp=-1;
    45	.     swap(tmp,fd);
    46	.     //sys::close(tmp);
    47	.   }
    48	.   void flush()
    49	.   {
    50	.     if(!pos)
    51	.       return;
    52	.     tot+=pos;
    53	.     sys::full_write(fd,buf,pos);
    54	.     pos=0;
    55	.     memset(&buf,0,end-buf);
    56	.   }
    57	.   size_t room() const
    58	.   {
    59	.     return size - pos;
    60	.   };
    61	.   bool between(char min, char val, char max)
    62	.   {
    63	.     return min <= val && val <= max;
    64	.   };
    65	.   write_buf &put(c_str str)
    66	.   {
    67	.     // this while will repeat if there are zeroes in the str.
    68	.     while(str)
    69	.     {
    70	.       size_t room= this->room();
    71	.       if(!room)
    72	.       {
    73	.         flush();
    74	.       }
    75	.       else if(str.len() > room)
    76	.       {
    77	.         char ch;
    78	.         while(str && room--)
    79	.           if((ch= *str++))
    80	.             buf[pos++]= ch;
    81	.       }
    82	.       else
    83	.       {
    84	.         char ch;
    85	.         while(str)
    86	.           if((ch= *str++))
    87	.             buf[pos++]= ch;
    88	.       };
    89	.     };
    90	.     if(!room())
    91	.       flush();
    92	.     return *this;
    93	.   };
    94	.   write_buf &putln(c_str str)
    95	.   {
    96	.     put(str);
    97	.     switch(room())
    98	.     {
    99	.       case 0:
   100	.         flush();
   101	.         // fall through
   102	.       case 1:
   103	.         buf[pos++]= '\n';
   104	.         flush();
   105	.         break;
   106	.       default:
   107	.         buf[pos++]= '\n';
   108	.         break;
   109	.     };
   110	.     return *this;
   111	.   };
   112	.   write_buf &putln(const fmt_t& fmt)
   113	.   {
   114	.     c_str str= fmt.get();
   115	.     return putln(str);
   116	.   };
   117	.   write_buf &put(const fmt_t& fmt)
   118	.   {
   119	.     c_str str= fmt.get();
   120	.     return put(str);
   121	.   };
   122	.   template <size_t n>
   123	.   write_buf &putln(const char (&str)[n])
   124	.   {
   125	.     return putln(c_str(str, n - 1));
   126	.   };
   127	.   template <size_t n>
   128	.   write_buf &put(const char (&str)[n])
   129	.   {
   130	.     return put(c_str(str, n - 1));
   131	.   };
   132	.   write_buf &put(const char* str)
   133	.   {
   134	.     return put(c_str(str));
   135	.   };
   136	.   write_buf &put(char* str)
   137	.   {
   138	.     return put(c_str(str));
   139	.   };
   140	.   template <typename val_t>
   141	.   write_buf &fmtln(const val_t& val)
   142	.   {
   143	.     fmt_t fmt(val);
   144	.     return putln(fmt.get());
   145	.   };
   146	.   template <typename val_t>
   147	.   write_buf &fmt(const val_t& val)
   148	.   {
   149	.     fmt_t fmt(val);
   150	.     return put(fmt.get());
   151	.   };
   152	. };
   153	. #endif
FILE: END: inc/write_buf.hh
FILE: START: lib/abi.cc
HASH: MD5: 9cfda04c15eb16efe83d537c6c6efccc
     1	. #include <syscall.hh>
     2	. 
     3	. extern "C" {
     4	.   using sys::write;
     5	. 
     6	.   void __cxa_pure_virtual() { 
     7	.     write(2,L("pure virtual function called\n"));
     8	.     abort();
     9	.   }
    10	. 
    11	.   void __cxa_guard_release(void*)
    12	.   {
    13	.   };
    14	.   void __cxa_guard_acquire(void*)
    15	.   {
    16	.   };
    17	.   void * __dso_handle=(void*)&__dso_handle;
    18	. }
FILE: END: lib/abi.cc
FILE: START: lib/c_str.cc
HASH: MD5: 516e0d5a0a7d460a250aaf7d45fd1f01
     1	. #include <c_str.hh>
     2	. 
     3	. const char c_str::null_str[1]="";
     4	. const c_str c_str::colon=":";
     5	. const c_str c_str::newline="\n";
     6	. 
     7	. int c_str::cmp(size_t lhs, size_t rhs) {
     8	.   return lhs-rhs;
     9	. };
    10	. int c_str::cmp(const c_str &lhs, const c_str &rhs)
    11	. {
    12	.   int res = cmp(lhs.len(),rhs.len());
    13	.   if(!res)
    14	.     res=strncmp(lhs.begin(),rhs.begin(),lhs.size());
    15	.   return res;
    16	. };
FILE: END: lib/c_str.cc
FILE: START: lib/dbg.cc
HASH: MD5: 1a4e4f63d40ada239432110b7f8b7d88
     1	. #include <dbg.hh>
     2	. namespace dbg 
     3	. {
     4	. #if 0
     5	.   struct runtime_error
     6	.   {
     7	.   };
     8	. #endif
     9	.   template<typename ...arg_t>
    10	.     void __xthrow(arg_t ... args)
    11	.     {
    12	.     };
    13	.   void __xassert(const char *cond)
    14	.   {
    15	.   };
    16	. }
FILE: END: lib/dbg.cc
FILE: START: lib/delete.cc
HASH: MD5: 1efb686e8dc71159903fa29c99f3c44e
     1	. #include <syscall.hh>
     2	. #include <new.hh>
     3	. 
     4	. namespace std
     5	. {
     6	.   extern "C" void free(void*);
     7	. }
     8	. 
     9	. using std::align_val_t;
    10	. using std::nothrow_t;
    11	. 
    12	. void operator delete(void* ptr, align_val_t) noexcept
    13	. {
    14	.   free (ptr);
    15	. }
    16	. void operator delete (void *ptr, align_val_t al, const nothrow_t&)
    17	. 	noexcept
    18	. {
    19	.   ::operator delete (ptr, al);
    20	. }
    21	. void operator delete(void* ptr) noexcept
    22	. {
    23	.   free(ptr);
    24	. }
    25	. void operator delete (void *ptr, const nothrow_t&) noexcept
    26	. {
    27	.   ::operator delete (ptr);
    28	. }
    29	. void operator delete(void* ptr, size_t, align_val_t al) noexcept
    30	. {
    31	.   ::operator delete (ptr, al);
    32	. }
    33	. void operator delete(void* ptr, size_t) noexcept
    34	. {
    35	.   ::operator delete (ptr);
    36	. }
    37	. 
    38	. void operator delete[] (void *ptr) 
    39	. {
    40	.   ::operator delete (ptr);
    41	. }
    42	. void operator delete[] (void *ptr, align_val_t al) noexcept
    43	. {
    44	.   ::operator delete (ptr, al);
    45	. }
    46	. void operator delete[] (void *ptr, align_val_t al, const nothrow_t&)
    47	. 	noexcept
    48	. {
    49	.   ::operator delete[] (ptr, al);
    50	. }
    51	. void operator delete[] (void *ptr, const nothrow_t&) noexcept
    52	. {
    53	.   ::operator delete[] (ptr);
    54	. }
    55	. void operator delete[] (void *ptr, size_t, align_val_t al) noexcept
    56	. {
    57	.   ::operator delete[] (ptr, al);
    58	. }
    59	. void operator delete[] (void *ptr, size_t) noexcept
    60	. {
    61	.   ::operator delete[] (ptr);
    62	. }
FILE: END: lib/delete.cc
FILE: START: lib/dyncast.cc
HASH: MD5: 9f385fbdf6c3a4e86a35a1df99f3815d
     1	. // Copyright (C) 1994-2019 Free Software Foundation, Inc.
     2	. //
     3	. // This file is part of GCC.
     4	. //
     5	. // GCC is free software; you can redistribute it and/or modify
     6	. // it under the terms of the GNU General Public License as published by
     7	. // the Free Software Foundation; either version 3, or (at your option)
     8	. // any later version.
     9	. 
    10	. // GCC is distributed in the hope that it will be useful,
    11	. // but WITHOUT ANY WARRANTY; without even the implied warranty of
    12	. // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    13	. // GNU General Public License for more details.
    14	. 
    15	. // Under Section 7 of GPL version 3, you are granted additional
    16	. // permissions described in the GCC Runtime Library Exception, version
    17	. // 3.1, as published by the Free Software Foundation.
    18	. 
    19	. // You should have received a copy of the GNU General Public License and
    20	. // a copy of the GCC Runtime Library Exception along with this program;
    21	. // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
    22	. // <http://www.gnu.org/licenses/>.
    23	. 
    24	. #include <tinfo.hh>
    25	. 
    26	. namespace __cxxabiv1 {
    27	. 
    28	. 
    29	. // this is the external interface to the dynamic cast machinery
    30	. /* sub: source address to be adjusted; nonnull, and since the
    31	.  *      source object is polymorphic, *(void**)sub is a virtual pointer.
    32	.  * src: static type of the source object.
    33	.  * dst: destination type (the "T" in "dynamic_cast<T>(v)").
    34	.  * src2dst_offset: a static hint about the location of the
    35	.  *    source subobject with respect to the complete object;
    36	.  *    special negative values are:
    37	.  *       -1: no hint
    38	.  *       -2: src is not a public base of dst
    39	.  *       -3: src is a multiple public base type but never a
    40	.  *           virtual base type
    41	.  *    otherwise, the src type is a unique public nonvirtual
    42	.  *    base type of dst at offset src2dst_offset from the
    43	.  *    origin of dst.  */
    44	. 	extern "C" void * __dynamic_cast (
    45	. 			const void *src_ptr,    // object started from
    46	. 			const __class_type_info *src_type, // type of the starting object
    47	. 			const __class_type_info *dst_type, // desired target type
    48	. 			ptrdiff_t src2dst
    49	. 			) // how src and dst are related
    50	. 	{
    51	. 		const void *vtable = *static_cast <const void *const *> (src_ptr);
    52	. 		const vtable_prefix *prefix =
    53	. 			adjust_pointer <vtable_prefix> (vtable, 
    54	. 					-offsetof (vtable_prefix, origin));
    55	. 		const void *whole_ptr =
    56	. 			adjust_pointer <void> (src_ptr, prefix->whole_object);
    57	. 		const __class_type_info *whole_type = prefix->whole_type;
    58	. 		__class_type_info::__dyncast_result result;
    59	. 
    60	. 		// If the whole object vptr doesn't refer to the whole object type, we're
    61	. 		// in the middle of constructing a primary base, and src is a separate
    62	. 		// base.  This has undefined behavior and we can't find anything outside
    63	. 		// of the base we're actually constructing, so fail now rather than
    64	. 		// segfault later trying to use a vbase offset that doesn't exist.
    65	. 		const void *whole_vtable = *static_cast <const void *const *> (whole_ptr);
    66	. 		const vtable_prefix *whole_prefix =
    67	. 			adjust_pointer <vtable_prefix> (whole_vtable,
    68	. 					-offsetof (vtable_prefix, origin));
    69	. 		if (whole_prefix->whole_type != whole_type)
    70	. 			return NULL;
    71	. 
    72	. 		whole_type->__do_dyncast (src2dst, __class_type_info::__contained_public,
    73	. 				dst_type, whole_ptr, src_type, src_ptr, result);
    74	. 		if (!result.dst_ptr)
    75	. 			return NULL;
    76	. 		if (contained_public_p (result.dst2src))
    77	. 			// Src is known to be a public base of dst.
    78	. 			return const_cast <void *> (result.dst_ptr);
    79	. 		if (contained_public_p (__class_type_info::__sub_kind (result.whole2src & result.whole2dst)))
    80	. 			// Both src and dst are known to be public bases of whole. Found a valid
    81	. 			// cross cast.
    82	. 			return const_cast <void *> (result.dst_ptr);
    83	. 		if (contained_nonvirtual_p (result.whole2src))
    84	. 			// Src is known to be a non-public nonvirtual base of whole, and not a
    85	. 			// base of dst. Found an invalid cross cast, which cannot also be a down
    86	. 			// cast
    87	. 			return NULL;
    88	. 		if (result.dst2src == __class_type_info::__unknown)
    89	. 			result.dst2src = dst_type->__find_public_src (src2dst, result.dst_ptr,
    90	. 					src_type, src_ptr);
    91	. 		if (contained_public_p (result.dst2src))
    92	. 			// Found a valid down cast
    93	. 			return const_cast <void *> (result.dst_ptr);
    94	. 		// Must be an invalid down cast, or the cross cast wasn't bettered
    95	. 		return NULL;
    96	. 	}
    97	. 
    98	. }
FILE: END: lib/dyncast.cc
FILE: START: lib/errno.cc
HASH: MD5: d1ca8e4318b41cf5eadb36c592cf0f6d
     1	. #include <errno.hh>
     2	. #include <syscall.hh>
     3	. #include <buf.hh>
     4	. 
     5	. namespace sys {
     6	.   errno_t errno;
     7	.   ssize_t set_errno(errno_t err)
     8	.   {
     9	.     if(err>=0)
    10	.       return err;
    11	.     {
    12	.       buf_ns::buf_t buf(2);
    13	.       if(err!=11)
    14	.         buf.println("seting error to=",err);
    15	.     };
    16	.     errno=-err;
    17	.     return -1;
    18	.   }
    19	.   void perror(const c_str &msg)
    20	.   {
    21	.     static c_str null;
    22	.     perror(null,msg);
    23	.   };
    24	.   void pexit(const c_str &msg)
    25	.   {
    26	.     perror(msg);
    27	.     exit(1);
    28	.   };
    29	.   void perror(const c_str &msg1, const c_str &msg2)
    30	.   {
    31	.     buf_ns::buf_t buf(2);
    32	.     if(msg1) {
    33	.       buf.print(msg1);
    34	.       buf.print(":");
    35	.     };
    36	.     if(msg2) {
    37	.       buf.print(msg2);
    38	.       buf.print(":");
    39	.     };
    40	.     buf.println(strerror(errno));
    41	.   };
    42	.   void pexit(const c_str &msg1, const c_str &msg2)
    43	.   {
    44	.     perror(msg1,msg2);
    45	.     exit(1);
    46	.   };
    47	. };
FILE: END: lib/errno.cc
FILE: START: lib/getopt.cc
HASH: MD5: d29edf319e3c58cde1b701a1bf6dd541
     1	. /*******************************************************************************
     2	.  * Copyright (c) 2012-2017, Kim Grasman <kim.grasman@gmail.com>
     3	.  * All rights reserved.
     4	.  *
     5	.  * Redistribution and use in source and binary forms, with or without
     6	.  * modification, are permitted provided that the following conditions are met:
     7	.  *   * Redistributions of source code must retain the above copyright
     8	.  *     notice, this list of conditions and the following disclaimer.
     9	.  *   * Redistributions in binary form must reproduce the above copyright
    10	.  *     notice, this list of conditions and the following disclaimer in the
    11	.  *     documentation and/or other materials provided with the distribution.
    12	.  *   * Neither the name of Kim Grasman nor the
    13	.  *     names of contributors may be used to endorse or promote products
    14	.  *     derived from this software without specific prior written permission.
    15	.  *
    16	.  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
    17	.  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    18	.  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
    19	.  * ARE DISCLAIMED. IN NO EVENT SHALL KIM GRASMAN BE LIABLE FOR ANY
    20	.  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
    21	.  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
    22	.  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
    23	.  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
    24	.  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    25	.  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    26	.  *
    27	.  ******************************************************************************/
    28	. #include <syscall.hh>
    29	. #include <getopt.hh>
    30	. 
    31	. //   #include <stddef.h>
    32	. //   #include <string.h>
    33	. 
    34	. char* optarg;
    35	. int optopt;
    36	. /* The variable optind [...] shall be initialized to 1 by the system. */
    37	. int optind = 1;
    38	. int opterr;
    39	. #define NULL nullptr
    40	. 
    41	. static char* optcursor = NULL;
    42	. 
    43	. /* Implemented based on [1] and [2] for optional arguments.
    44	.    optopt is handled FreeBSD-style, per [3].
    45	.    Other GNU and FreeBSD extensions are purely accidental.
    46	. 
    47	. [1] http://pubs.opengroup.org/onlinepubs/000095399/functions/getopt.html
    48	. [2] http://www.kernel.org/doc/man-pages/online/pages/man3/getopt.3.html
    49	. [3] http://www.freebsd.org/cgi/man.cgi?query=getopt&sektion=3&manpath=FreeBSD+9.0-RELEASE
    50	. */
    51	. int getopt(int argc, char* const argv[], const char* optstring) {
    52	.   int optchar = -1;
    53	.   const char* optdecl = NULL;
    54	. 
    55	.   optarg = NULL;
    56	.   opterr = 0;
    57	.   optopt = 0;
    58	. 
    59	.   /* Unspecified, but we need it to avoid overrunning the argv bounds. */
    60	.   if (optind >= argc)
    61	.     goto no_more_optchars;
    62	. 
    63	.   /* If, when getopt() is called argv[optind] is a null pointer, getopt()
    64	.      shall return -1 without changing optind. */
    65	.   if (argv[optind] == NULL)
    66	.     goto no_more_optchars;
    67	. 
    68	.   /* If, when getopt() is called *argv[optind]  is not the character '-',
    69	.      getopt() shall return -1 without changing optind. */
    70	.   if (*argv[optind] != '-')
    71	.     goto no_more_optchars;
    72	. 
    73	.   /* If, when getopt() is called argv[optind] points to the string "-",
    74	.      getopt() shall return -1 without changing optind. */
    75	.   if (strcmp(argv[optind], "-") == 0)
    76	.     goto no_more_optchars;
    77	. 
    78	.   /* If, when getopt() is called argv[optind] points to the string "--",
    79	.      getopt() shall return -1 after incrementing optind. */
    80	.   if (strcmp(argv[optind], "--") == 0) {
    81	.     ++optind;
    82	.     goto no_more_optchars;
    83	.   }
    84	. 
    85	.   if (optcursor == NULL || *optcursor == '\0')
    86	.     optcursor = argv[optind] + 1;
    87	. 
    88	.   optchar = *optcursor;
    89	. 
    90	.   /* FreeBSD: The variable optopt saves the last known option character
    91	.      returned by getopt(). */
    92	.   optopt = optchar;
    93	. 
    94	.   /* The getopt() function shall return the next option character (if one is
    95	.      found) from argv that matches a character in optstring, if there is
    96	.      one that matches. */
    97	.   optdecl = strchr(optstring, optchar);
    98	.   if (optdecl) {
    99	.     /* [I]f a character is followed by a colon, the option takes an
   100	.        argument. */
   101	.     if (optdecl[1] == ':') {
   102	.       optarg = ++optcursor;
   103	.       if (*optarg == '\0') {
   104	.         /* GNU extension: Two colons mean an option takes an
   105	.            optional arg; if there is text in the current argv-element
   106	.            (i.e., in the same word as the option name itself, for example,
   107	.            "-oarg"), then it is returned in optarg, otherwise optarg is set
   108	.            to zero. */
   109	.         if (optdecl[2] != ':') {
   110	.           /* If the option was the last character in the string pointed to by
   111	.              an element of argv, then optarg shall contain the next element
   112	.              of argv, and optind shall be incremented by 2. If the resulting
   113	.              value of optind is greater than argc, this indicates a missing
   114	.              option-argument, and getopt() shall return an error indication.
   115	. 
   116	.              Otherwise, optarg shall point to the string following the
   117	.              option character in that element of argv, and optind shall be
   118	.              incremented by 1.
   119	.           */
   120	.           if (++optind < argc) {
   121	.             optarg = argv[optind];
   122	.           } else {
   123	.             /* If it detects a missing option-argument, it shall return the
   124	.                colon character ( ':' ) if the first character of optstring
   125	.                was a colon, or a question-mark character ( '?' ) otherwise.
   126	.             */
   127	.             optarg = NULL;
   128	.             optchar = (optstring[0] == ':') ? ':' : '?';
   129	.           }
   130	.         } else {
   131	.           optarg = NULL;
   132	.         }
   133	.       }
   134	. 
   135	.       optcursor = NULL;
   136	.     }
   137	.   } else {
   138	.     /* If getopt() encounters an option character that is not contained in
   139	.        optstring, it shall return the question-mark ( '?' ) character. */
   140	.     optchar = '?';
   141	.   }
   142	. 
   143	.   if (optcursor == NULL || *++optcursor == '\0')
   144	.     ++optind;
   145	. 
   146	.   return optchar;
   147	. 
   148	. no_more_optchars:
   149	.   optcursor = NULL;
   150	.   return -1;
   151	. }
   152	. 
   153	. /* Implementation based on [1].
   154	. 
   155	. [1] http://www.kernel.org/doc/man-pages/online/pages/man3/getopt.3.html
   156	. */
   157	. int getopt_long(int argc, char* const argv[], const char* optstring,
   158	.   const struct option* longopts, int* longindex) {
   159	.   const struct option* o = longopts;
   160	.   const struct option* match = NULL;
   161	.   int num_matches = 0;
   162	.   size_t argument_name_length = 0;
   163	.   const char* current_argument = NULL;
   164	.   int retval = -1;
   165	. 
   166	.   optarg = NULL;
   167	.   optopt = 0;
   168	. 
   169	.   if (optind >= argc)
   170	.     return -1;
   171	. 
   172	.   if (strlen(argv[optind]) < 3 || strncmp(argv[optind], "--", 2) != 0)
   173	.     return getopt(argc, argv, optstring);
   174	. 
   175	.   /* It's an option; starts with -- and is longer than two chars. */
   176	.   current_argument = argv[optind] + 2;
   177	.   argument_name_length = strcspn(current_argument, "=");
   178	.   for (; o->name; ++o) {
   179	.     if (strncmp(o->name, current_argument, argument_name_length) == 0) {
   180	.       match = o;
   181	.       ++num_matches;
   182	.     }
   183	.   }
   184	. 
   185	.   if (num_matches == 1) {
   186	.     /* If longindex is not NULL, it points to a variable which is set to the
   187	.        index of the long option relative to longopts. */
   188	.     if (longindex)
   189	.       *longindex = (match - longopts);
   190	. 
   191	.     /* If flag is NULL, then getopt_long() shall return val.
   192	.        Otherwise, getopt_long() returns 0, and flag shall point to a variable
   193	.        which shall be set to val if the option is found, but left unchanged if
   194	.        the option is not found. */
   195	.     if (match->flag)
   196	.       *(match->flag) = match->val;
   197	. 
   198	.     retval = match->flag ? 0 : match->val;
   199	. 
   200	.     if (match->has_arg != no_argument) {
   201	.       optarg = (char*)strchr(argv[optind], '=');
   202	.       if (optarg != NULL)
   203	.         ++optarg;
   204	. 
   205	.       if (match->has_arg == required_argument) {
   206	.         /* Only scan the next argv for required arguments. Behavior is not
   207	.            specified, but has been observed with Ubuntu and Mac OSX. */
   208	.         if (optarg == NULL && ++optind < argc) {
   209	.           optarg = argv[optind];
   210	.         }
   211	. 
   212	.         if (optarg == NULL)
   213	.           retval = ':';
   214	.       }
   215	.     } else if (strchr(argv[optind], '=')) {
   216	.       /* An argument was provided to a non-argument option.
   217	.          I haven't seen this specified explicitly, but both GNU and BSD-based
   218	.          implementations show this behavior.
   219	.       */
   220	.       retval = '?';
   221	.     }
   222	.   } else {
   223	.     /* Unknown option or ambiguous match. */
   224	.     retval = '?';
   225	.   }
   226	. 
   227	.   ++optind;
   228	.   return retval;
   229	. }
FILE: END: lib/getopt.cc
FILE: START: lib/init_array.cc
HASH: MD5: 7ed79ad2b9fe1e835348a7a817d32af3
     1	. #include <types.hh>
     2	. #include <syscall.hh>
     3	. typedef unsigned long size_t;
     4	. typedef long ssize_t;
     5	. typedef unsigned char uint8_t;
     6	. 
     7	. extern void (*__preinit_array_start []) (void) __attribute__((weak));
     8	. extern void (*__preinit_array_end []) (void) __attribute__((weak));
     9	. extern void (*__init_array_start []) (void) __attribute__((weak));
    10	. extern void (*__init_array_end []) (void) __attribute__((weak));
    11	. extern void (*__fini_array_start []) (void) __attribute__((weak));
    12	. extern void (*__fini_array_end []) (void) __attribute__((weak));
    13	. 
    14	. #ifndef L
    15	. #define L(x) x,sizeof(x)-1
    16	. #endif
    17	. inline ssize_t write( fd_t fd,  const char *buf,  size_t len)
    18	. {
    19	. 	long res;
    20	. 	asm (
    21	. 			"syscall\n"
    22	. 			: "=a"(res)
    23	. 			: "a"(1), "D"(fd), "S"(buf),"d"(len)
    24	. 			: "rcx", "r11", "memory"
    25	. 			);
    26	. 	return res;
    27	. };
    28	. extern "C" {
    29	. 	void _init();
    30	. 	void _fini();
    31	. 	void exit(int return_code) __attribute__((noreturn));
    32	. 
    33	. 	static void __libc_init_array() {
    34	. 		size_t count, i;
    35	. 
    36	. 		count = __preinit_array_end - __preinit_array_start;
    37	. 		for (i = 0; i < count; i++)
    38	. 			__preinit_array_start[i]();
    39	. 
    40	. 		//_init();
    41	. 
    42	. 		count = __init_array_end - __init_array_start;
    43	. 		for (i = 0; i < count; i++)
    44	. 			__init_array_start[i]();
    45	. 	}
    46	. 
    47	. 	static void __libc_fini_array() {
    48	. 		ssize_t count, i;
    49	. 
    50	. 		count = __fini_array_end - __fini_array_start;
    51	. 		for (i = count - 1; i >= 0; i--)
    52	.     {
    53	.       __fini_array_start[i]();
    54	.     };
    55	. 
    56	. 		//_fini();
    57	. 	}
    58	. 
    59	. #define MAX_ATEXIT 32
    60	. 
    61	. 	typedef void(*atexit_func_t)(void);
    62	. 	typedef void(*cxa_atexit_func_t)(void *);
    63	. 	struct exit_func {
    64	. 		enum {
    65	. 			ef_none=0,
    66	. 			ef_c,
    67	. 			ef_cxa
    68	. 		} flavor;
    69	. 		union {
    70	. 			struct {
    71	. 				cxa_atexit_func_t func;
    72	. 				void *arg;
    73	. 			} cxa;
    74	. 		 	struct {
    75	. 				void *dummy;
    76	. 				atexit_func_t func;
    77	. 			} c;
    78	. 		};
    79	. 		void call() {
    80	. 			switch(flavor) {
    81	. 				case ef_c:
    82	. 					c.func();
    83	. 					break;
    84	. 				case ef_cxa:
    85	. 					cxa.func(cxa.arg);
    86	. 					break;
    87	. 				case ef_none:
    88	. 					write(2,L("Tried to call 'ef_none' exit func\n"));
    89	. 					break;
    90	. 				default:
    91	. 					write(2,L("Tried to call invalid exit func\n"));
    92	. 					break;
    93	. 			};
    94	. 		};
    95	. 		exit_func( atexit_func_t func )
    96	. 			: flavor(ef_c)
    97	. 		{
    98	. 			c.func=func;
    99	. 		};
   100	. 		exit_func( cxa_atexit_func_t func, void *arg )
   101	. 			: flavor(ef_cxa)
   102	. 		{
   103	. 			cxa.func=func;
   104	. 			cxa.arg=arg;
   105	. 		};
   106	. 		exit_func()
   107	. 			: flavor(ef_none)
   108	. 		{
   109	. 		};
   110	. 	};
   111	. 	char func_buf[MAX_ATEXIT*sizeof(exit_func)];
   112	. 	exit_func *funcs=(exit_func*)(0+func_buf);
   113	. 	static size_t nfunc=0;
   114	. 
   115	. 	int __cxa_atexit(
   116	. 			cxa_atexit_func_t func,
   117	. 			void * arg, 
   118	. 			void * dso_handle
   119	. 			)
   120	. 	{
   121	. 		if(nfunc>=MAX_ATEXIT){
   122	. 			write(2,L("Too many atexit funcs\n"));
   123	. 			exit(1);
   124	. 		};
   125	. 		funcs[nfunc++]=exit_func(func,arg);
   126	. 		return 0;
   127	. 	}
   128	. 	int atexit(atexit_func_t func) {
   129	. 
   130	. 		funcs[nfunc++] = func;
   131	. 		return 0;
   132	. 	}
   133	. 
   134	. 	void exit(int return_code) {
   135	. 		int i=nfunc;
   136	. 		while(i)
   137	. 			funcs[--i].call();	
   138	. 
   139	. 		__libc_fini_array();
   140	.     sys::exit(return_code);
   141	. 	}
   142	. 
   143	. 	void libc_init() {
   144	. 		__libc_init_array();
   145	. 	}
   146	. }
FILE: END: lib/init_array.cc
FILE: START: lib/mm.cc
HASH: MD5: 1a0e51924455fd8b5c321cebcaa892fe
     1	. #include <syscall.hh>
     2	. #include <fmt.hh>
     3	. #include <write_buf.hh>
     4	. 
     5	. using fmt::write_dec;
     6	. using fmt::write_ptr;
     7	. using fmt::write_hex;
     8	. 
     9	. namespace fmt {
    10	.   inline char *fmt_sphex(unsigned long val, char *beg, char *end)
    11	.   {
    12	.     int i;
    13	.     for(i=0;i<2*sizeof(val);i++){
    14	.       *--end=hex_dig(val);
    15	.       if((val/=0x10)==0)
    16	.         break;
    17	.     };
    18	.     for(;i<2*sizeof(val);i++)
    19	.       *--end=' ';
    20	.     return end;
    21	.   };
    22	.   inline int write_sphex(fd_t fd, size_t hex) {
    23	.     char buf[sizeof(hex)*4];
    24	.     return write(fd, fmt::fmt_sphex(hex,buf,&buf[sizeof(buf)-1]));
    25	.   };
    26	. };
    27	. using fmt::write_sphex;
    28	. using fmt::fmt_sphex;
    29	. using namespace sys;
    30	. class block_l {
    31	.   enum magic_t { magic = 0xdeadbeef };
    32	.   struct block_t {
    33	.     magic_t magic1;
    34	.     block_t *next;
    35	.     magic_t magic2;
    36	.     size_t size;
    37	.     magic_t magic3;
    38	.     bool used;
    39	.     void combine() {
    40	.       if(!next)
    41	.         return;
    42	.       if(next->used)
    43	.         return;
    44	.       size+=sizeof(*next)+next->size;
    45	.       next=next->next;
    46	.     };
    47	.   };
    48	.   block_t *list;
    49	.   public:
    50	.   block_l()
    51	.     :list(0)
    52	.   {
    53	.   };
    54	.   void *malloc(size_t size)
    55	.   {
    56	.     void *res=_malloc(size);
    57	.     if(0){
    58	.       write_buf<> msg(2);
    59	.       msg.put("malloc(");
    60	.       msg.fmt(size);
    61	.       msg.put(") => ");
    62	.       msg.fmtln(res);
    63	.     };
    64	.     return res;
    65	. 
    66	.   };
    67	.   void *_malloc(size_t size)
    68	.   {
    69	.     block_t **pos=&list;
    70	.     while(*pos) {
    71	.       block_t *blk=*pos;
    72	.       void *ptr = (void*)(blk+1);
    73	.       if( blk->magic1 != magic || blk->magic2 != magic || blk->magic3 != magic ) 
    74	.       {
    75	.         using fmt::hex_t;
    76	.         write_buf<> msg(2);
    77	.         msg.put(__FILE__);
    78	.         msg.put(":");
    79	.         msg.fmt(__LINE__);
    80	.         msg.put(":");
    81	.         msg.put("free: ");
    82	.         msg.fmtln(ptr);
    83	.         msg.put("blk: ");
    84	.         msg.fmtln(blk);
    85	.         msg.put("magic1: ");
    86	.         msg.fmtln(hex_t((unsigned long)blk->magic1));
    87	.         msg.put("magic2: ");
    88	.         msg.fmtln(hex_t((unsigned long)blk->magic2));
    89	.         msg.put("magic3: ");
    90	.         msg.fmtln(hex_t((unsigned long)blk->magic3));
    91	.       };
    92	.       if(!(*pos)->used && (*pos)->size>=size) {
    93	.         (*pos)->used=true;
    94	.         return *pos+1;
    95	.       };
    96	.       pos=&((*pos)->next);
    97	.     };
    98	.     block_t *blk=(block_t*)sbrk(size+sizeof(block_t));
    99	.     blk->magic1=blk->magic2=blk->magic3=magic;
   100	.     blk->used=true;
   101	.     blk->size=size;
   102	.     blk->next=0;
   103	.     *pos=blk;
   104	.     return blk+1;
   105	.   };
   106	.   ~block_l() {
   107	.     //show();
   108	.     list=0;
   109	.   };
   110	.   typedef char* char_p;
   111	.   void free(void *ptr){
   112	.     if(!ptr)
   113	.       return;
   114	.     block_t *blk=(block_t*)ptr;
   115	.     --blk;
   116	.     if( blk->magic1 != magic || blk->magic2 != magic || blk->magic3 != magic ) 
   117	.     {
   118	.         using fmt::hex_t;
   119	.       write_buf<> msg(2);
   120	.       msg.put(__FILE__);
   121	.       msg.put(":");
   122	.       msg.fmt(__LINE__);
   123	.       msg.put(":");
   124	.       msg.put("free: ");
   125	.       msg.fmtln(ptr);
   126	.       msg.put("blk: ");
   127	.       msg.fmtln(blk);
   128	.       msg.put("magic1: ");
   129	.       msg.fmtln(hex_t((unsigned long)blk->magic1));
   130	.       msg.put("magic2: ");
   131	.       msg.fmtln(hex_t((unsigned long)blk->magic2));
   132	.       msg.put("magic3: ");
   133	.       msg.fmtln(hex_t((unsigned long)blk->magic3));
   134	.       msg.flush();
   135	.     };
   136	.     if(!blk->used) {
   137	.       write(2,L("warning: double free of: "));
   138	.       write_ptr(2,ptr);
   139	.       write(2,L("\n"));
   140	.     };
   141	.     blk->used=false;
   142	.     for(blk=list;blk;blk=blk->next)
   143	.       blk->combine();
   144	.   };
   145	.   void show() {
   146	.     write(2,L("(---BLOCK LIST----\n"));
   147	.     for( block_t *blk=list; blk; blk=blk->next ) {
   148	.       write(2,L("blk: "));
   149	.       write_ptr(2,blk);
   150	.       write(2,L(" data: "));
   151	.       write_ptr(2,blk+1);
   152	.       write(2,L(" size: "));
   153	.       write_sphex(2,blk->size);
   154	.       write(2,L(" used: "));
   155	.       write_dec(2,blk->used);
   156	.       write(2,L("\n"));
   157	.       write(2,L("       "));
   158	.       write_ptr(2,char_p(blk)+blk->size+sizeof(*blk));
   159	.       write(2,L("\n"));
   160	.     };
   161	.     write(2,L("----BLOCK LIST---}\n"));
   162	.   };
   163	. };
   164	. block_l list;
   165	. extern "C" {
   166	. //     void mm_show() {
   167	. //       list.show();
   168	. //     };
   169	. };
   170	. void *malloc(size_t size) {
   171	. #if 1
   172	.   return list.malloc(size);
   173	. #else
   174	.   write(2,L("malloc("));
   175	.   write_dec(2,size);
   176	.   write(2,L(") => "));
   177	.   void *res=list.malloc(size);
   178	.   write_ptr(2,res);
   179	.   write(2,L("\n"));
   180	.   return res;
   181	. #endif
   182	. };
   183	. void *realloc(void *ptr, size_t size) {
   184	.   char *optr=(char*)ptr;
   185	.   char *nptr=(char*)malloc(size);
   186	.   memcpy(nptr,optr,size);
   187	.   free(optr);
   188	.   return nptr;
   189	. };
   190	. void free(void *ptr) {
   191	.   list.free(ptr);
   192	. };
   193	. void *__curbrk;
   194	. 
   195	. int brk (void *addr)
   196	. {
   197	.   char *newbrk;
   198	. 
   199	.   asm (
   200	.       "syscall\n" 
   201	.       : "=a"(newbrk) 
   202	.       : "0"(12), "D"(addr)
   203	.       : "rcx", "r11", "memory"
   204	.       );
   205	. 
   206	.   __curbrk=newbrk;
   207	. 
   208	.   if (newbrk < addr)
   209	.     {
   210	.       set_errno (ENOMEM);
   211	.       return -1;
   212	.     }
   213	. 
   214	.   return 0;
   215	. }
   216	. void * sbrk (ssize_t increment)
   217	. {
   218	.   void *oldbrk;
   219	. 
   220	.   /* If this is not part of the dynamic library or the library is used
   221	.      via dynamic loading in a statically linked program update
   222	.      __curbrk from the kernel's brk value.  That way two separate
   223	.      instances of brk and sbrk can share the heap, returning
   224	.      interleaved pieces of it.  */
   225	.   if (!__curbrk && (brk(0)<0))
   226	.     return (void*)-1;
   227	. 
   228	.   if (increment == 0)
   229	.     return __curbrk;
   230	. 
   231	.   oldbrk = __curbrk;
   232	.   if (increment > 0
   233	.       ? ((uintptr_t) oldbrk + (uintptr_t) increment < (uintptr_t) oldbrk)
   234	.       : ((uintptr_t) oldbrk < (uintptr_t) -increment))
   235	.     {
   236	.       set_errno (ENOMEM);
   237	.       return (void *) -1;
   238	.     }
   239	. 
   240	.   if (brk (ostr_t(oldbrk) + increment) < 0)
   241	.     return (void *) -1;
   242	. 
   243	.   return oldbrk;
   244	. }
FILE: END: lib/mm.cc
FILE: START: lib/new.cc
HASH: MD5: 0007146408bb7161c3eb35781cb28f0a
     1	. #include <syscall.hh>
     2	. #include <new.hh>
     3	. 
     4	. using std::align_val_t;
     5	. using std::nothrow_t;
     6	. 
     7	. void* operator new(size_t sz)
     8	. {
     9	. 	return malloc(sz);
    10	. }
    11	. void* operator new(size_t sz, align_val_t align)
    12	. {
    13	. 	return operator new(sz);
    14	. }
    15	. void* operator new(size_t sz, align_val_t al, const nothrow_t&)
    16	.   noexcept
    17	. {
    18	. 	return operator new(sz, al);
    19	. }
    20	. 
    21	. void* operator new[](size_t sz)
    22	. {
    23	. 	return operator new(sz);
    24	. }
    25	. void* operator new[](size_t sz, align_val_t align)
    26	. {
    27	. 	return operator new[](sz);
    28	. };
    29	. 
    30	. void* operator new[](size_t sz, align_val_t al, const nothrow_t&)
    31	.   noexcept
    32	. {
    33	. 	return operator new[](sz, al);
    34	. }
FILE: END: lib/new.cc
FILE: START: lib/start.S
HASH: MD5: 9ae122f7f89fb06fd34aa17815f9d2c9
     1	. .text
     2	. .global _start
     3	. _start:
     4	. xorl %ebp,%ebp
     5	. call libc_init
     6	. movq 0(%rsp),%rdi
     7	. lea 8(%rsp),%rsi
     8	. call main
     9	. movq %rax,%rdi
    10	. call exit
    11	. int3
    12	. #   movq %rax,%rdi
    13	. #   movl $60,%eax
    14	. #   syscall
    15	. #   int3
FILE: END: lib/start.S
FILE: START: lib/stdlib.cc
HASH: MD5: 9f1b6eb65c770ac893cb988031e57bfc
     1	. #define inline
     2	. #define AAI
     3	. #include "stdlib.hh"
     4	. 
FILE: END: lib/stdlib.cc
FILE: START: lib/strerror_list.cc
HASH: MD5: 9a5b00dc6d4a56e1ddf8b682ff59971c
     1	. // do not edit this file.  It will be regenerated.
     2	. 
     3	. #include <c_str.hh>
     4	. 
     5	. 
     6	. 
     7	. static c_str strerror_v[]={
     8	. 
     9	.   "Unknown Error(###)",
    10	. 
    11	.  "Operation not permitted",
    12	.  "No such file or directory",
    13	.  "No such process",
    14	.  "Interrupted system call",
    15	.  "Input/output error",
    16	.  "No such device or address",
    17	.  "Argument list too long",
    18	.  "Exec format error",
    19	.  "Bad file descriptor",
    20	.  "No child processes",
    21	.  "Resource temporarily unavailable",
    22	.  "Cannot allocate memory",
    23	.  "Permission denied",
    24	.  "Bad address",
    25	.  "Block device required",
    26	.  "Device or resource busy",
    27	.  "File exists",
    28	.  "Invalid cross-device link",
    29	.  "No such device",
    30	.  "Not a directory",
    31	.  "Is a directory",
    32	.  "Invalid argument",
    33	.  "Too many open files in system",
    34	.  "Too many open files",
    35	.  "Inappropriate ioctl for device",
    36	.  "Text file busy",
    37	.  "File too large",
    38	.  "No space left on device",
    39	.  "Illegal seek",
    40	.  "Read-only file system",
    41	.  "Too many links",
    42	.  "Broken pipe",
    43	.  "Numerical argument out of domain",
    44	.  "Numerical result out of range",
    45	.  "Resource deadlock avoided",
    46	.  "File name too long",
    47	.  "No locks available",
    48	.  "Function not implemented",
    49	.  "Directory not empty",
    50	.  "Too many levels of symbolic links",
    51	.  "Unknown error 41",
    52	.  "No message of desired type",
    53	.  "Identifier removed",
    54	.  "Channel number out of range",
    55	.  "Level 2 not synchronized",
    56	.  "Level 3 halted",
    57	.  "Level 3 reset",
    58	.  "Link number out of range",
    59	.  "Protocol driver not attached",
    60	.  "No CSI structure available",
    61	.  "Level 2 halted",
    62	.  "Invalid exchange",
    63	.  "Invalid request descriptor",
    64	.  "Exchange full",
    65	.  "No anode",
    66	.  "Invalid request code",
    67	.  "Invalid slot",
    68	.  "Unknown error 58",
    69	.  "Bad font file format",
    70	.  "Device not a stream",
    71	.  "No data available",
    72	.  "Timer expired",
    73	.  "Out of streams resources",
    74	.  "Machine is not on the network",
    75	.  "Package not installed",
    76	.  "Object is remote",
    77	.  "Link has been severed",
    78	.  "Advertise error",
    79	.  "Srmount error",
    80	.  "Communication error on send",
    81	.  "Protocol error",
    82	.  "Multihop attempted",
    83	.  "RFS specific error",
    84	.  "Bad message",
    85	.  "Value too large for defined data type",
    86	.  "Name not unique on network",
    87	.  "File descriptor in bad state",
    88	.  "Remote address changed",
    89	.  "Can not access a needed shared library",
    90	.  "Accessing a corrupted shared library",
    91	.  ".lib section in a.out corrupted",
    92	.  "Attempting to link in too many shared libraries",
    93	.  "Cannot exec a shared library directly",
    94	.  "Invalid or incomplete multibyte or wide character",
    95	.  "Interrupted system call should be restarted",
    96	.  "Streams pipe error",
    97	.  "Too many users",
    98	.  "Socket operation on non-socket",
    99	.  "Destination address required",
   100	.  "Message too long",
   101	.  "Protocol wrong type for socket",
   102	.  "Protocol not available",
   103	.  "Protocol not supported",
   104	.  "Socket type not supported",
   105	.  "Operation not supported",
   106	.  "Protocol family not supported",
   107	.  "Address family not supported by protocol",
   108	.  "Address already in use",
   109	.  "Cannot assign requested address",
   110	.  "Network is down",
   111	.  "Network is unreachable",
   112	.  "Network dropped connection on reset",
   113	.  "Software caused connection abort",
   114	.  "Connection reset by peer",
   115	.  "No buffer space available",
   116	.  "Transport endpoint is already connected",
   117	.  "Transport endpoint is not connected",
   118	.  "Cannot send after transport endpoint shutdown",
   119	.  "Too many references: cannot splice",
   120	.  "Connection timed out",
   121	.  "Connection refused",
   122	.  "Host is down",
   123	.  "No route to host",
   124	.  "Operation already in progress",
   125	.  "Operation now in progress",
   126	.  "Stale file handle",
   127	.  "Structure needs cleaning",
   128	.  "Not a XENIX named type file",
   129	.  "No XENIX semaphores available",
   130	.  "Is a named type file",
   131	.  "Remote I/O error",
   132	.  "Disk quota exceeded",
   133	.  "No medium found",
   134	.  "Wrong medium type",
   135	.  "Operation canceled",
   136	.  "Required key not available",
   137	.  "Key has expired",
   138	.  "Key has been revoked",
   139	.  "Key was rejected by service",
   140	.  "Owner died",
   141	.  "State not recoverable",
   142	.  "Operation not possible due to RF-kill",
   143	.  "Memory page has hardware error",
   144	.  "Unknown error 134",
   145	. };
   146	. 
   147	. 
   148	. static size_t strerror_c = sizeof(strerror_v)/sizeof(strerror_v[0]);
   149	. namespace sys {
   150	.   c_str no_err(L("No Error"));
   151	.   const c_str &strerror(errno_t err) {
   152	.     if(!err)
   153	.       return no_err;
   154	.     else if(err<strerror_c)
   155	.       return strerror_v[err];
   156	.     else
   157	.       return strerror_v[0];
   158	.   };  
   159	. }
   160	. 
FILE: END: lib/strerror_list.cc
FILE: START: lib/type_info.cc
HASH: MD5: f56951ba18bcf14de0d2d2b40bfeb839
     1	. // Copyright (C) 1994-2019 Free Software Foundation, Inc.
     2	. //
     3	. // This file is part of GCC.
     4	. //
     5	. // GCC is free software; you can redistribute it and/or modify
     6	. // it under the terms of the GNU General Public License as published by
     7	. // the Free Software Foundation; either version 3, or (at your option)
     8	. // any later version.
     9	. 
    10	. // GCC is distributed in the hope that it will be useful,
    11	. // but WITHOUT ANY WARRANTY; without even the implied warranty of
    12	. // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    13	. // GNU General Public License for more details.
    14	. 
    15	. // Under Section 7 of GPL version 3, you are granted additional
    16	. // permissions described in the GCC Runtime Library Exception, version
    17	. // 3.1, as published by the Free Software Foundation.
    18	. 
    19	. // You should have received a copy of the GNU General Public License and
    20	. // a copy of the GCC Runtime Library Exception along with this program;
    21	. // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
    22	. // <http://www.gnu.org/licenses/>.
    23	. 
    24	. #include <tinfo.hh>
    25	. 
    26	. namespace std {
    27	. 	type_info::~type_info()
    28	. 	{
    29	. 	}
    30	.   bool type_info::__is_pointer_p() const
    31	. 	{
    32	. 		return false;
    33	. 	}
    34	. 	bool type_info::__is_function_p() const
    35	. 	{
    36	. 		return false;
    37	. 	}
    38	. 	bool type_info::__do_catch(
    39	. 			const type_info *__thr_type,
    40	. 			void **__thr_obj,
    41	. 			unsigned __outer
    42	. 			) const
    43	. 	{
    44	. 		return *this == *__thr_type;
    45	. 	}
    46	.   bool type_info::__do_upcast(const __cxxabiv1::__class_type_info *__target,
    47	. 			     void **__obj_ptr) const
    48	. 	{
    49	. 		return false;
    50	. 	}
    51	. 	bool type_info::operator== (const std::type_info& arg) const
    52	. 	{
    53	. 		return name () == arg.name ();
    54	. 	}
    55	. }
    56	. namespace __cxxabiv1 {
    57	. 	__function_type_info::~__function_type_info ()
    58	. 	{
    59	. 	}
    60	. 	bool __function_type_info::__is_function_p () const
    61	. 	{
    62	. 		return true;
    63	. 	}
    64	. 	__class_type_info::~__class_type_info ()
    65	. 	{
    66	. 	}
    67	. 	bool __class_type_info::__do_catch (
    68	. 			const type_info *thr_type,
    69	. 			void **thr_obj,
    70	. 			unsigned outer
    71	. 			) const
    72	. 	{
    73	. 		if (*this == *thr_type)
    74	. 			return true;
    75	. 		if (outer >= 4)
    76	. 			// Neither `A' nor `A *'.
    77	. 			return false;
    78	. 		return thr_type->__do_upcast (this, thr_obj);
    79	. 	}
    80	. 
    81	. 	bool __class_type_info::
    82	. 		__do_upcast (const __class_type_info *dst_type,
    83	. 				void **obj_ptr) const
    84	. 		{
    85	. 			__upcast_result result (__vmi_class_type_info::__flags_unknown_mask);
    86	. 
    87	. 			__do_upcast (dst_type, *obj_ptr, result);
    88	. 			if (!contained_public_p (result.part2dst))
    89	. 				return false;
    90	. 			*obj_ptr = const_cast <void *> (result.dst_ptr);
    91	. 			return true;
    92	. 		}
    93	. 
    94	. 	__class_type_info::__sub_kind __class_type_info::__do_find_public_src (
    95	. 			ptrdiff_t,
    96	. 			const void *obj_ptr,
    97	. 			const __class_type_info *,
    98	. 			const void *src_ptr
    99	. 			) const
   100	. 	{
   101	. 		if (src_ptr == obj_ptr)
   102	. 			// Must be our type, as the pointers match.
   103	. 			return __contained_public;
   104	. 		return __not_contained;
   105	. 	}
   106	. 
   107	. 	bool __class_type_info::__do_dyncast (
   108	. 			ptrdiff_t,
   109	. 			__sub_kind access_path,
   110	. 			const __class_type_info *dst_type,
   111	. 			const void *obj_ptr,
   112	. 			const __class_type_info *src_type,
   113	. 			const void *src_ptr,
   114	. 			__dyncast_result &__restrict result
   115	. 			) const
   116	. 	{
   117	. 		if (obj_ptr == src_ptr && *this == *src_type)
   118	. 		{
   119	. 			// The src object we started from. Indicate how we are accessible from
   120	. 			// the most derived object.
   121	. 			result.whole2src = access_path;
   122	. 			return false;
   123	. 		}
   124	. 		if (*this == *dst_type)
   125	. 		{
   126	. 			result.dst_ptr = obj_ptr;
   127	. 			result.whole2dst = access_path;
   128	. 			result.dst2src = __not_contained;
   129	. 			return false;
   130	. 		}
   131	. 		return false;
   132	. 	}
   133	. 
   134	. 	bool __class_type_info::__do_upcast (
   135	. 			const __class_type_info *dst,
   136	. 			const void *obj,
   137	. 			__upcast_result &__restrict result
   138	. 			) const
   139	. 	{
   140	. 		if (*this == *dst)
   141	. 		{
   142	. 			result.dst_ptr = obj;
   143	. 			result.base_type = nonvirtual_base_type;
   144	. 			result.part2dst = __contained_public;
   145	. 			return true;
   146	. 		}
   147	. 		return false;
   148	. 	}
   149	. 
   150	. 
   151	. 	__si_class_type_info::~__si_class_type_info ()
   152	. 	{
   153	. 	}
   154	. 
   155	. 	__class_type_info::__sub_kind __si_class_type_info:: __do_find_public_src (
   156	. 			ptrdiff_t src2dst,
   157	. 			const void *obj_ptr,
   158	. 			const __class_type_info *src_type,
   159	. 			const void *src_ptr
   160	. 			) const
   161	. 	{
   162	. 		if (src_ptr == obj_ptr && *this == *src_type)
   163	. 			return __contained_public;
   164	. 		return __base_type->__do_find_public_src (src2dst, obj_ptr, src_type, src_ptr);
   165	. 	}
   166	. 
   167	. 	bool __si_class_type_info::
   168	. 		__do_dyncast (ptrdiff_t src2dst,
   169	. 				__sub_kind access_path,
   170	. 				const __class_type_info *dst_type,
   171	. 				const void *obj_ptr,
   172	. 				const __class_type_info *src_type,
   173	. 				const void *src_ptr,
   174	. 				__dyncast_result &__restrict result) const
   175	. 		{
   176	. 			if (*this == *dst_type)
   177	. 			{
   178	. 				result.dst_ptr = obj_ptr;
   179	. 				result.whole2dst = access_path;
   180	. 				if (src2dst >= 0)
   181	. 					result.dst2src = adjust_pointer <void> (obj_ptr, src2dst) == src_ptr
   182	. 						? __contained_public : __not_contained;
   183	. 				else if (src2dst == -2)
   184	. 					result.dst2src = __not_contained;
   185	. 				return false;
   186	. 			}
   187	. 			if (obj_ptr == src_ptr && *this == *src_type)
   188	. 			{
   189	. 				// The src object we started from. Indicate how we are accessible from
   190	. 				// the most derived object.
   191	. 				result.whole2src = access_path;
   192	. 				return false;
   193	. 			}
   194	. 			return __base_type->__do_dyncast (src2dst, access_path, dst_type, obj_ptr,
   195	. 					src_type, src_ptr, result);
   196	. 		}
   197	. 
   198	. 	bool __si_class_type_info::__do_upcast 
   199	. 		(
   200	. 		 const __class_type_info *dst, 
   201	. 		 const void *obj_ptr,
   202	. 		 __upcast_result &__restrict result
   203	. 		) const
   204	. 		{
   205	. 			if (__class_type_info::__do_upcast (dst, obj_ptr, result))
   206	. 				return true;
   207	. 
   208	. 			return __base_type->__do_upcast (dst, obj_ptr, result);
   209	. 		}
   210	. 
   211	. 
   212	. 	__pointer_type_info::
   213	. 		~__pointer_type_info ()
   214	. 		{}
   215	. 
   216	. 	bool __pointer_type_info::
   217	. 		__is_pointer_p () const
   218	. 		{
   219	. 			return true;
   220	. 		}
   221	. 
   222	. 	bool __pointer_type_info::
   223	. 		__pointer_catch (const __pbase_type_info *thrown_type,
   224	. 				void **thr_obj,
   225	. 				unsigned outer) const
   226	. 		{
   227	. #if __cpp_rtti
   228	. 			if (outer < 2 && *__pointee == typeid (void))
   229	. 			{
   230	. 				// conversion to void
   231	. 				return !thrown_type->__pointee->__is_function_p ();
   232	. 			}
   233	. #endif
   234	. 
   235	. 			return __pbase_type_info::__pointer_catch (thrown_type, thr_obj, outer);
   236	. 		}
   237	. 
   238	. 	__pbase_type_info::
   239	. 		~__pbase_type_info ()
   240	. 		{}
   241	. 
   242	. 	bool __pbase_type_info::
   243	. 		__do_catch (const type_info *thr_type,
   244	. 				void **thr_obj,
   245	. 				unsigned outer) const
   246	. 		{
   247	. 			if (*this == *thr_type)
   248	. 				return true;      // same type
   249	. 
   250	. #if __cpp_rtti
   251	. 			if (*thr_type == typeid (nullptr))
   252	. 			{
   253	. 				// A catch handler for any pointer type matches nullptr_t.
   254	. 				if (typeid (*this) == typeid(__pointer_type_info))
   255	. 				{
   256	. 					*thr_obj = nullptr;
   257	. 					return true;
   258	. 				}
   259	. 				else if (typeid (*this) == typeid(__pointer_to_member_type_info))
   260	. 				{
   261	. 					if (__pointee->__is_function_p ())
   262	. 					{
   263	. 						using pmf_type = void (__pbase_type_info::*)();
   264	. 						static const pmf_type pmf = nullptr;
   265	. 						*thr_obj = const_cast<pmf_type*>(&pmf);
   266	. 						return true;
   267	. 					}
   268	. 					else
   269	. 					{
   270	. 						using pm_type = int __pbase_type_info::*;
   271	. 						static const pm_type pm = nullptr;
   272	. 						*thr_obj = const_cast<pm_type*>(&pm);
   273	. 						return true;
   274	. 					}
   275	. 				}
   276	. 			}
   277	. 
   278	. 			if (typeid (*this) != typeid (*thr_type))
   279	. 				return false;     // not both same kind of pointers
   280	. #endif
   281	. 
   282	. 			if (!(outer & 1))
   283	. 				// We're not the same and our outer pointers are not all const qualified
   284	. 				// Therefore there must at least be a qualification conversion involved
   285	. 				// But for that to be valid, our outer pointers must be const qualified.
   286	. 				return false;
   287	. 
   288	. 			const __pbase_type_info *thrown_type =
   289	. 				static_cast <const __pbase_type_info *> (thr_type);
   290	. 
   291	. 			unsigned tflags = thrown_type->__flags;
   292	. 
   293	. 			const unsigned fqual_mask = __transaction_safe_mask|__noexcept_mask;
   294	. 			unsigned throw_fqual = (tflags & fqual_mask);
   295	. 			unsigned catch_fqual = (__flags & fqual_mask);
   296	. 			if (throw_fqual & ~catch_fqual)
   297	. 				/* Catch can perform a function pointer conversion.  */
   298	. 				tflags &= catch_fqual;
   299	. 			if (catch_fqual & ~throw_fqual)
   300	. 				/* But not the reverse.  */
   301	. 				return false;
   302	. 
   303	. 			if (tflags & ~__flags)
   304	. 				// We're less qualified.
   305	. 				return false;
   306	. 
   307	. 			if (!(__flags & __const_mask))
   308	. 				outer &= ~1;
   309	. 
   310	. 			return __pointer_catch (thrown_type, thr_obj, outer);
   311	. 		}
   312	. 
   313	. 	// This has special meaning to the compiler, and will cause it
   314	. 	// to emit the type_info structures for the fundamental types which are
   315	. 	// mandated to exist in the runtime.
   316	. 	__fundamental_type_info::
   317	. 		~__fundamental_type_info ()
   318	. 		{}
   319	. 
   320	. 
   321	. 	__pointer_to_member_type_info::
   322	. 		~__pointer_to_member_type_info ()
   323	. 		{}
   324	. 
   325	. 	bool __pointer_to_member_type_info::
   326	. 		__pointer_catch (
   327	. 				const __pbase_type_info *thr_type,
   328	. 				void **thr_obj,
   329	. 				unsigned outer
   330	. 				) const
   331	. 		{
   332	. 			// This static cast is always valid, as our caller will have
   333	. 			// determined that thr_type is really a __pointer_to_member_type_info.
   334	. 
   335	. 			const __pointer_to_member_type_info *thrown_type =
   336	. 				static_cast <const __pointer_to_member_type_info *> (thr_type);
   337	. 
   338	. 			if (*__context != *thrown_type->__context)
   339	. 				return false;     // not pointers to member of same class
   340	. 
   341	. 			return __pbase_type_info::__pointer_catch (thrown_type, thr_obj, outer);
   342	. 		}
   343	. 
   344	. 	__vmi_class_type_info::
   345	. 		~__vmi_class_type_info ()
   346	. 		{}
   347	. 
   348	. 	__class_type_info::__sub_kind __vmi_class_type_info::
   349	. 		__do_find_public_src (ptrdiff_t src2dst,
   350	. 				const void *obj_ptr,
   351	. 				const __class_type_info *src_type,
   352	. 				const void *src_ptr) const
   353	. 		{
   354	. 			if (obj_ptr == src_ptr && *this == *src_type)
   355	. 				return __contained_public;
   356	. 
   357	. 			for (std::size_t i = __base_count; i--;)
   358	. 			{
   359	. 				if (!__base_info[i].__is_public_p ())
   360	. 					continue; // Not public, can't be here.
   361	. 
   362	. 				const void *base = obj_ptr;
   363	. 				ptrdiff_t offset = __base_info[i].__offset ();
   364	. 				bool is_virtual = __base_info[i].__is_virtual_p ();
   365	. 
   366	. 				if (is_virtual)
   367	. 				{
   368	. 					if (src2dst == -3)
   369	. 						continue; // Not a virtual base, so can't be here.
   370	. 				}
   371	. 				base = convert_to_base (base, is_virtual, offset);
   372	. 
   373	. 				__sub_kind base_kind = __base_info[i].__base_type->__do_find_public_src
   374	. 					(src2dst, base, src_type, src_ptr);
   375	. 				if (contained_p (base_kind))
   376	. 				{
   377	. 					if (is_virtual)
   378	. 						base_kind = __sub_kind (base_kind | __contained_virtual_mask);
   379	. 					return base_kind;
   380	. 				}
   381	. 			}
   382	. 
   383	. 			return __not_contained;
   384	. 		}
   385	. 
   386	. 	// This is a big hairy function. Although the run-time behaviour of
   387	. 	// dynamic_cast is simple to describe, it gives rise to some non-obvious
   388	. 	// behaviour. We also desire to determine as early as possible any definite
   389	. 	// answer we can get. Because it is unknown what the run-time ratio of
   390	. 	// succeeding to failing dynamic casts is, we do not know in which direction
   391	. 	// to bias any optimizations. To that end we make no particular effort towards
   392	. 	// early fail answers or early success answers. Instead we try to minimize
   393	. 	// work by filling in things lazily (when we know we need the information),
   394	. 	// and opportunisticly take early success or failure results.
   395	. 	bool __vmi_class_type_info::
   396	. 		__do_dyncast (ptrdiff_t src2dst,
   397	. 				__sub_kind access_path,
   398	. 				const __class_type_info *dst_type,
   399	. 				const void *obj_ptr,
   400	. 				const __class_type_info *src_type,
   401	. 				const void *src_ptr,
   402	. 				__dyncast_result &__restrict result) const
   403	. 		{
   404	. 			if (result.whole_details & __flags_unknown_mask)
   405	. 				result.whole_details = __flags;
   406	. 
   407	. 			if (obj_ptr == src_ptr && *this == *src_type)
   408	. 			{
   409	. 				// The src object we started from. Indicate how we are accessible from
   410	. 				// the most derived object.
   411	. 				result.whole2src = access_path;
   412	. 				return false;
   413	. 			}
   414	. 			if (*this == *dst_type)
   415	. 			{
   416	. 				result.dst_ptr = obj_ptr;
   417	. 				result.whole2dst = access_path;
   418	. 				if (src2dst >= 0)
   419	. 					result.dst2src = adjust_pointer <void> (obj_ptr, src2dst) == src_ptr
   420	. 						? __contained_public : __not_contained;
   421	. 				else if (src2dst == -2)
   422	. 					result.dst2src = __not_contained;
   423	. 				return false;
   424	. 			}
   425	. 
   426	. 			// If src_type is a unique non-virtual base of dst_type, we have a good
   427	. 			// guess at the address we want, so in the first pass try skipping any
   428	. 			// bases which don't contain that address.
   429	. 			const void *dst_cand = NULL;
   430	. 			if (src2dst >= 0)
   431	. 				dst_cand = adjust_pointer<void>(src_ptr, -src2dst);
   432	. 			bool first_pass = true;
   433	. 			bool skipped = false;
   434	. 
   435	. 			bool result_ambig = false;
   436	. again:
   437	. 			for (std::size_t i = __base_count; i--;)
   438	. 			{
   439	. 				__dyncast_result result2 (result.whole_details);
   440	. 				void const *base = obj_ptr;
   441	. 				__sub_kind base_access = access_path;
   442	. 				ptrdiff_t offset = __base_info[i].__offset ();
   443	. 				bool is_virtual = __base_info[i].__is_virtual_p ();
   444	. 
   445	. 				if (is_virtual)
   446	. 					base_access = __sub_kind (base_access | __contained_virtual_mask);
   447	. 				base = convert_to_base (base, is_virtual, offset);
   448	. 
   449	. 				if (dst_cand)
   450	. 				{
   451	. 					bool skip_on_first_pass = base > dst_cand;
   452	. 					if (skip_on_first_pass == first_pass)
   453	. 					{
   454	. 						// We aren't interested in this base on this pass: either
   455	. 						// we're on the first pass and this base doesn't contain the
   456	. 						// likely address, or we're on the second pass and we checked
   457	. 						// this base on the first pass.
   458	. 						skipped = true;
   459	. 						continue;
   460	. 					}
   461	. 				}
   462	. 
   463	. 				if (!__base_info[i].__is_public_p ())
   464	. 				{
   465	. 					if (src2dst == -2 &&
   466	. 							!(result.whole_details
   467	. 								& (__non_diamond_repeat_mask | __diamond_shaped_mask)))
   468	. 						// The hierarchy has no duplicate bases (which might ambiguate
   469	. 						// things) and where we started is not a public base of what we
   470	. 						// want (so it cannot be a downcast). There is nothing of interest
   471	. 						// hiding in a non-public base.
   472	. 						continue;
   473	. 					base_access = __sub_kind (base_access & ~__contained_public_mask);
   474	. 				}
   475	. 
   476	. 				bool result2_ambig
   477	. 					= __base_info[i].__base_type->__do_dyncast (src2dst, base_access,
   478	. 							dst_type, base,
   479	. 							src_type, src_ptr, result2);
   480	. 				result.whole2src = __sub_kind (result.whole2src | result2.whole2src);
   481	. 				if (result2.dst2src == __contained_public
   482	. 						|| result2.dst2src == __contained_ambig)
   483	. 				{
   484	. 					result.dst_ptr = result2.dst_ptr;
   485	. 					result.whole2dst = result2.whole2dst;
   486	. 					result.dst2src = result2.dst2src;
   487	. 					// Found a downcast which can't be bettered or an ambiguous downcast
   488	. 					// which can't be disambiguated
   489	. 					return result2_ambig;
   490	. 				}
   491	. 
   492	. 				if (!result_ambig && !result.dst_ptr)
   493	. 				{
   494	. 					// Not found anything yet.
   495	. 					result.dst_ptr = result2.dst_ptr;
   496	. 					result.whole2dst = result2.whole2dst;
   497	. 					result_ambig = result2_ambig;
   498	. 					if (result.dst_ptr && result.whole2src != __unknown
   499	. 							&& !(__flags & __non_diamond_repeat_mask))
   500	. 						// Found dst and src and we don't have repeated bases.
   501	. 						return result_ambig;
   502	. 				}
   503	. 				else if (result.dst_ptr && result.dst_ptr == result2.dst_ptr)
   504	. 				{
   505	. 					// Found at same address, must be via virtual.  Pick the most
   506	. 					// accessible path.
   507	. 					result.whole2dst =
   508	. 						__sub_kind (result.whole2dst | result2.whole2dst);
   509	. 				}
   510	. 				else if ((result.dst_ptr != 0 && result2.dst_ptr != 0)
   511	. 						|| (result.dst_ptr != 0 && result2_ambig)
   512	. 						|| (result2.dst_ptr != 0 && result_ambig))
   513	. 				{
   514	. 					// Found two different DST_TYPE bases, or a valid one and a set of
   515	. 					// ambiguous ones, must disambiguate. See whether SRC_PTR is
   516	. 					// contained publicly within one of the non-ambiguous choices. If it
   517	. 					// is in only one, then that's the choice. If it is in both, then
   518	. 					// we're ambiguous and fail. If it is in neither, we're ambiguous,
   519	. 					// but don't yet fail as we might later find a third base which does
   520	. 					// contain SRC_PTR.
   521	. 
   522	. 					__sub_kind new_sub_kind = result2.dst2src;
   523	. 					__sub_kind old_sub_kind = result.dst2src;
   524	. 
   525	. 					if (contained_p (result.whole2src)
   526	. 							&& (!virtual_p (result.whole2src)
   527	. 								|| !(result.whole_details & __diamond_shaped_mask)))
   528	. 					{
   529	. 						// We already found SRC_PTR as a base of most derived, and
   530	. 						// either it was non-virtual, or the whole hierarchy is
   531	. 						// not-diamond shaped. Therefore if it is in either choice, it
   532	. 						// can only be in one of them, and we will already know.
   533	. 						if (old_sub_kind == __unknown)
   534	. 							old_sub_kind = __not_contained;
   535	. 						if (new_sub_kind == __unknown)
   536	. 							new_sub_kind = __not_contained;
   537	. 					}
   538	. 					else
   539	. 					{
   540	. 						if (old_sub_kind >= __not_contained)
   541	. 							;// already calculated
   542	. 						else if (contained_p (new_sub_kind)
   543	. 								&& (!virtual_p (new_sub_kind)
   544	. 									|| !(__flags & __diamond_shaped_mask)))
   545	. 							// Already found inside the other choice, and it was
   546	. 							// non-virtual or we are not diamond shaped.
   547	. 							old_sub_kind = __not_contained;
   548	. 						else
   549	. 							old_sub_kind = dst_type->__find_public_src
   550	. 								(src2dst, result.dst_ptr, src_type, src_ptr);
   551	. 
   552	. 						if (new_sub_kind >= __not_contained)
   553	. 							;// already calculated
   554	. 						else if (contained_p (old_sub_kind)
   555	. 								&& (!virtual_p (old_sub_kind)
   556	. 									|| !(__flags & __diamond_shaped_mask)))
   557	. 							// Already found inside the other choice, and it was
   558	. 							// non-virtual or we are not diamond shaped.
   559	. 							new_sub_kind = __not_contained;
   560	. 						else
   561	. 							new_sub_kind = dst_type->__find_public_src
   562	. 								(src2dst, result2.dst_ptr, src_type, src_ptr);
   563	. 					}
   564	. 
   565	. 					// Neither sub_kind can be contained_ambig -- we bail out early
   566	. 					// when we find those.
   567	. 					if (contained_p (__sub_kind (new_sub_kind ^ old_sub_kind)))
   568	. 					{
   569	. 						// Only on one choice, not ambiguous.
   570	. 						if (contained_p (new_sub_kind))
   571	. 						{
   572	. 							// Only in new.
   573	. 							result.dst_ptr = result2.dst_ptr;
   574	. 							result.whole2dst = result2.whole2dst;
   575	. 							result_ambig = false;
   576	. 							old_sub_kind = new_sub_kind;
   577	. 						}
   578	. 						result.dst2src = old_sub_kind;
   579	. 						if (public_p (result.dst2src))
   580	. 							return false; // Can't be an ambiguating downcast for later discovery.
   581	. 						if (!virtual_p (result.dst2src))
   582	. 							return false; // Found non-virtually can't be bettered
   583	. 					}
   584	. 					else if (contained_p (__sub_kind (new_sub_kind & old_sub_kind)))
   585	. 					{
   586	. 						// In both.
   587	. 						result.dst_ptr = NULL;
   588	. 						result.dst2src = __contained_ambig;
   589	. 						return true;  // Fail.
   590	. 					}
   591	. 					else
   592	. 					{
   593	. 						// In neither publicly, ambiguous for the moment, but keep
   594	. 						// looking. It is possible that it was private in one or
   595	. 						// both and therefore we should fail, but that's just tough.
   596	. 						result.dst_ptr = NULL;
   597	. 						result.dst2src = __not_contained;
   598	. 						result_ambig = true;
   599	. 					}
   600	. 				}
   601	. 
   602	. 				if (result.whole2src == __contained_private)
   603	. 					// We found SRC_PTR as a private non-virtual base, therefore all
   604	. 					// cross casts will fail. We have already found a down cast, if
   605	. 					// there is one.
   606	. 					return result_ambig;
   607	. 			}
   608	. 
   609	. 			if (skipped && first_pass)
   610	. 			{
   611	. 				// We didn't find dst where we expected it, so let's go back and try
   612	. 				// the bases we skipped (if any).
   613	. 				first_pass = false;
   614	. 				goto again;
   615	. 			}
   616	. 
   617	. 			return result_ambig;
   618	. 		}
   619	. 
   620	. 	bool __vmi_class_type_info::
   621	. 		__do_upcast (const __class_type_info *dst, const void *obj_ptr,
   622	. 				__upcast_result &__restrict result) const
   623	. 		{
   624	. 			if (__class_type_info::__do_upcast (dst, obj_ptr, result))
   625	. 				return true;
   626	. 
   627	. 			int src_details = result.src_details;
   628	. 			if (src_details & __flags_unknown_mask)
   629	. 				src_details = __flags;
   630	. 
   631	. 			for (std::size_t i = __base_count; i--;)
   632	. 			{
   633	. 				__upcast_result result2 (src_details);
   634	. 				const void *base = obj_ptr;
   635	. 				ptrdiff_t offset = __base_info[i].__offset ();
   636	. 				bool is_virtual = __base_info[i].__is_virtual_p ();
   637	. 				bool is_public = __base_info[i].__is_public_p ();
   638	. 
   639	. 				if (!is_public && !(src_details & __non_diamond_repeat_mask))
   640	. 					// original cannot have an ambiguous base, so skip private bases
   641	. 					continue;
   642	. 
   643	. 				if (base)
   644	. 					base = convert_to_base (base, is_virtual, offset);
   645	. 
   646	. 				if (__base_info[i].__base_type->__do_upcast (dst, base, result2))
   647	. 				{
   648	. 					if (result2.base_type == nonvirtual_base_type && is_virtual)
   649	. 						result2.base_type = __base_info[i].__base_type;
   650	. 					if (contained_p (result2.part2dst) && !is_public)
   651	. 						result2.part2dst = __sub_kind (
   652	. 								result2.part2dst & 
   653	. 								~__contained_public_mask
   654	. 								);
   655	. 
   656	. 					if (!result.base_type)
   657	. 					{
   658	. 						result = result2;
   659	. 						if (!contained_p (result.part2dst))
   660	. 							return true; // found ambiguously
   661	. 
   662	. 						if (result.part2dst & __contained_public_mask)
   663	. 						{
   664	. 							if (!(__flags & __non_diamond_repeat_mask))
   665	. 								return true;  // cannot have an ambiguous other base
   666	. 						}
   667	. 						else
   668	. 						{
   669	. 							if (!virtual_p (result.part2dst))
   670	. 								return true; // cannot have another path
   671	. 							if (!(__flags & __diamond_shaped_mask))
   672	. 								return true; // cannot have a more accessible path
   673	. 						}
   674	. 					}
   675	. 					else if (result.dst_ptr != result2.dst_ptr)
   676	. 					{
   677	. 						// Found an ambiguity.
   678	. 						result.dst_ptr = NULL;
   679	. 						result.part2dst = __contained_ambig;
   680	. 						return true;
   681	. 					}
   682	. 					else if (result.dst_ptr)
   683	. 					{
   684	. 						// Ok, found real object via a virtual path.
   685	. 						result.part2dst
   686	. 							= __sub_kind (result.part2dst | result2.part2dst);
   687	. 					}
   688	. 					else
   689	. 					{
   690	. 						// Dealing with a null pointer, need to check vbase
   691	. 						// containing each of the two choices.
   692	. 						if (result2.base_type == nonvirtual_base_type
   693	. 								|| result.base_type == nonvirtual_base_type
   694	. 								|| !(*result2.base_type == *result.base_type))
   695	. 						{
   696	. 							// Already ambiguous, not virtual or via different virtuals.
   697	. 							// Cannot match.
   698	. 							result.part2dst = __contained_ambig;
   699	. 							return true;
   700	. 						}
   701	. 						result.part2dst
   702	. 							= __sub_kind (result.part2dst | result2.part2dst);
   703	. 					}
   704	. 				}
   705	. 			}
   706	. 			return result.part2dst != __unknown;
   707	. 		}
   708	. 
   709	. }
FILE: END: lib/type_info.cc
FILE: START: lib/unistd.cc
HASH: MD5: 79a927b0d158f2d19428c59e463d7785
     1	. #include <syscall.hh>
     2	. 
     3	. extern "C" {
     4	. 	long errno=0;
     5	. };
FILE: END: lib/unistd.cc
FILE: START: lib/write_buf.cc
HASH: MD5: 50ee076972fe93a41ec35f6afb7ab00f
     1	. #include <write_buf.hh>
     2	. 
     3	. static char isprint_chars[] = (
     4	.     " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNO"
     5	.     "PQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
     6	.     );
     7	. class isprint_t
     8	. {
     9	.   char res[256];
    10	.   public:
    11	.   isprint_t()
    12	.   {
    13	.     memset(res,0,sizeof(res));
    14	.     for(char *pos=isprint_chars; *pos; ++pos)
    15	.     {
    16	.       res[*pos]=1;
    17	.     };
    18	.     res['\n']=1;
    19	.   };
    20	.   bool operator()(char ch) const
    21	.   {
    22	.     return res[ch];
    23	.   };
    24	. };
    25	. const isprint_t isprint;
    26	. 
    27	. void doit() {
    28	.   write_buf<1,4096>buf(88);
    29	.   buf.close();
    30	.   buf.flush();
    31	. };
FILE: END: lib/write_buf.cc
FILE: START: sbin/arch
HASH: MD5: 0e8a1ee021364050e37241c7f68da184
     1	. #!/bin/bash
     2	. 
     3	. die(){
     4	.   echo $(printf "$@") >&2;
     5	.   exit 1;
     6	. }
     7	. n=$(($#))
     8	. for i; do
     9	.   set -- "$@" ${i#lib/}  
    10	. done
    11	. shift ${n}
    12	. 
    13	. cd lib
    14	. case "$1" in
    15	.   (*.a|*.aa)
    16	.     lib="$1"
    17	.     
    18	.     shift
    19	.     ;;
    20	.   (*)
    21	.     die "bad lib name %q" "$l"
    22	.     ;;
    23	. esac
    24	. for s; do
    25	.   case "$s" in
    26	.     (*.oo)
    27	.       test -f "$s" || die "missing file %s" $s
    28	.       ;;
    29	.     (*)
    30	.       die "bad archive member name: %q" "$s"
    31	.       ;;
    32	.   esac
    33	. done
    34	. 
    35	. ar r $lib "$@"
    36	. ranlib "$lib"
    37	. ar t "$lib" | sed "s,^,$lib: $(dirname $lib)/," > /dev/null
    38	. 
FILE: END: sbin/arch
FILE: START: sbin/casm
HASH: MD5: cd9565a630003aea4a0cf7c982559796
     1	. #!/bin/bash
     2	. set -e
     3	. trap 'die "${BASH_COMMAND}" returned $?' ERR
     4	. set -o pipefail
     5	. act=-c ii=.S oo=.oo flags=@etc/asmflags
     6	. die(){ echo $(printf "$@") >&2; exit 1; }
     7	. o="$1"
     8	. shift
     9	. r=${o%$oo}
    10	. test -z "$oo" || test "x$r" != "x$o" || die "bad ext $o"
    11	. i=$r$ii
    12	. d=$o.d
    13	. set -- "$i" "$@"
    14	. test -n "$oo" || set -- "-Wl,--start-group" "$@" "-Wl,--end-group"  -Wl,--verbose
    15	. set -- "$@" -o "$o" 
    16	. set -- "$@" $flags
    17	. set -- "$@" -MD -MF "$d" -MP -MT "$o"
    18	. set -- "g++" "$@" $act 
    19	. #printf ' (%s)\n' "$@"
    20	. log=log/$o.log
    21	. mkdir -p $(dirname "$log")
    22	. echo "$@" >&2
    23	. report "$@" > log/$o.log 2>&1 && exit 0
    24	. n=$?
    25	. echo >&2 "$log:1:log"
    26	. cat $log
    27	. die "$* returned %d" $n
FILE: END: sbin/casm
FILE: START: sbin/clean
HASH: MD5: 0e1932f292bba8a6db920093cb006c23
     1	. #!/bin/bash
     2	. 
     3	. set -xv
     4	. serdate=$(serdate)
     5	. mkdir -p trash/$serdate
     6	. mv $(lsfiles "$@") trash/$serdate
FILE: END: sbin/clean
FILE: START: sbin/comp
HASH: MD5: 2afa14316f584eae6fe1d7ed6ed8e5a5
     1	. #!/bin/bash
     2	. set -e
     3	. trap 'die "${BASH_COMMAND}" returned $?' ERR
     4	. set -o pipefail
     5	. act=-c ii=.ii oo=.oo flags=@etc/cxxflags
     6	. die(){ echo $(printf "$@") >&2; exit 1; }
     7	. o="$1"
     8	. shift
     9	. r=${o%$oo}
    10	. test -z "$oo" || test "x$r" != "x$o" || die "bad ext $o"
    11	. i=$r$ii
    12	. d=$o.d
    13	. set -- "$i" "$@"
    14	. test -n "$oo" || set -- "-Wl,--start-group" "$@" "-Wl,--end-group"  -Wl,--verbose
    15	. set -- "$@" -o "$o" 
    16	. set -- "$@" $flags
    17	. set -- "$@" -MD -MF "$d" -MP -MT "$o"
    18	. set -- "g++" "$@" $act 
    19	. #printf ' (%s)\n' "$@"
    20	. log=log/$o.log
    21	. mkdir -p $(dirname "$log")
    22	. echo "$@" >&2
    23	. report "$@" > log/$o.log 2>&1 && exit 0
    24	. n=$?
    25	. echo >&2 "$log:1:log"
    26	. cat $log
    27	. die "$* returned %d" $n
FILE: END: sbin/comp
FILE: START: sbin/genheaders.pl
HASH: MD5: bf7c0245dc248bcae660a86ca14ff995
     1	. #/usr/bin/perl
     2	. 
     3	. use strict;
     4	. use warnings;
     5	. use autodie qw(:all);
     6	. use Data::Dumper;
     7	. $|++;
     8	. use FindBin;
     9	. use lib "$FindBin::Bin";
    10	. 
    11	. 
    12	. our(%calls);
    13	. require "syscall.pl" or die "$@";
    14	. 
    15	. sub code_sort {
    16	. 	return $calls{$a}{code} <=> $calls{$b}{code};
    17	. };
    18	. $\="\n";
    19	. $,=" ";
    20	. 
    21	. print q(#file __FILE__);
    22	. print q(#line __LINE__);
    23	. print q(extern "C" {);
    24	. for my $name (sort {code_sort} keys %calls) {
    25	. 	our(%call);
    26	. 	local *call=$calls{$name};
    27	. 	next unless $call{impl};
    28	. 	my @args = @{$call{args}};
    29	. 	for(@args) {
    30	. 		$_=join(" ",@$_);
    31	. 	};
    32	. 	@args=join(", ", @args);
    33	. 	my $rtype=$call{ret};
    34	.         print "// __NR__", $call{name}, "=", $call{code}, "\n";
    35	. 	print "inline $rtype $name(@args)";
    36	. 	print "  __attribute__((__always_inline__));";
    37	. };
    38	. print q(});
FILE: END: sbin/genheaders.pl
FILE: START: sbin/genlist.pl
HASH: MD5: 4725fbf793ab33a1174022472ef60a00
     1	. #/usr/bin/perl
     2	. 
     3	. use strict;
     4	. use warnings;
     5	. use Data::Dumper;
     6	. $|++;
     7	. our(%calls);
     8	. use FindBin;
     9	. use lib "$FindBin::Bin";
    10	. require "syscall.pl" or die "$@";
    11	. 
    12	. sub code_sort {
    13	. 	return $calls{$a}{code} <=> $calls{$b}{code};
    14	. };
    15	. $\="\n";
    16	. $,=" ";
    17	. 
    18	. print q(#file script/genheaders.pl);
    19	. print q(#line 1);
    20	. print q(extern "C" {);
    21	. for my $name (sort {code_sort} keys %calls) {
    22	. 	our(%call);
    23	. 	local *call=$calls{$name};
    24	. 	next unless $call{impl};
    25	. 	my @args = @{$call{args}};
    26	. 	for(@args) {
    27	. 		$_=join(" ",@$_);
    28	. 	};
    29	. 	@args=join(", ", @args);
    30	. 	my $rtype=$call{ret};
    31	.         print "// __NR__", $call{name}, "=", $call{code}, "\n";
    32	. 	print "inline $rtype $name(@args)";
    33	. 	print "  __attribute__((__always_inline__));";
    34	. };
    35	. print q(});
FILE: END: sbin/genlist.pl
FILE: START: sbin/genstrerror.pl
HASH: MD5: 5d4bcc60527a2e4cc67a46cd9bd2914c
     1	. #!/usr/bin/perl
     2	. use warnings;
     3	. use strict;
     4	. use autodie(qw(:all));
     5	. $|++;
     6	. $\="\n";
     7	. 
     8	. die "$@" if "$@";
     9	. 
    10	. my $fn = "lib/strerror_list.cc";
    11	. open(STDOUT,">$fn.new");
    12	. print "// do not edit this file.  It will be regenerated.\n";
    13	. print "#include <c_str.hh>\n";
    14	. print "\n";
    15	. print "static c_str strerror_v[]={\n";
    16	. print "  \"Unknown Error(###)\",\n";
    17	. my $i=1;
    18	. while($i) {
    19	.   $!=$i;
    20	.   for("$!") {
    21	.     if( $i>134 && /Unknown Error/i ) {
    22	.       $i=0;
    23	.     } else {
    24	.       print " \"$_\",";
    25	.       $i++;
    26	.     };
    27	.   };
    28	. };
    29	. print "};\n";
    30	. print <DATA>;
    31	. rename("$fn.new",$fn);
    32	. __DATA__
    33	. 
    34	. static size_t strerror_c = sizeof(strerror_v)/sizeof(strerror_v[0]);
    35	. namespace sys {
    36	.   c_str no_err(L("No Error"));
    37	.   const c_str &strerror(errno_t err) {
    38	.     if(!err)
    39	.       return no_err;
    40	.     else if(err<strerror_c)
    41	.       return strerror_v[err];
    42	.     else
    43	.       return strerror_v[0];
    44	.   };  
    45	. }
FILE: END: sbin/genstrerror.pl
FILE: START: sbin/gensyscall.pl
HASH: MD5: 1bf5d3806a415d2f7596988ba13d9772
     1	. #!/usr/bin/perl
     2	. $|++;
     3	. use strict;
     4	. use warnings;
     5	. use autodie qw(:all);
     6	. use Data::Dumper;
     7	. use FindBin;
     8	. our(%calls);
     9	. my $dump="$FindBin::Bin/syscall.pl";
    10	. require $dump or die "$@";
    11	. my @keys = qw(code name impl args ret);
    12	. 
    13	. BEGIN {
    14	.   open(STDERR,"|less -FS");
    15	.   open(STDOUT,">&STDERR");
    16	. };
    17	. END {
    18	.   close(STDOUT);
    19	.   close(STDERR) or warn "less returned non zero\n";
    20	. };
    21	. ##
    22	. ## Put the code to modify the %calls hash here, and the modified version
    23	. ## Will appear in syscall.pl.new
    24	. ##
    25	. $\="\n";
    26	. $,=" ";
    27	. our(%call);
    28	. sub fmt() {
    29	. 	my $name=$call{name};
    30	. 	@_=@{$call{args}};
    31	. 	for(@_){
    32	. 		$_=join(" ", @$_);
    33	. 	};
    34	. 	return "$name(",join(",",@_),")";
    35	. };
    36	. my %args;
    37	. #print Dumper \%calls;
    38	. for(keys %calls){
    39	.   local *call=$calls{$_};
    40	.   next unless $call{impl};
    41	.   for(@{$call{args}}){
    42	.     next unless ($_->[0] eq "istr_t") || ($_->[0] eq "ostr_t");
    43	.     if( $_->[1] eq "oldname" ) {
    44	.       $_->[1] = "opath";
    45	.     } elsif ( $_->[1] eq "newname" ) {
    46	.       $_->[1] = "npath";
    47	.     };
    48	.   };
    49	. };
    50	. #print Dumper \%calls;
    51	. ##
    52	. ## Don't change the code after this.
    53	. ##
    54	. {
    55	. 	my $calls=\%calls;
    56	. 	open(STDOUT,">$dump.new") or die "open:$!";
    57	. 	my @calls = sort { $calls{$a}{code} <=> $calls{$b}{code} } keys %calls;
    58	. 	local $Data::Dumper::Sortkeys=sub
    59	. 	{
    60	. 		if( $_[0] eq $calls ) {
    61	. 			return \@calls;
    62	. 		} else {
    63	. 			return [ grep { exists $_[0]->{$_} } @keys ];
    64	. 		};
    65	. 	};
    66	. 	local $Data::Dumper::Indent=1;
    67	. 	print Data::Dumper->Dump([\%calls],[qw(*calls)]);
    68	. 	system("mv $dump $dump.old");
    69	. 	system("mv $dump.new $dump");
    70	. }
FILE: END: sbin/gensyscall.pl
FILE: START: sbin/light-trace
HASH: MD5: 0e397485e8a4bd74e4ef61645e16920d
     1	. #!/bin/bash
     2	. 
     3	. exec strace -etrace=read,write,select,bind,connect,accept "$@"
FILE: END: sbin/light-trace
FILE: START: sbin/link
HASH: MD5: 9ceb978f7c4d2a8539374d3b49ffce44
     1	. #!/bin/bash
     2	. set -e
     3	. trap 'die "${BASH_COMMAND}" returned $?' ERR
     4	. set -o pipefail
     5	. act= ii=.oo oo= flags=@etc/ld_flags
     6	. die(){ echo $(printf "$@") >&2; exit 1; }
     7	. o="$1"
     8	. shift
     9	. r=${o%$oo}
    10	. test -z "$oo" || test "x$r" != "x$o" || die "bad ext $o"
    11	. i=$r$ii
    12	. d=$o.d
    13	. set -- "$i" "$@"
    14	. test -n "$oo" || set -- "-Wl,--start-group" "$@" "-Wl,--end-group"  -Wl,--verbose
    15	. set -- "$@" -o "$o" 
    16	. set -- "$@" $flags
    17	. set -- "$@" -MD -MF "$d" -MP -MT "$o"
    18	. set -- "g++" "$@" $act 
    19	. #printf ' (%s)\n' "$@"
    20	. log=log/$o.log
    21	. mkdir -p $(dirname "$log")
    22	. echo "$@" >&2
    23	. report "$@" > log/$o.log 2>&1 && exit 0
    24	. n=$?
    25	. echo >&2 "$log:1:log"
    26	. cat $log
    27	. die "$* returned %d" $n
FILE: END: sbin/link
FILE: START: sbin/make
HASH: MD5: 81b526576981c572b19b21de225e70f2
     1	. #!/usr/bin/perl
     2	. $|++;
     3	. 
     4	. use common::sense;
     5	. use Nobody::Util;
     6	. use Env qw($HOME @PATH);
     7	. $ENV{LANG}="C";
     8	. open(STDIN, "</dev/null");
     9	. system("mkdir -p log") unless -d "log";
    10	. open(STDOUT,"|tee log/make.out");
    11	. open(STDERR,">&STDOUT");
    12	. exec("/usr/bin/make",@ARGV);
    13	. die("exec:/usr/bin/make:$!");
    14	. BEGIN {
    15	.   my %keep;
    16	.   $keep{$_}=1 for qw(PATH HOME LANG TZ TERM );
    17	.   for( sort keys %ENV) {
    18	.     next if $keep{$_};
    19	.     delete $ENV{$_};
    20	.   }
    21	. }
FILE: END: sbin/make
FILE: START: sbin/prec
HASH: MD5: e88a57fd4d40711ec809ab16fb148b30
     1	. #!/bin/bash
     2	. set -e
     3	. trap 'die "${BASH_COMMAND}" returned $?' ERR
     4	. set -o pipefail
     5	. act=-E ii=.cc oo=.ii flags=@etc/cppflags
     6	. die(){ echo $(printf "$@") >&2; exit 1; }
     7	. o="$1"
     8	. shift
     9	. r=${o%$oo}
    10	. test -z "$oo" || test "x$r" != "x$o" || die "bad ext $o"
    11	. i=$r$ii
    12	. d=$o.d
    13	. set -- "$i" "$@"
    14	. test -n "$oo" || set -- "-Wl,--start-group" "$@" "-Wl,--end-group"  -Wl,--verbose
    15	. set -- "$@" -o "$o" 
    16	. set -- "$@" $flags
    17	. set -- "$@" -MD -MF "$d" -MP -MT "$o"
    18	. set -- "g++" "$@" $act 
    19	. #printf ' (%s)\n' "$@"
    20	. log=log/$o.log
    21	. mkdir -p $(dirname "$log")
    22	. echo "$@" >&2
    23	. report "$@" > log/$o.log 2>&1 && exit 0
    24	. n=$?
    25	. echo >&2 "$log:1:log"
    26	. cat $log
    27	. die "$* returned %d" $n
FILE: END: sbin/prec
FILE: START: sbin/start-many.sh
HASH: MD5: aa57ffb092df684cab686eed4f41fc5e
     1	. for i in 2 3 4 5;
     2	. do
     3	.   tmux send-keys -t $i $'simchat\n'
     4	. done
FILE: END: sbin/start-many.sh
FILE: START: sbin/syscall.pl
HASH: MD5: 5b19470e25a9432706cd96f492f3293a
     1	. %calls = (
     2	.   'read' => {
     3	.     'code' => 0,
     4	.     'name' => 'read',
     5	.     'impl' => 1,
     6	.     'args' => [
     7	.       [
     8	.         'fd_t',
     9	.         'fd'
    10	.       ],
    11	.       [
    12	.         'ostr_t',
    13	.         'buf'
    14	.       ],
    15	.       [
    16	.         'size_t',
    17	.         'count'
    18	.       ]
    19	.     ],
    20	.     'ret' => 'ssize_t'
    21	.   },
    22	.   'sys_write' => {
    23	.     'code' => 1,
    24	.     'name' => 'write',
    25	.     'impl' => 1,
    26	.     'args' => [
    27	.       [
    28	.         'fd_t',
    29	.         'fd'
    30	.       ],
    31	.       [
    32	.         'istr_t',
    33	.         'buf'
    34	.       ],
    35	.       [
    36	.         'size_t',
    37	.         'count'
    38	.       ]
    39	.     ],
    40	.     'ret' => 'ssize_t'
    41	.   },
    42	.   'open' => {
    43	.     'code' => 2,
    44	.     'name' => 'open',
    45	.     'impl' => 1,
    46	.     'args' => [
    47	.       [
    48	.         'istr_t',
    49	.         'path'
    50	.       ],
    51	.       [
    52	.         'int',
    53	.         'flags'
    54	.       ],
    55	.       [
    56	.         'int',
    57	.         'mode'
    58	.       ]
    59	.     ],
    60	.     'ret' => 'fd_t'
    61	.   },
    62	.   'close' => {
    63	.     'code' => 3,
    64	.     'name' => 'close',
    65	.     'impl' => 1,
    66	.     'args' => [
    67	.       [
    68	.         'fd_t',
    69	.         'fd'
    70	.       ]
    71	.     ],
    72	.     'ret' => 'int'
    73	.   },
    74	.   'stat' => {
    75	.     'code' => 4,
    76	.     'name' => 'stat',
    77	.     'impl' => 1,
    78	.     'args' => [
    79	.       [
    80	.         'istr_t',
    81	.         'path'
    82	.       ],
    83	.       [
    84	.         'stat_p',
    85	.         'statbuf'
    86	.       ]
    87	.     ],
    88	.     'ret' => 'int'
    89	.   },
    90	.   'fstat' => {
    91	.     'code' => 5,
    92	.     'name' => 'fstat',
    93	.     'impl' => 1,
    94	.     'args' => [
    95	.       [
    96	.         'fd_t',
    97	.         'fd'
    98	.       ],
    99	.       [
   100	.         'stat_p',
   101	.         'statbuf'
   102	.       ]
   103	.     ],
   104	.     'ret' => 'int'
   105	.   },
   106	.   'lstat' => {
   107	.     'code' => 6,
   108	.     'name' => 'lstat',
   109	.     'impl' => 1,
   110	.     'args' => [
   111	.       [
   112	.         'istr_t',
   113	.         'path'
   114	.       ],
   115	.       [
   116	.         'stat_p',
   117	.         'statbuf'
   118	.       ]
   119	.     ],
   120	.     'ret' => 'int'
   121	.   },
   122	.   'poll' => {
   123	.     'code' => 7,
   124	.     'name' => 'poll',
   125	.     'impl' => 1,
   126	.     'args' => [
   127	.       [
   128	.         'pollfd_p',
   129	.         'ufds'
   130	.       ],
   131	.       [
   132	.         'unsigned',
   133	.         'nfds'
   134	.       ],
   135	.       [
   136	.         'long',
   137	.         'timeout_msecs'
   138	.       ]
   139	.     ],
   140	.     'ret' => 'int'
   141	.   },
   142	.   'lseek' => {
   143	.     'code' => 8,
   144	.     'name' => 'lseek',
   145	.     'impl' => 1,
   146	.     'args' => [
   147	.       [
   148	.         'fd_t',
   149	.         'fd'
   150	.       ],
   151	.       [
   152	.         'off_t',
   153	.         'offset'
   154	.       ],
   155	.       [
   156	.         'unsigned',
   157	.         'origin'
   158	.       ]
   159	.     ],
   160	.     'ret' => 'int'
   161	.   },
   162	.   'mmap' => {
   163	.     'code' => 9,
   164	.     'name' => 'mmap',
   165	.     'impl' => 1,
   166	.     'args' => [
   167	.       [
   168	.         'void*',
   169	.         'addr'
   170	.       ],
   171	.       [
   172	.         'size_t',
   173	.         'len'
   174	.       ],
   175	.       [
   176	.         'int',
   177	.         'prot'
   178	.       ],
   179	.       [
   180	.         'int',
   181	.         'flags'
   182	.       ],
   183	.       [
   184	.         'fd_t',
   185	.         'fd'
   186	.       ],
   187	.       [
   188	.         'off_t',
   189	.         'off'
   190	.       ]
   191	.     ],
   192	.     'ret' => 'char*'
   193	.   },
   194	.   'mprotect' => {
   195	.     'code' => 10,
   196	.     'name' => 'mprotect',
   197	.     'impl' => 1,
   198	.     'args' => [
   199	.       [
   200	.         'uint64_t',
   201	.         'start'
   202	.       ],
   203	.       [
   204	.         'size_t',
   205	.         'len'
   206	.       ],
   207	.       [
   208	.         'uint64_t',
   209	.         'prot'
   210	.       ]
   211	.     ],
   212	.     'ret' => 'int'
   213	.   },
   214	.   'munmap' => {
   215	.     'code' => 11,
   216	.     'name' => 'munmap',
   217	.     'impl' => 1,
   218	.     'args' => [
   219	.       [
   220	.         'uint64_t',
   221	.         'addr'
   222	.       ],
   223	.       [
   224	.         'size_t',
   225	.         'len'
   226	.       ]
   227	.     ],
   228	.     'ret' => 'int'
   229	.   },
   230	.   'brk' => {
   231	.     'code' => 12,
   232	.     'name' => 'brk',
   233	.     'impl' => 1,
   234	.     'args' => [
   235	.       [
   236	.         'void_p',
   237	.         'brk'
   238	.       ]
   239	.     ],
   240	.     'ret' => 'int'
   241	.   },
   242	.   'rt_sigaction' => {
   243	.     'code' => 13,
   244	.     'name' => 'rt_sigaction',
   245	.     'impl' => 1,
   246	.     'args' => [
   247	.       [
   248	.         'int',
   249	.         'sig'
   250	.       ],
   251	.       [
   252	.         'sigaction_p',
   253	.         'act'
   254	.       ],
   255	.       [
   256	.         'sigaction_p',
   257	.         'oact'
   258	.       ]
   259	.     ],
   260	.     'ret' => 'int'
   261	.   },
   262	.   'rt_sigprocmask' => {
   263	.     'code' => 14,
   264	.     'name' => 'rt_sigprocmask',
   265	.     'impl' => 1,
   266	.     'args' => [
   267	.       [
   268	.         'int',
   269	.         'how'
   270	.       ],
   271	.       [
   272	.         'sigset_p',
   273	.         'nset'
   274	.       ],
   275	.       [
   276	.         'sigset_p',
   277	.         'oset'
   278	.       ],
   279	.       [
   280	.         'size_t',
   281	.         'sigsetsize'
   282	.       ]
   283	.     ],
   284	.     'ret' => 'int'
   285	.   },
   286	.   'rt_sigreturn' => {
   287	.     'code' => 15,
   288	.     'name' => 'rt_sigreturn',
   289	.     'impl' => 1,
   290	.     'args' => [
   291	.       [
   292	.         'uint64_t',
   293	.         '__unused'
   294	.       ]
   295	.     ],
   296	.     'ret' => 'int'
   297	.   },
   298	.   'ioctl' => {
   299	.     'code' => 16,
   300	.     'name' => 'ioctl',
   301	.     'impl' => 1,
   302	.     'args' => [
   303	.       [
   304	.         'fd_t',
   305	.         'fd'
   306	.       ],
   307	.       [
   308	.         'unsigned',
   309	.         'cmd'
   310	.       ],
   311	.       [
   312	.         'uint64_t',
   313	.         'arg'
   314	.       ]
   315	.     ],
   316	.     'ret' => 'int'
   317	.   },
   318	.   'pread64' => {
   319	.     'code' => 17,
   320	.     'name' => 'pread64',
   321	.     'impl' => 1,
   322	.     'args' => [
   323	.       [
   324	.         'fd_t',
   325	.         'fd'
   326	.       ],
   327	.       [
   328	.         'ostr_t',
   329	.         'buf'
   330	.       ],
   331	.       [
   332	.         'size_t',
   333	.         'count'
   334	.       ],
   335	.       [
   336	.         'off_t',
   337	.         'pos'
   338	.       ]
   339	.     ],
   340	.     'ret' => 'int'
   341	.   },
   342	.   'pwrite64' => {
   343	.     'code' => 18,
   344	.     'name' => 'pwrite64',
   345	.     'impl' => 1,
   346	.     'args' => [
   347	.       [
   348	.         'fd_t',
   349	.         'fd'
   350	.       ],
   351	.       [
   352	.         'istr_t',
   353	.         'buf'
   354	.       ],
   355	.       [
   356	.         'size_t',
   357	.         'count'
   358	.       ],
   359	.       [
   360	.         'off_t',
   361	.         'pos'
   362	.       ]
   363	.     ],
   364	.     'ret' => 'int'
   365	.   },
   366	.   'readv' => {
   367	.     'code' => 19,
   368	.     'name' => 'readv',
   369	.     'impl' => 1,
   370	.     'args' => [
   371	.       [
   372	.         'fd_t',
   373	.         'fd'
   374	.       ],
   375	.       [
   376	.         'iovec_p',
   377	.         'vec'
   378	.       ],
   379	.       [
   380	.         'uint64_t',
   381	.         'vlen'
   382	.       ]
   383	.     ],
   384	.     'ret' => 'int'
   385	.   },
   386	.   'writev' => {
   387	.     'code' => 20,
   388	.     'name' => 'writev',
   389	.     'impl' => 1,
   390	.     'args' => [
   391	.       [
   392	.         'fd_t',
   393	.         'fd'
   394	.       ],
   395	.       [
   396	.         'iovec_p',
   397	.         'vec'
   398	.       ],
   399	.       [
   400	.         'uint64_t',
   401	.         'vlen'
   402	.       ]
   403	.     ],
   404	.     'ret' => 'int'
   405	.   },
   406	.   'access' => {
   407	.     'code' => 21,
   408	.     'name' => 'access',
   409	.     'impl' => 1,
   410	.     'args' => [
   411	.       [
   412	.         'istr_t',
   413	.         'path'
   414	.       ],
   415	.       [
   416	.         'int',
   417	.         'mode'
   418	.       ]
   419	.     ],
   420	.     'ret' => 'int'
   421	.   },
   422	.   'pipe' => {
   423	.     'code' => 22,
   424	.     'name' => 'pipe',
   425	.     'impl' => 1,
   426	.     'args' => [
   427	.       [
   428	.         'fd_p',
   429	.         'filedes'
   430	.       ]
   431	.     ],
   432	.     'ret' => 'int'
   433	.   },
   434	.   'select' => {
   435	.     'code' => 23,
   436	.     'name' => 'select',
   437	.     'impl' => 1,
   438	.     'args' => [
   439	.       [
   440	.         'int',
   441	.         'n'
   442	.       ],
   443	.       [
   444	.         'fd_set_p',
   445	.         'inp'
   446	.       ],
   447	.       [
   448	.         'fd_set_p',
   449	.         'outp'
   450	.       ],
   451	.       [
   452	.         'fd_set_p',
   453	.         'exp'
   454	.       ],
   455	.       [
   456	.         'timeval_p',
   457	.         'tvp'
   458	.       ]
   459	.     ],
   460	.     'ret' => 'int'
   461	.   },
   462	.   'sched_yield' => {
   463	.     'code' => 24,
   464	.     'name' => 'sched_yield',
   465	.     'impl' => 1,
   466	.     'args' => [],
   467	.     'ret' => 'int'
   468	.   },
   469	.   'mremap' => {
   470	.     'code' => 25,
   471	.     'name' => 'mremap',
   472	.     'impl' => 1,
   473	.     'args' => [
   474	.       [
   475	.         'uint64_t',
   476	.         'addr'
   477	.       ],
   478	.       [
   479	.         'uint64_t',
   480	.         'old_len'
   481	.       ],
   482	.       [
   483	.         'uint64_t',
   484	.         'new_len'
   485	.       ],
   486	.       [
   487	.         'uint64_t',
   488	.         'flags'
   489	.       ],
   490	.       [
   491	.         'uint64_t',
   492	.         'new_addr'
   493	.       ]
   494	.     ],
   495	.     'ret' => 'int'
   496	.   },
   497	.   'msync' => {
   498	.     'code' => 26,
   499	.     'name' => 'msync',
   500	.     'impl' => 1,
   501	.     'args' => [
   502	.       [
   503	.         'uint64_t',
   504	.         'start'
   505	.       ],
   506	.       [
   507	.         'size_t',
   508	.         'len'
   509	.       ],
   510	.       [
   511	.         'int',
   512	.         'flags'
   513	.       ]
   514	.     ],
   515	.     'ret' => 'int'
   516	.   },
   517	.   'mincore' => {
   518	.     'code' => 27,
   519	.     'name' => 'mincore',
   520	.     'impl' => 1,
   521	.     'args' => [
   522	.       [
   523	.         'uint64_t',
   524	.         'start'
   525	.       ],
   526	.       [
   527	.         'size_t',
   528	.         'len'
   529	.       ],
   530	.       [
   531	.         'ostr_t',
   532	.         'vec'
   533	.       ]
   534	.     ],
   535	.     'ret' => 'int'
   536	.   },
   537	.   'madvise' => {
   538	.     'code' => 28,
   539	.     'name' => 'madvise',
   540	.     'impl' => 1,
   541	.     'args' => [
   542	.       [
   543	.         'uint64_t',
   544	.         'start'
   545	.       ],
   546	.       [
   547	.         'size_t',
   548	.         'len_in'
   549	.       ],
   550	.       [
   551	.         'int',
   552	.         'behavior'
   553	.       ]
   554	.     ],
   555	.     'ret' => 'int'
   556	.   },
   557	.   'shmget' => {
   558	.     'code' => 29,
   559	.     'name' => 'shmget',
   560	.     'impl' => 1,
   561	.     'args' => [
   562	.       [
   563	.         'key_t',
   564	.         'key'
   565	.       ],
   566	.       [
   567	.         'size_t',
   568	.         'size'
   569	.       ],
   570	.       [
   571	.         'int',
   572	.         'shmflg'
   573	.       ]
   574	.     ],
   575	.     'ret' => 'int'
   576	.   },
   577	.   'shmat' => {
   578	.     'code' => 30,
   579	.     'name' => 'shmat',
   580	.     'impl' => 1,
   581	.     'args' => [
   582	.       [
   583	.         'int',
   584	.         'shmid'
   585	.       ],
   586	.       [
   587	.         'ostr_t',
   588	.         'shmaddr'
   589	.       ],
   590	.       [
   591	.         'int',
   592	.         'shmflg'
   593	.       ]
   594	.     ],
   595	.     'ret' => 'int'
   596	.   },
   597	.   'shmctl' => {
   598	.     'code' => 31,
   599	.     'name' => 'shmctl',
   600	.     'impl' => 1,
   601	.     'args' => [
   602	.       [
   603	.         'int',
   604	.         'shmid'
   605	.       ],
   606	.       [
   607	.         'int',
   608	.         'cmd'
   609	.       ],
   610	.       [
   611	.         'shmid_ds_p',
   612	.         'buf'
   613	.       ]
   614	.     ],
   615	.     'ret' => 'int'
   616	.   },
   617	.   'dup' => {
   618	.     'code' => 32,
   619	.     'name' => 'dup',
   620	.     'impl' => 1,
   621	.     'args' => [
   622	.       [
   623	.         'unsigned',
   624	.         'fildes'
   625	.       ]
   626	.     ],
   627	.     'ret' => 'int'
   628	.   },
   629	.   'dup2' => {
   630	.     'code' => 33,
   631	.     'name' => 'dup2',
   632	.     'impl' => 1,
   633	.     'args' => [
   634	.       [
   635	.         'fd_t',
   636	.         'oldfd'
   637	.       ],
   638	.       [
   639	.         'fd_t',
   640	.         'newfd'
   641	.       ]
   642	.     ],
   643	.     'ret' => 'int'
   644	.   },
   645	.   'pause' => {
   646	.     'code' => 34,
   647	.     'name' => 'pause',
   648	.     'impl' => 1,
   649	.     'args' => [],
   650	.     'ret' => 'int'
   651	.   },
   652	.   'nanosleep' => {
   653	.     'code' => 35,
   654	.     'name' => 'nanosleep',
   655	.     'impl' => 1,
   656	.     'args' => [
   657	.       [
   658	.         'timespec_p',
   659	.         'rqtp'
   660	.       ],
   661	.       [
   662	.         'timespec_p',
   663	.         'rmtp'
   664	.       ]
   665	.     ],
   666	.     'ret' => 'int'
   667	.   },
   668	.   'getitimer' => {
   669	.     'code' => 36,
   670	.     'name' => 'getitimer',
   671	.     'impl' => 1,
   672	.     'args' => [
   673	.       [
   674	.         'int',
   675	.         'which'
   676	.       ],
   677	.       [
   678	.         'itimerval_p',
   679	.         'value'
   680	.       ]
   681	.     ],
   682	.     'ret' => 'int'
   683	.   },
   684	.   'alarm' => {
   685	.     'code' => 37,
   686	.     'name' => 'alarm',
   687	.     'impl' => 1,
   688	.     'args' => [
   689	.       [
   690	.         'unsigned',
   691	.         'seconds'
   692	.       ]
   693	.     ],
   694	.     'ret' => 'int'
   695	.   },
   696	.   'setitimer' => {
   697	.     'code' => 38,
   698	.     'name' => 'setitimer',
   699	.     'impl' => 1,
   700	.     'args' => [
   701	.       [
   702	.         'int',
   703	.         'which'
   704	.       ],
   705	.       [
   706	.         'itimerval_p',
   707	.         'value'
   708	.       ],
   709	.       [
   710	.         'itimerval_p',
   711	.         'ovalue'
   712	.       ]
   713	.     ],
   714	.     'ret' => 'int'
   715	.   },
   716	.   'getpid' => {
   717	.     'code' => 39,
   718	.     'name' => 'getpid',
   719	.     'impl' => 1,
   720	.     'args' => [],
   721	.     'ret' => 'int'
   722	.   },
   723	.   'sendfile' => {
   724	.     'code' => 40,
   725	.     'name' => 'sendfile',
   726	.     'impl' => 1,
   727	.     'args' => [
   728	.       [
   729	.         'int',
   730	.         'out_fd'
   731	.       ],
   732	.       [
   733	.         'int',
   734	.         'in_fd'
   735	.       ],
   736	.       [
   737	.         'off_p',
   738	.         'offset'
   739	.       ],
   740	.       [
   741	.         'size_t',
   742	.         'count'
   743	.       ]
   744	.     ],
   745	.     'ret' => 'int'
   746	.   },
   747	.   'socket' => {
   748	.     'code' => 41,
   749	.     'name' => 'socket',
   750	.     'impl' => 1,
   751	.     'args' => [
   752	.       [
   753	.         'int',
   754	.         'family'
   755	.       ],
   756	.       [
   757	.         'int',
   758	.         'type'
   759	.       ],
   760	.       [
   761	.         'int',
   762	.         'protocol'
   763	.       ]
   764	.     ],
   765	.     'ret' => 'int'
   766	.   },
   767	.   'connect' => {
   768	.     'code' => 42,
   769	.     'name' => 'connect',
   770	.     'impl' => 1,
   771	.     'args' => [
   772	.       [
   773	.         'fd_t',
   774	.         'fd'
   775	.       ],
   776	.       [
   777	.         'sockaddr_p',
   778	.         'uservaddr'
   779	.       ],
   780	.       [
   781	.         'int',
   782	.         'addrlen'
   783	.       ]
   784	.     ],
   785	.     'ret' => 'int'
   786	.   },
   787	.   'accept' => {
   788	.     'code' => 43,
   789	.     'name' => 'accept',
   790	.     'impl' => 1,
   791	.     'args' => [
   792	.       [
   793	.         'fd_t',
   794	.         'fd'
   795	.       ],
   796	.       [
   797	.         'sockaddr_p',
   798	.         'upeer_sockaddr'
   799	.       ],
   800	.       [
   801	.         'int32_p',
   802	.         'upeer_addrlen'
   803	.       ]
   804	.     ],
   805	.     'ret' => 'int'
   806	.   },
   807	.   'sendto' => {
   808	.     'code' => 44,
   809	.     'name' => 'sendto',
   810	.     'impl' => 1,
   811	.     'args' => [
   812	.       [
   813	.         'fd_t',
   814	.         'fd'
   815	.       ],
   816	.       [
   817	.         'void_p',
   818	.         'buff'
   819	.       ],
   820	.       [
   821	.         'size_t',
   822	.         'len'
   823	.       ],
   824	.       [
   825	.         'unsigned',
   826	.         'flags'
   827	.       ],
   828	.       [
   829	.         'sockaddr_p',
   830	.         'addr'
   831	.       ],
   832	.       [
   833	.         'int',
   834	.         'addr_len'
   835	.       ]
   836	.     ],
   837	.     'ret' => 'int'
   838	.   },
   839	.   'recvfrom' => {
   840	.     'code' => 45,
   841	.     'name' => 'recvfrom',
   842	.     'impl' => 1,
   843	.     'args' => [
   844	.       [
   845	.         'fd_t',
   846	.         'fd'
   847	.       ],
   848	.       [
   849	.         'void_p',
   850	.         'ubuf'
   851	.       ],
   852	.       [
   853	.         'size_t',
   854	.         'size'
   855	.       ],
   856	.       [
   857	.         'unsigned',
   858	.         'flags'
   859	.       ],
   860	.       [
   861	.         'sockaddr_p',
   862	.         'addr'
   863	.       ],
   864	.       [
   865	.         'int32_p',
   866	.         'addr_len'
   867	.       ]
   868	.     ],
   869	.     'ret' => 'int'
   870	.   },
   871	.   'sendmsg' => {
   872	.     'code' => 46,
   873	.     'name' => 'sendmsg',
   874	.     'impl' => 1,
   875	.     'args' => [
   876	.       [
   877	.         'fd_t',
   878	.         'fd'
   879	.       ],
   880	.       [
   881	.         'msghdr_p',
   882	.         'msg'
   883	.       ],
   884	.       [
   885	.         'unsigned',
   886	.         'flags'
   887	.       ]
   888	.     ],
   889	.     'ret' => 'int'
   890	.   },
   891	.   'recvmsg' => {
   892	.     'code' => 47,
   893	.     'name' => 'recvmsg',
   894	.     'impl' => 1,
   895	.     'args' => [
   896	.       [
   897	.         'fd_t',
   898	.         'fd'
   899	.       ],
   900	.       [
   901	.         'msghdr_p',
   902	.         'msg'
   903	.       ],
   904	.       [
   905	.         'unsigned',
   906	.         'flags'
   907	.       ]
   908	.     ],
   909	.     'ret' => 'int'
   910	.   },
   911	.   'shutdown' => {
   912	.     'code' => 48,
   913	.     'name' => 'shutdown',
   914	.     'impl' => 1,
   915	.     'args' => [
   916	.       [
   917	.         'fd_t',
   918	.         'fd'
   919	.       ],
   920	.       [
   921	.         'int',
   922	.         'how'
   923	.       ]
   924	.     ],
   925	.     'ret' => 'int'
   926	.   },
   927	.   'bind' => {
   928	.     'code' => 49,
   929	.     'name' => 'bind',
   930	.     'impl' => 1,
   931	.     'args' => [
   932	.       [
   933	.         'fd_t',
   934	.         'fd'
   935	.       ],
   936	.       [
   937	.         'sockaddr_p',
   938	.         'umyaddr'
   939	.       ],
   940	.       [
   941	.         'int',
   942	.         'addrlen'
   943	.       ]
   944	.     ],
   945	.     'ret' => 'int'
   946	.   },
   947	.   'listen' => {
   948	.     'code' => 50,
   949	.     'name' => 'listen',
   950	.     'impl' => 1,
   951	.     'args' => [
   952	.       [
   953	.         'fd_t',
   954	.         'fd'
   955	.       ],
   956	.       [
   957	.         'int',
   958	.         'backlog'
   959	.       ]
   960	.     ],
   961	.     'ret' => 'int'
   962	.   },
   963	.   'getsockname' => {
   964	.     'code' => 51,
   965	.     'name' => 'getsockname',
   966	.     'impl' => 1,
   967	.     'args' => [
   968	.       [
   969	.         'fd_t',
   970	.         'fd'
   971	.       ],
   972	.       [
   973	.         'sockaddr_p',
   974	.         'usockaddr'
   975	.       ],
   976	.       [
   977	.         'int32_p',
   978	.         'usockaddr_len'
   979	.       ]
   980	.     ],
   981	.     'ret' => 'int'
   982	.   },
   983	.   'getpeername' => {
   984	.     'code' => 52,
   985	.     'name' => 'getpeername',
   986	.     'impl' => 1,
   987	.     'args' => [
   988	.       [
   989	.         'fd_t',
   990	.         'fd'
   991	.       ],
   992	.       [
   993	.         'sockaddr_p',
   994	.         'usockaddr'
   995	.       ],
   996	.       [
   997	.         'int32_p',
   998	.         'usockaddr_len'
   999	.       ]
  1000	.     ],
  1001	.     'ret' => 'int'
  1002	.   },
  1003	.   'socketpair' => {
  1004	.     'code' => 53,
  1005	.     'name' => 'socketpair',
  1006	.     'impl' => 1,
  1007	.     'args' => [
  1008	.       [
  1009	.         'int',
  1010	.         'family'
  1011	.       ],
  1012	.       [
  1013	.         'int',
  1014	.         'type'
  1015	.       ],
  1016	.       [
  1017	.         'int',
  1018	.         'protocol'
  1019	.       ],
  1020	.       [
  1021	.         'int32_p',
  1022	.         'usockvec'
  1023	.       ]
  1024	.     ],
  1025	.     'ret' => 'int'
  1026	.   },
  1027	.   'setsockopt' => {
  1028	.     'code' => 54,
  1029	.     'name' => 'setsockopt',
  1030	.     'impl' => 1,
  1031	.     'args' => [
  1032	.       [
  1033	.         'fd_t',
  1034	.         'fd'
  1035	.       ],
  1036	.       [
  1037	.         'int',
  1038	.         'level'
  1039	.       ],
  1040	.       [
  1041	.         'int',
  1042	.         'optname'
  1043	.       ],
  1044	.       [
  1045	.         'ostr_t',
  1046	.         'optval'
  1047	.       ],
  1048	.       [
  1049	.         'int',
  1050	.         'optlen'
  1051	.       ]
  1052	.     ],
  1053	.     'ret' => 'int'
  1054	.   },
  1055	.   'getsockopt' => {
  1056	.     'code' => 55,
  1057	.     'name' => 'getsockopt',
  1058	.     'impl' => 1,
  1059	.     'args' => [
  1060	.       [
  1061	.         'fd_t',
  1062	.         'fd'
  1063	.       ],
  1064	.       [
  1065	.         'int',
  1066	.         'level'
  1067	.       ],
  1068	.       [
  1069	.         'int',
  1070	.         'optname'
  1071	.       ],
  1072	.       [
  1073	.         'ostr_t',
  1074	.         'optval'
  1075	.       ],
  1076	.       [
  1077	.         'int32_p',
  1078	.         'optlen'
  1079	.       ]
  1080	.     ],
  1081	.     'ret' => 'int'
  1082	.   },
  1083	.   'sys_clone' => {
  1084	.     'code' => 56,
  1085	.     'name' => 'clone',
  1086	.     'impl' => 1,
  1087	.     'args' => [
  1088	.       [
  1089	.         'uint64_t',
  1090	.         'clone_flags'
  1091	.       ],
  1092	.       [
  1093	.         'uint64_t',
  1094	.         'newsp'
  1095	.       ],
  1096	.       [
  1097	.         'void_p',
  1098	.         'parent_tid'
  1099	.       ],
  1100	.       [
  1101	.         'void_p',
  1102	.         'child_tid'
  1103	.       ]
  1104	.     ],
  1105	.     'ret' => 'int'
  1106	.   },
  1107	.   'fork' => {
  1108	.     'code' => 57,
  1109	.     'name' => 'fork',
  1110	.     'impl' => 1,
  1111	.     'args' => [],
  1112	.     'ret' => 'int'
  1113	.   },
  1114	.   'vfork' => {
  1115	.     'code' => 58,
  1116	.     'name' => 'vfork',
  1117	.     'impl' => 1,
  1118	.     'args' => [],
  1119	.     'ret' => 'int'
  1120	.   },
  1121	.   'execve' => {
  1122	.     'code' => 59,
  1123	.     'name' => 'execve',
  1124	.     'impl' => 1,
  1125	.     'args' => [
  1126	.       [
  1127	.         'const char *',
  1128	.         'filename'
  1129	.       ],
  1130	.       [
  1131	.         'char *const *',
  1132	.         'argv'
  1133	.       ],
  1134	.       [
  1135	.         'char *const *',
  1136	.         'envp'
  1137	.       ]
  1138	.     ],
  1139	.     'ret' => 'int'
  1140	.   },
  1141	.   '_exit' => {
  1142	.     'code' => 60,
  1143	.     'name' => 'exit',
  1144	.     'impl' => 1,
  1145	.     'args' => [
  1146	.       [
  1147	.         'int',
  1148	.         'error_code'
  1149	.       ]
  1150	.     ],
  1151	.     'ret' => 'void'
  1152	.   },
  1153	.   'wait4' => {
  1154	.     'code' => 61,
  1155	.     'name' => 'wait4',
  1156	.     'impl' => 1,
  1157	.     'args' => [
  1158	.       [
  1159	.         'pid_t',
  1160	.         'upid'
  1161	.       ],
  1162	.       [
  1163	.         'int32_p',
  1164	.         'stat_addr'
  1165	.       ],
  1166	.       [
  1167	.         'int',
  1168	.         'options'
  1169	.       ],
  1170	.       [
  1171	.         'rusage_p',
  1172	.         'ru'
  1173	.       ]
  1174	.     ],
  1175	.     'ret' => 'int'
  1176	.   },
  1177	.   'kill' => {
  1178	.     'code' => 62,
  1179	.     'name' => 'kill',
  1180	.     'impl' => 1,
  1181	.     'args' => [
  1182	.       [
  1183	.         'pid_t',
  1184	.         'pid'
  1185	.       ],
  1186	.       [
  1187	.         'int',
  1188	.         'sig'
  1189	.       ]
  1190	.     ],
  1191	.     'ret' => 'int'
  1192	.   },
  1193	.   'uname' => {
  1194	.     'code' => 63,
  1195	.     'name' => 'uname',
  1196	.     'impl' => 1,
  1197	.     'args' => [
  1198	.       [
  1199	.         'utsname_p',
  1200	.         'name'
  1201	.       ]
  1202	.     ],
  1203	.     'ret' => 'int'
  1204	.   },
  1205	.   'semget' => {
  1206	.     'code' => 64,
  1207	.     'name' => 'semget',
  1208	.     'impl' => 1,
  1209	.     'args' => [
  1210	.       [
  1211	.         'key_t',
  1212	.         'key'
  1213	.       ],
  1214	.       [
  1215	.         'int',
  1216	.         'nsems'
  1217	.       ],
  1218	.       [
  1219	.         'int',
  1220	.         'semflg'
  1221	.       ]
  1222	.     ],
  1223	.     'ret' => 'int'
  1224	.   },
  1225	.   'semop' => {
  1226	.     'code' => 65,
  1227	.     'name' => 'semop',
  1228	.     'impl' => 1,
  1229	.     'args' => [
  1230	.       [
  1231	.         'int',
  1232	.         'semid'
  1233	.       ],
  1234	.       [
  1235	.         'sembuf_p',
  1236	.         'tsops'
  1237	.       ],
  1238	.       [
  1239	.         'unsigned',
  1240	.         'nsops'
  1241	.       ]
  1242	.     ],
  1243	.     'ret' => 'int'
  1244	.   },
  1245	.   'semctl' => {
  1246	.     'code' => 66,
  1247	.     'name' => 'semctl',
  1248	.     'impl' => 1,
  1249	.     'args' => [
  1250	.       [
  1251	.         'int',
  1252	.         'semid'
  1253	.       ],
  1254	.       [
  1255	.         'int',
  1256	.         'semnum'
  1257	.       ],
  1258	.       [
  1259	.         'int',
  1260	.         'cmd'
  1261	.       ],
  1262	.       [
  1263	.         'union semun',
  1264	.         'arg'
  1265	.       ]
  1266	.     ],
  1267	.     'ret' => 'int'
  1268	.   },
  1269	.   'shmdt' => {
  1270	.     'code' => 67,
  1271	.     'name' => 'shmdt',
  1272	.     'impl' => 1,
  1273	.     'args' => [
  1274	.       [
  1275	.         'ostr_t',
  1276	.         'shmaddr'
  1277	.       ]
  1278	.     ],
  1279	.     'ret' => 'int'
  1280	.   },
  1281	.   'msgget' => {
  1282	.     'code' => 68,
  1283	.     'name' => 'msgget',
  1284	.     'impl' => 1,
  1285	.     'args' => [
  1286	.       [
  1287	.         'key_t',
  1288	.         'key'
  1289	.       ],
  1290	.       [
  1291	.         'int',
  1292	.         'msgflg'
  1293	.       ]
  1294	.     ],
  1295	.     'ret' => 'int'
  1296	.   },
  1297	.   'msgsnd' => {
  1298	.     'code' => 69,
  1299	.     'name' => 'msgsnd',
  1300	.     'impl' => 1,
  1301	.     'args' => [
  1302	.       [
  1303	.         'int',
  1304	.         'msqid'
  1305	.       ],
  1306	.       [
  1307	.         'msgbuf_p',
  1308	.         'msgp'
  1309	.       ],
  1310	.       [
  1311	.         'size_t',
  1312	.         'msgsz'
  1313	.       ],
  1314	.       [
  1315	.         'int',
  1316	.         'msgflg'
  1317	.       ]
  1318	.     ],
  1319	.     'ret' => 'int'
  1320	.   },
  1321	.   'msgrcv' => {
  1322	.     'code' => 70,
  1323	.     'name' => 'msgrcv',
  1324	.     'impl' => 1,
  1325	.     'args' => [
  1326	.       [
  1327	.         'int',
  1328	.         'msqid'
  1329	.       ],
  1330	.       [
  1331	.         'msgbuf_p',
  1332	.         'msgp'
  1333	.       ],
  1334	.       [
  1335	.         'size_t',
  1336	.         'msgsz'
  1337	.       ],
  1338	.       [
  1339	.         'long',
  1340	.         'msgtyp'
  1341	.       ],
  1342	.       [
  1343	.         'int',
  1344	.         'msgflg'
  1345	.       ]
  1346	.     ],
  1347	.     'ret' => 'int'
  1348	.   },
  1349	.   'msgctl' => {
  1350	.     'code' => 71,
  1351	.     'name' => 'msgctl',
  1352	.     'impl' => 1,
  1353	.     'args' => [
  1354	.       [
  1355	.         'int',
  1356	.         'msqid'
  1357	.       ],
  1358	.       [
  1359	.         'int',
  1360	.         'cmd'
  1361	.       ],
  1362	.       [
  1363	.         'msqid_ds_p',
  1364	.         'buf'
  1365	.       ]
  1366	.     ],
  1367	.     'ret' => 'int'
  1368	.   },
  1369	.   'fcntl' => {
  1370	.     'code' => 72,
  1371	.     'name' => 'fcntl',
  1372	.     'impl' => 1,
  1373	.     'args' => [
  1374	.       [
  1375	.         'fd_t',
  1376	.         'fd'
  1377	.       ],
  1378	.       [
  1379	.         'unsigned',
  1380	.         'cmd'
  1381	.       ],
  1382	.       [
  1383	.         'uint64_t',
  1384	.         'arg'
  1385	.       ]
  1386	.     ],
  1387	.     'ret' => 'int'
  1388	.   },
  1389	.   'flock' => {
  1390	.     'code' => 73,
  1391	.     'name' => 'flock',
  1392	.     'impl' => 1,
  1393	.     'args' => [
  1394	.       [
  1395	.         'fd_t',
  1396	.         'fd'
  1397	.       ],
  1398	.       [
  1399	.         'unsigned',
  1400	.         'cmd'
  1401	.       ]
  1402	.     ],
  1403	.     'ret' => 'int'
  1404	.   },
  1405	.   'fsync' => {
  1406	.     'code' => 74,
  1407	.     'name' => 'fsync',
  1408	.     'impl' => 1,
  1409	.     'args' => [
  1410	.       [
  1411	.         'fd_t',
  1412	.         'fd'
  1413	.       ]
  1414	.     ],
  1415	.     'ret' => 'int'
  1416	.   },
  1417	.   'fdatasync' => {
  1418	.     'code' => 75,
  1419	.     'name' => 'fdatasync',
  1420	.     'impl' => 1,
  1421	.     'args' => [
  1422	.       [
  1423	.         'fd_t',
  1424	.         'fd'
  1425	.       ]
  1426	.     ],
  1427	.     'ret' => 'int'
  1428	.   },
  1429	.   'truncate' => {
  1430	.     'code' => 76,
  1431	.     'name' => 'truncate',
  1432	.     'impl' => 1,
  1433	.     'args' => [
  1434	.       [
  1435	.         'istr_t',
  1436	.         'path'
  1437	.       ],
  1438	.       [
  1439	.         'long',
  1440	.         'length'
  1441	.       ]
  1442	.     ],
  1443	.     'ret' => 'int'
  1444	.   },
  1445	.   'ftruncate' => {
  1446	.     'code' => 77,
  1447	.     'name' => 'ftruncate',
  1448	.     'impl' => 1,
  1449	.     'args' => [
  1450	.       [
  1451	.         'fd_t',
  1452	.         'fd'
  1453	.       ],
  1454	.       [
  1455	.         'uint64_t',
  1456	.         'length'
  1457	.       ]
  1458	.     ],
  1459	.     'ret' => 'int'
  1460	.   },
  1461	.   'getdents' => {
  1462	.     'code' => 78,
  1463	.     'name' => 'getdents',
  1464	.     'impl' => 1,
  1465	.     'args' => [
  1466	.       [
  1467	.         'fd_t',
  1468	.         'fd'
  1469	.       ],
  1470	.       [
  1471	.         'linux_dirent_p',
  1472	.         'dirent'
  1473	.       ],
  1474	.       [
  1475	.         'size_t',
  1476	.         'count'
  1477	.       ]
  1478	.     ],
  1479	.     'ret' => 'ssize_t'
  1480	.   },
  1481	.   'getcwd' => {
  1482	.     'code' => 79,
  1483	.     'name' => 'getcwd',
  1484	.     'impl' => 1,
  1485	.     'args' => [
  1486	.       [
  1487	.         'ostr_t',
  1488	.         'buf'
  1489	.       ],
  1490	.       [
  1491	.         'uint64_t',
  1492	.         'size'
  1493	.       ]
  1494	.     ],
  1495	.     'ret' => 'int'
  1496	.   },
  1497	.   'chdir' => {
  1498	.     'code' => 80,
  1499	.     'name' => 'chdir',
  1500	.     'impl' => 1,
  1501	.     'args' => [
  1502	.       [
  1503	.         'istr_t',
  1504	.         'path'
  1505	.       ]
  1506	.     ],
  1507	.     'ret' => 'int'
  1508	.   },
  1509	.   'fchdir' => {
  1510	.     'code' => 81,
  1511	.     'name' => 'fchdir',
  1512	.     'impl' => 1,
  1513	.     'args' => [
  1514	.       [
  1515	.         'fd_t',
  1516	.         'fd'
  1517	.       ]
  1518	.     ],
  1519	.     'ret' => 'int'
  1520	.   },
  1521	.   'rename' => {
  1522	.     'code' => 82,
  1523	.     'name' => 'rename',
  1524	.     'impl' => 1,
  1525	.     'args' => [
  1526	.       [
  1527	.         'istr_t',
  1528	.         'opath'
  1529	.       ],
  1530	.       [
  1531	.         'istr_t',
  1532	.         'npath'
  1533	.       ]
  1534	.     ],
  1535	.     'ret' => 'int'
  1536	.   },
  1537	.   'mkdir' => {
  1538	.     'code' => 83,
  1539	.     'name' => 'mkdir',
  1540	.     'impl' => 1,
  1541	.     'args' => [
  1542	.       [
  1543	.         'istr_t',
  1544	.         'path'
  1545	.       ],
  1546	.       [
  1547	.         'int',
  1548	.         'mode'
  1549	.       ]
  1550	.     ],
  1551	.     'ret' => 'int'
  1552	.   },
  1553	.   'rmdir' => {
  1554	.     'code' => 84,
  1555	.     'name' => 'rmdir',
  1556	.     'impl' => 1,
  1557	.     'args' => [
  1558	.       [
  1559	.         'istr_t',
  1560	.         'path'
  1561	.       ]
  1562	.     ],
  1563	.     'ret' => 'int'
  1564	.   },
  1565	.   'creat' => {
  1566	.     'code' => 85,
  1567	.     'name' => 'creat',
  1568	.     'impl' => 1,
  1569	.     'args' => [
  1570	.       [
  1571	.         'istr_t',
  1572	.         'path'
  1573	.       ],
  1574	.       [
  1575	.         'int',
  1576	.         'mode'
  1577	.       ]
  1578	.     ],
  1579	.     'ret' => 'int'
  1580	.   },
  1581	.   'link' => {
  1582	.     'code' => 86,
  1583	.     'name' => 'link',
  1584	.     'impl' => 1,
  1585	.     'args' => [
  1586	.       [
  1587	.         'istr_t',
  1588	.         'opath'
  1589	.       ],
  1590	.       [
  1591	.         'istr_t',
  1592	.         'npath'
  1593	.       ]
  1594	.     ],
  1595	.     'ret' => 'int'
  1596	.   },
  1597	.   'unlink' => {
  1598	.     'code' => 87,
  1599	.     'name' => 'unlink',
  1600	.     'impl' => 1,
  1601	.     'args' => [
  1602	.       [
  1603	.         'istr_t',
  1604	.         'path'
  1605	.       ]
  1606	.     ],
  1607	.     'ret' => 'int'
  1608	.   },
  1609	.   'symlink' => {
  1610	.     'code' => 88,
  1611	.     'name' => 'symlink',
  1612	.     'impl' => 1,
  1613	.     'args' => [
  1614	.       [
  1615	.         'istr_t',
  1616	.         'opath'
  1617	.       ],
  1618	.       [
  1619	.         'istr_t',
  1620	.         'npath'
  1621	.       ]
  1622	.     ],
  1623	.     'ret' => 'int'
  1624	.   },
  1625	.   'readlink' => {
  1626	.     'code' => 89,
  1627	.     'name' => 'readlink',
  1628	.     'impl' => 1,
  1629	.     'args' => [
  1630	.       [
  1631	.         'istr_t',
  1632	.         'path'
  1633	.       ],
  1634	.       [
  1635	.         'ostr_t',
  1636	.         'buf'
  1637	.       ],
  1638	.       [
  1639	.         'int',
  1640	.         'bufsiz'
  1641	.       ]
  1642	.     ],
  1643	.     'ret' => 'int'
  1644	.   },
  1645	.   'chmod' => {
  1646	.     'code' => 90,
  1647	.     'name' => 'chmod',
  1648	.     'impl' => 1,
  1649	.     'args' => [
  1650	.       [
  1651	.         'istr_t',
  1652	.         'path'
  1653	.       ],
  1654	.       [
  1655	.         'mode_t',
  1656	.         'mode'
  1657	.       ]
  1658	.     ],
  1659	.     'ret' => 'int'
  1660	.   },
  1661	.   'fchmod' => {
  1662	.     'code' => 91,
  1663	.     'name' => 'fchmod',
  1664	.     'impl' => 1,
  1665	.     'args' => [
  1666	.       [
  1667	.         'fd_t',
  1668	.         'fd'
  1669	.       ],
  1670	.       [
  1671	.         'mode_t',
  1672	.         'mode'
  1673	.       ]
  1674	.     ],
  1675	.     'ret' => 'int'
  1676	.   },
  1677	.   'chown' => {
  1678	.     'code' => 92,
  1679	.     'name' => 'chown',
  1680	.     'impl' => 1,
  1681	.     'args' => [
  1682	.       [
  1683	.         'istr_t',
  1684	.         'path'
  1685	.       ],
  1686	.       [
  1687	.         'uid_t',
  1688	.         'user'
  1689	.       ],
  1690	.       [
  1691	.         'gid_t',
  1692	.         'group'
  1693	.       ]
  1694	.     ],
  1695	.     'ret' => 'int'
  1696	.   },
  1697	.   'fchown' => {
  1698	.     'code' => 93,
  1699	.     'name' => 'fchown',
  1700	.     'impl' => 1,
  1701	.     'args' => [
  1702	.       [
  1703	.         'fd_t',
  1704	.         'fd'
  1705	.       ],
  1706	.       [
  1707	.         'uid_t',
  1708	.         'user'
  1709	.       ],
  1710	.       [
  1711	.         'gid_t',
  1712	.         'group'
  1713	.       ]
  1714	.     ],
  1715	.     'ret' => 'int'
  1716	.   },
  1717	.   'lchown' => {
  1718	.     'code' => 94,
  1719	.     'name' => 'lchown',
  1720	.     'impl' => 1,
  1721	.     'args' => [
  1722	.       [
  1723	.         'istr_t',
  1724	.         'path'
  1725	.       ],
  1726	.       [
  1727	.         'uid_t',
  1728	.         'user'
  1729	.       ],
  1730	.       [
  1731	.         'gid_t',
  1732	.         'group'
  1733	.       ]
  1734	.     ],
  1735	.     'ret' => 'int'
  1736	.   },
  1737	.   'umask' => {
  1738	.     'code' => 95,
  1739	.     'name' => 'umask',
  1740	.     'impl' => 1,
  1741	.     'args' => [
  1742	.       [
  1743	.         'int',
  1744	.         'mask'
  1745	.       ]
  1746	.     ],
  1747	.     'ret' => 'int'
  1748	.   },
  1749	.   'gettimeofday' => {
  1750	.     'code' => 96,
  1751	.     'name' => 'gettimeofday',
  1752	.     'impl' => 1,
  1753	.     'args' => [
  1754	.       [
  1755	.         'timeval_p',
  1756	.         'tv'
  1757	.       ],
  1758	.       [
  1759	.         'timezone_p',
  1760	.         'tz'
  1761	.       ]
  1762	.     ],
  1763	.     'ret' => 'int'
  1764	.   },
  1765	.   'getrlimit' => {
  1766	.     'code' => 97,
  1767	.     'name' => 'getrlimit',
  1768	.     'impl' => 1,
  1769	.     'args' => [
  1770	.       [
  1771	.         'unsigned',
  1772	.         'resource'
  1773	.       ],
  1774	.       [
  1775	.         'rlimit_p',
  1776	.         'rlim'
  1777	.       ]
  1778	.     ],
  1779	.     'ret' => 'int'
  1780	.   },
  1781	.   'getrusage' => {
  1782	.     'code' => 98,
  1783	.     'name' => 'getrusage',
  1784	.     'impl' => 1,
  1785	.     'args' => [
  1786	.       [
  1787	.         'int',
  1788	.         'who'
  1789	.       ],
  1790	.       [
  1791	.         'rusage_p',
  1792	.         'ru'
  1793	.       ]
  1794	.     ],
  1795	.     'ret' => 'int'
  1796	.   },
  1797	.   'sysinfo' => {
  1798	.     'code' => 99,
  1799	.     'name' => 'sysinfo',
  1800	.     'impl' => 1,
  1801	.     'args' => [
  1802	.       [
  1803	.         'sysinfo_p',
  1804	.         'info'
  1805	.       ]
  1806	.     ],
  1807	.     'ret' => 'int'
  1808	.   },
  1809	.   'times' => {
  1810	.     'code' => 100,
  1811	.     'name' => 'times',
  1812	.     'impl' => 1,
  1813	.     'args' => [
  1814	.       [
  1815	.         'sysinfo_p',
  1816	.         'info'
  1817	.       ]
  1818	.     ],
  1819	.     'ret' => 'int'
  1820	.   },
  1821	.   'ptrace' => {
  1822	.     'code' => 101,
  1823	.     'name' => 'ptrace',
  1824	.     'impl' => 1,
  1825	.     'args' => [
  1826	.       [
  1827	.         'long',
  1828	.         'request'
  1829	.       ],
  1830	.       [
  1831	.         'long',
  1832	.         'pid'
  1833	.       ],
  1834	.       [
  1835	.         'uint64_t',
  1836	.         'addr'
  1837	.       ],
  1838	.       [
  1839	.         'uint64_t',
  1840	.         'data'
  1841	.       ]
  1842	.     ],
  1843	.     'ret' => 'int'
  1844	.   },
  1845	.   'getuid' => {
  1846	.     'code' => 102,
  1847	.     'name' => 'getuid',
  1848	.     'impl' => 1,
  1849	.     'args' => [],
  1850	.     'ret' => 'int'
  1851	.   },
  1852	.   'syslog' => {
  1853	.     'code' => 103,
  1854	.     'name' => 'syslog',
  1855	.     'impl' => 1,
  1856	.     'args' => [
  1857	.       [
  1858	.         'int',
  1859	.         'type'
  1860	.       ],
  1861	.       [
  1862	.         'ostr_t',
  1863	.         'buf'
  1864	.       ],
  1865	.       [
  1866	.         'int',
  1867	.         'len'
  1868	.       ]
  1869	.     ],
  1870	.     'ret' => 'int'
  1871	.   },
  1872	.   'getgid' => {
  1873	.     'code' => 104,
  1874	.     'name' => 'getgid',
  1875	.     'impl' => 1,
  1876	.     'args' => [],
  1877	.     'ret' => 'int'
  1878	.   },
  1879	.   'setuid' => {
  1880	.     'code' => 105,
  1881	.     'name' => 'setuid',
  1882	.     'impl' => 1,
  1883	.     'args' => [
  1884	.       [
  1885	.         'uid_t',
  1886	.         'uid'
  1887	.       ]
  1888	.     ],
  1889	.     'ret' => 'int'
  1890	.   },
  1891	.   'setgid' => {
  1892	.     'code' => 106,
  1893	.     'name' => 'setgid',
  1894	.     'impl' => 1,
  1895	.     'args' => [
  1896	.       [
  1897	.         'gid_t',
  1898	.         'gid'
  1899	.       ]
  1900	.     ],
  1901	.     'ret' => 'int'
  1902	.   },
  1903	.   'geteuid' => {
  1904	.     'code' => 107,
  1905	.     'name' => 'geteuid',
  1906	.     'impl' => 1,
  1907	.     'args' => [],
  1908	.     'ret' => 'int'
  1909	.   },
  1910	.   'getegid' => {
  1911	.     'code' => 108,
  1912	.     'name' => 'getegid',
  1913	.     'impl' => 1,
  1914	.     'args' => [],
  1915	.     'ret' => 'int'
  1916	.   },
  1917	.   'setpgid' => {
  1918	.     'code' => 109,
  1919	.     'name' => 'setpgid',
  1920	.     'impl' => 1,
  1921	.     'args' => [
  1922	.       [
  1923	.         'pid_t',
  1924	.         'pid'
  1925	.       ],
  1926	.       [
  1927	.         'pid_t',
  1928	.         'pgid'
  1929	.       ]
  1930	.     ],
  1931	.     'ret' => 'int'
  1932	.   },
  1933	.   'getppid' => {
  1934	.     'code' => 110,
  1935	.     'name' => 'getppid',
  1936	.     'impl' => 1,
  1937	.     'args' => [],
  1938	.     'ret' => 'int'
  1939	.   },
  1940	.   'getpgrp' => {
  1941	.     'code' => 111,
  1942	.     'name' => 'getpgrp',
  1943	.     'impl' => 1,
  1944	.     'args' => [],
  1945	.     'ret' => 'int'
  1946	.   },
  1947	.   'setsid' => {
  1948	.     'code' => 112,
  1949	.     'name' => 'setsid',
  1950	.     'impl' => 1,
  1951	.     'args' => [],
  1952	.     'ret' => 'int'
  1953	.   },
  1954	.   'setreuid' => {
  1955	.     'code' => 113,
  1956	.     'name' => 'setreuid',
  1957	.     'impl' => 1,
  1958	.     'args' => [
  1959	.       [
  1960	.         'uid_t',
  1961	.         'ruid'
  1962	.       ],
  1963	.       [
  1964	.         'uid_t',
  1965	.         'euid'
  1966	.       ]
  1967	.     ],
  1968	.     'ret' => 'int'
  1969	.   },
  1970	.   'setregid' => {
  1971	.     'code' => 114,
  1972	.     'name' => 'setregid',
  1973	.     'impl' => 1,
  1974	.     'args' => [
  1975	.       [
  1976	.         'gid_t',
  1977	.         'rgid'
  1978	.       ],
  1979	.       [
  1980	.         'gid_t',
  1981	.         'egid'
  1982	.       ]
  1983	.     ],
  1984	.     'ret' => 'int'
  1985	.   },
  1986	.   'getgroups' => {
  1987	.     'code' => 115,
  1988	.     'name' => 'getgroups',
  1989	.     'impl' => 1,
  1990	.     'args' => [
  1991	.       [
  1992	.         'int',
  1993	.         'gidsetsize'
  1994	.       ],
  1995	.       [
  1996	.         'gid_p',
  1997	.         'grouplist'
  1998	.       ]
  1999	.     ],
  2000	.     'ret' => 'int'
  2001	.   },
  2002	.   'setgroups' => {
  2003	.     'code' => 116,
  2004	.     'name' => 'setgroups',
  2005	.     'impl' => 1,
  2006	.     'args' => [
  2007	.       [
  2008	.         'int',
  2009	.         'gidsetsize'
  2010	.       ],
  2011	.       [
  2012	.         'gid_p',
  2013	.         'grouplist'
  2014	.       ]
  2015	.     ],
  2016	.     'ret' => 'int'
  2017	.   },
  2018	.   'setresuid' => {
  2019	.     'code' => 117,
  2020	.     'name' => 'setresuid',
  2021	.     'impl' => 1,
  2022	.     'args' => [
  2023	.       [
  2024	.         'uid_p',
  2025	.         'ruid'
  2026	.       ],
  2027	.       [
  2028	.         'uid_p',
  2029	.         'euid'
  2030	.       ],
  2031	.       [
  2032	.         'uid_p',
  2033	.         'suid'
  2034	.       ]
  2035	.     ],
  2036	.     'ret' => 'int'
  2037	.   },
  2038	.   'getresuid' => {
  2039	.     'code' => 118,
  2040	.     'name' => 'getresuid',
  2041	.     'impl' => 1,
  2042	.     'args' => [
  2043	.       [
  2044	.         'uid_p',
  2045	.         'ruid'
  2046	.       ],
  2047	.       [
  2048	.         'uid_p',
  2049	.         'euid'
  2050	.       ],
  2051	.       [
  2052	.         'uid_p',
  2053	.         'suid'
  2054	.       ]
  2055	.     ],
  2056	.     'ret' => 'int'
  2057	.   },
  2058	.   'setresgid' => {
  2059	.     'code' => 119,
  2060	.     'name' => 'setresgid',
  2061	.     'impl' => 1,
  2062	.     'args' => [
  2063	.       [
  2064	.         'gid_t',
  2065	.         'rgid'
  2066	.       ],
  2067	.       [
  2068	.         'gid_t',
  2069	.         'egid'
  2070	.       ],
  2071	.       [
  2072	.         'gid_t',
  2073	.         'sgid'
  2074	.       ]
  2075	.     ],
  2076	.     'ret' => 'int'
  2077	.   },
  2078	.   'getresgid' => {
  2079	.     'code' => 120,
  2080	.     'name' => 'getresgid',
  2081	.     'impl' => 1,
  2082	.     'args' => [
  2083	.       [
  2084	.         'gid_p',
  2085	.         'rgid'
  2086	.       ],
  2087	.       [
  2088	.         'gid_p',
  2089	.         'egid'
  2090	.       ],
  2091	.       [
  2092	.         'gid_p',
  2093	.         'sgid'
  2094	.       ]
  2095	.     ],
  2096	.     'ret' => 'int'
  2097	.   },
  2098	.   'getpgid' => {
  2099	.     'code' => 121,
  2100	.     'name' => 'getpgid',
  2101	.     'impl' => 1,
  2102	.     'args' => [
  2103	.       [
  2104	.         'pid_t',
  2105	.         'pid'
  2106	.       ]
  2107	.     ],
  2108	.     'ret' => 'int'
  2109	.   },
  2110	.   'setfsuid' => {
  2111	.     'code' => 122,
  2112	.     'name' => 'setfsuid',
  2113	.     'impl' => 1,
  2114	.     'args' => [
  2115	.       [
  2116	.         'uid_t',
  2117	.         'uid'
  2118	.       ]
  2119	.     ],
  2120	.     'ret' => 'int'
  2121	.   },
  2122	.   'setfsgid' => {
  2123	.     'code' => 123,
  2124	.     'name' => 'setfsgid',
  2125	.     'impl' => 1,
  2126	.     'args' => [
  2127	.       [
  2128	.         'gid_t',
  2129	.         'gid'
  2130	.       ]
  2131	.     ],
  2132	.     'ret' => 'int'
  2133	.   },
  2134	.   'getsid' => {
  2135	.     'code' => 124,
  2136	.     'name' => 'getsid',
  2137	.     'impl' => 1,
  2138	.     'args' => [
  2139	.       [
  2140	.         'pid_t',
  2141	.         'pid'
  2142	.       ]
  2143	.     ],
  2144	.     'ret' => 'int'
  2145	.   },
  2146	.   'capget' => {
  2147	.     'code' => 125,
  2148	.     'name' => 'capget',
  2149	.     'impl' => 1,
  2150	.     'args' => [
  2151	.       [
  2152	.         'cap_user_header_t',
  2153	.         'header'
  2154	.       ],
  2155	.       [
  2156	.         'cap_user_data_t',
  2157	.         'dataptr'
  2158	.       ]
  2159	.     ],
  2160	.     'ret' => 'int'
  2161	.   },
  2162	.   'capset' => {
  2163	.     'code' => 126,
  2164	.     'name' => 'capset',
  2165	.     'impl' => 1,
  2166	.     'args' => [
  2167	.       [
  2168	.         'cap_user_header_t',
  2169	.         'header'
  2170	.       ],
  2171	.       [
  2172	.         'const cap_user_data_t',
  2173	.         'data'
  2174	.       ]
  2175	.     ],
  2176	.     'ret' => 'int'
  2177	.   },
  2178	.   'rt_sigpending' => {
  2179	.     'code' => 127,
  2180	.     'name' => 'rt_sigpending',
  2181	.     'impl' => 1,
  2182	.     'args' => [
  2183	.       [
  2184	.         'sigset_p',
  2185	.         'set'
  2186	.       ],
  2187	.       [
  2188	.         'size_t',
  2189	.         'sigsetsize'
  2190	.       ]
  2191	.     ],
  2192	.     'ret' => 'int'
  2193	.   },
  2194	.   'rt_sigtimedwait' => {
  2195	.     'code' => 128,
  2196	.     'name' => 'rt_sigtimedwait',
  2197	.     'impl' => 1,
  2198	.     'args' => [
  2199	.       [
  2200	.         'const sigset_p',
  2201	.         'uthese'
  2202	.       ],
  2203	.       [
  2204	.         'siginfo_p',
  2205	.         'uinfo'
  2206	.       ],
  2207	.       [
  2208	.         'timespec_p',
  2209	.         'uts'
  2210	.       ],
  2211	.       [
  2212	.         'size_t',
  2213	.         'sigsetsize'
  2214	.       ]
  2215	.     ],
  2216	.     'ret' => 'int'
  2217	.   },
  2218	.   'rt_sigqueueinfo' => {
  2219	.     'code' => 129,
  2220	.     'name' => 'rt_sigqueueinfo',
  2221	.     'impl' => 1,
  2222	.     'args' => [
  2223	.       [
  2224	.         'pid_t',
  2225	.         'pid'
  2226	.       ],
  2227	.       [
  2228	.         'int',
  2229	.         'sig'
  2230	.       ],
  2231	.       [
  2232	.         'siginfo_p',
  2233	.         'uinfo'
  2234	.       ]
  2235	.     ],
  2236	.     'ret' => 'int'
  2237	.   },
  2238	.   'rt_sigsuspend' => {
  2239	.     'code' => 130,
  2240	.     'name' => 'rt_sigsuspend',
  2241	.     'impl' => 1,
  2242	.     'args' => [
  2243	.       [
  2244	.         'sigset_p',
  2245	.         'unewset'
  2246	.       ],
  2247	.       [
  2248	.         'size_t',
  2249	.         'sigsetsize'
  2250	.       ]
  2251	.     ],
  2252	.     'ret' => 'int'
  2253	.   },
  2254	.   'sigaltstack' => {
  2255	.     'code' => 131,
  2256	.     'name' => 'sigaltstack',
  2257	.     'impl' => 1,
  2258	.     'args' => [
  2259	.       [
  2260	.         'const stack_p',
  2261	.         'uss'
  2262	.       ],
  2263	.       [
  2264	.         'stack_p',
  2265	.         'uoss'
  2266	.       ]
  2267	.     ],
  2268	.     'ret' => 'int'
  2269	.   },
  2270	.   'utime' => {
  2271	.     'code' => 132,
  2272	.     'name' => 'utime',
  2273	.     'impl' => 1,
  2274	.     'args' => [
  2275	.       [
  2276	.         'ostr_t',
  2277	.         'path'
  2278	.       ],
  2279	.       [
  2280	.         'utimbuf_p',
  2281	.         'times'
  2282	.       ]
  2283	.     ],
  2284	.     'ret' => 'int'
  2285	.   },
  2286	.   'mknod' => {
  2287	.     'code' => 133,
  2288	.     'name' => 'mknod',
  2289	.     'impl' => 1,
  2290	.     'args' => [
  2291	.       [
  2292	.         'istr_t',
  2293	.         'path'
  2294	.       ],
  2295	.       [
  2296	.         'umode_t',
  2297	.         'mode'
  2298	.       ],
  2299	.       [
  2300	.         'unsigned',
  2301	.         'dev'
  2302	.       ]
  2303	.     ],
  2304	.     'ret' => 'int'
  2305	.   },
  2306	.   'uselib' => {
  2307	.     'code' => 134,
  2308	.     'name' => 'uselib',
  2309	.     'impl' => 0
  2310	.   },
  2311	.   'personality' => {
  2312	.     'code' => 135,
  2313	.     'name' => 'personality',
  2314	.     'impl' => 1,
  2315	.     'args' => [
  2316	.       [
  2317	.         'unsigned',
  2318	.         'personality'
  2319	.       ]
  2320	.     ],
  2321	.     'ret' => 'int'
  2322	.   },
  2323	.   'ustat' => {
  2324	.     'code' => 136,
  2325	.     'name' => 'ustat',
  2326	.     'impl' => 1,
  2327	.     'args' => [
  2328	.       [
  2329	.         'unsigned',
  2330	.         'dev'
  2331	.       ],
  2332	.       [
  2333	.         'ustat_p',
  2334	.         'ubuf'
  2335	.       ]
  2336	.     ],
  2337	.     'ret' => 'int'
  2338	.   },
  2339	.   'statfs' => {
  2340	.     'code' => 137,
  2341	.     'name' => 'statfs',
  2342	.     'impl' => 1,
  2343	.     'args' => [
  2344	.       [
  2345	.         'istr_t',
  2346	.         'path'
  2347	.       ],
  2348	.       [
  2349	.         'statfs_p',
  2350	.         'buf'
  2351	.       ]
  2352	.     ],
  2353	.     'ret' => 'int'
  2354	.   },
  2355	.   'fstatfs' => {
  2356	.     'code' => 138,
  2357	.     'name' => 'fstatfs',
  2358	.     'impl' => 1,
  2359	.     'args' => [
  2360	.       [
  2361	.         'fd_t',
  2362	.         'fd'
  2363	.       ],
  2364	.       [
  2365	.         'statfs_p',
  2366	.         'buf'
  2367	.       ]
  2368	.     ],
  2369	.     'ret' => 'int'
  2370	.   },
  2371	.   'sysfs' => {
  2372	.     'code' => 139,
  2373	.     'name' => 'sysfs',
  2374	.     'impl' => 1,
  2375	.     'args' => [
  2376	.       [
  2377	.         'int',
  2378	.         'option'
  2379	.       ],
  2380	.       [
  2381	.         'uint64_t',
  2382	.         'arg1'
  2383	.       ],
  2384	.       [
  2385	.         'uint64_t',
  2386	.         'arg2'
  2387	.       ]
  2388	.     ],
  2389	.     'ret' => 'int'
  2390	.   },
  2391	.   'getpriority' => {
  2392	.     'code' => 140,
  2393	.     'name' => 'getpriority',
  2394	.     'impl' => 1,
  2395	.     'args' => [
  2396	.       [
  2397	.         'int',
  2398	.         'which'
  2399	.       ],
  2400	.       [
  2401	.         'int',
  2402	.         'who'
  2403	.       ]
  2404	.     ],
  2405	.     'ret' => 'int'
  2406	.   },
  2407	.   'setpriority' => {
  2408	.     'code' => 141,
  2409	.     'name' => 'setpriority',
  2410	.     'impl' => 1,
  2411	.     'args' => [
  2412	.       [
  2413	.         'int',
  2414	.         'which'
  2415	.       ],
  2416	.       [
  2417	.         'int',
  2418	.         'who'
  2419	.       ],
  2420	.       [
  2421	.         'int',
  2422	.         'niceval'
  2423	.       ]
  2424	.     ],
  2425	.     'ret' => 'int'
  2426	.   },
  2427	.   'sys_sched_setparam' => {
  2428	.     'code' => 142,
  2429	.     'name' => 'sched_setparam',
  2430	.     'impl' => 1,
  2431	.     'args' => [
  2432	.       [
  2433	.         'pid_t',
  2434	.         'pid'
  2435	.       ],
  2436	.       [
  2437	.         'const void *',
  2438	.         'param'
  2439	.       ]
  2440	.     ],
  2441	.     'ret' => 'int'
  2442	.   },
  2443	.   'sched_getparam' => {
  2444	.     'code' => 143,
  2445	.     'name' => 'sched_getparam',
  2446	.     'impl' => 1,
  2447	.     'args' => [
  2448	.       [
  2449	.         'pid_t',
  2450	.         'pid'
  2451	.       ],
  2452	.       [
  2453	.         'sched_param_p',
  2454	.         'param'
  2455	.       ]
  2456	.     ],
  2457	.     'ret' => 'int'
  2458	.   },
  2459	.   'sys_sched_setscheduler' => {
  2460	.     'code' => 144,
  2461	.     'name' => 'sched_setscheduler',
  2462	.     'impl' => 1,
  2463	.     'args' => [
  2464	.       [
  2465	.         'pid_t',
  2466	.         'pid'
  2467	.       ],
  2468	.       [
  2469	.         'int',
  2470	.         'policy'
  2471	.       ],
  2472	.       [
  2473	.         'sched_param_p',
  2474	.         'param'
  2475	.       ]
  2476	.     ],
  2477	.     'ret' => 'int'
  2478	.   },
  2479	.   'sched_getscheduler' => {
  2480	.     'code' => 145,
  2481	.     'name' => 'sched_getscheduler',
  2482	.     'impl' => 1,
  2483	.     'args' => [
  2484	.       [
  2485	.         'pid_t',
  2486	.         'pid'
  2487	.       ]
  2488	.     ],
  2489	.     'ret' => 'int'
  2490	.   },
  2491	.   'sched_get_priority_max' => {
  2492	.     'code' => 146,
  2493	.     'name' => 'sched_get_priority_max',
  2494	.     'impl' => 1,
  2495	.     'args' => [
  2496	.       [
  2497	.         'int',
  2498	.         'policy'
  2499	.       ]
  2500	.     ],
  2501	.     'ret' => 'int'
  2502	.   },
  2503	.   'sched_get_priority_min' => {
  2504	.     'code' => 147,
  2505	.     'name' => 'sched_get_priority_min',
  2506	.     'impl' => 1,
  2507	.     'args' => [
  2508	.       [
  2509	.         'int',
  2510	.         'policy'
  2511	.       ]
  2512	.     ],
  2513	.     'ret' => 'int'
  2514	.   },
  2515	.   'sched_rr_get_interval' => {
  2516	.     'code' => 148,
  2517	.     'name' => 'sched_rr_get_interval',
  2518	.     'impl' => 1,
  2519	.     'args' => [
  2520	.       [
  2521	.         'pid_t',
  2522	.         'pid'
  2523	.       ],
  2524	.       [
  2525	.         'timespec_p',
  2526	.         'interval'
  2527	.       ]
  2528	.     ],
  2529	.     'ret' => 'int'
  2530	.   },
  2531	.   'mlock' => {
  2532	.     'code' => 149,
  2533	.     'name' => 'mlock',
  2534	.     'impl' => 1,
  2535	.     'args' => [
  2536	.       [
  2537	.         'void_p',
  2538	.         'start'
  2539	.       ],
  2540	.       [
  2541	.         'size_t',
  2542	.         'len'
  2543	.       ]
  2544	.     ],
  2545	.     'ret' => 'int'
  2546	.   },
  2547	.   'munlock' => {
  2548	.     'code' => 150,
  2549	.     'name' => 'munlock',
  2550	.     'impl' => 1,
  2551	.     'args' => [
  2552	.       [
  2553	.         'void_p',
  2554	.         'start'
  2555	.       ],
  2556	.       [
  2557	.         'size_t',
  2558	.         'len'
  2559	.       ]
  2560	.     ],
  2561	.     'ret' => 'int'
  2562	.   },
  2563	.   'mlockall' => {
  2564	.     'code' => 151,
  2565	.     'name' => 'mlockall',
  2566	.     'impl' => 1,
  2567	.     'args' => [
  2568	.       [
  2569	.         'int',
  2570	.         'flags'
  2571	.       ]
  2572	.     ],
  2573	.     'ret' => 'int'
  2574	.   },
  2575	.   'munlockall' => {
  2576	.     'code' => 152,
  2577	.     'name' => 'munlockall',
  2578	.     'impl' => 1,
  2579	.     'args' => [],
  2580	.     'ret' => 'int'
  2581	.   },
  2582	.   'vhangup' => {
  2583	.     'code' => 153,
  2584	.     'name' => 'vhangup',
  2585	.     'impl' => 1,
  2586	.     'args' => [],
  2587	.     'ret' => 'int'
  2588	.   },
  2589	.   'modify_ldt' => {
  2590	.     'code' => 154,
  2591	.     'name' => 'modify_ldt',
  2592	.     'impl' => 1,
  2593	.     'args' => [
  2594	.       [
  2595	.         'int',
  2596	.         'func'
  2597	.       ],
  2598	.       [
  2599	.         'void_p',
  2600	.         'ptr'
  2601	.       ],
  2602	.       [
  2603	.         'uint64_t',
  2604	.         'bytecount'
  2605	.       ]
  2606	.     ],
  2607	.     'ret' => 'int'
  2608	.   },
  2609	.   'pivot_root' => {
  2610	.     'code' => 155,
  2611	.     'name' => 'pivot_root',
  2612	.     'impl' => 1,
  2613	.     'args' => [
  2614	.       [
  2615	.         'istr_t',
  2616	.         'new_root'
  2617	.       ],
  2618	.       [
  2619	.         'istr_t',
  2620	.         'put_old'
  2621	.       ]
  2622	.     ],
  2623	.     'ret' => 'int'
  2624	.   },
  2625	.   '_sysctl' => {
  2626	.     'code' => 156,
  2627	.     'name' => '_sysctl',
  2628	.     'impl' => 1,
  2629	.     'args' => [
  2630	.       [
  2631	.         'sysctl_args_p',
  2632	.         'args'
  2633	.       ]
  2634	.     ],
  2635	.     'ret' => 'int'
  2636	.   },
  2637	.   'prctl' => {
  2638	.     'code' => 157,
  2639	.     'name' => 'prctl',
  2640	.     'impl' => 1,
  2641	.     'args' => [
  2642	.       [
  2643	.         'int',
  2644	.         'option'
  2645	.       ],
  2646	.       [
  2647	.         'uint64_t',
  2648	.         'arg2'
  2649	.       ],
  2650	.       [
  2651	.         'uint64_t',
  2652	.         'arg3'
  2653	.       ],
  2654	.       [
  2655	.         'uint64_t',
  2656	.         'arg4'
  2657	.       ],
  2658	.       [
  2659	.         'uint64_t',
  2660	.         'arg5'
  2661	.       ]
  2662	.     ],
  2663	.     'ret' => 'int'
  2664	.   },
  2665	.   'arch_prctl' => {
  2666	.     'code' => 158,
  2667	.     'name' => 'arch_prctl',
  2668	.     'impl' => 1,
  2669	.     'args' => [
  2670	.       [
  2671	.         'task_struct_p',
  2672	.         'task'
  2673	.       ],
  2674	.       [
  2675	.         'int',
  2676	.         'code'
  2677	.       ],
  2678	.       [
  2679	.         'uint64_t',
  2680	.         'addr'
  2681	.       ]
  2682	.     ],
  2683	.     'ret' => 'int'
  2684	.   },
  2685	.   'adjtimex' => {
  2686	.     'code' => 159,
  2687	.     'name' => 'adjtimex',
  2688	.     'impl' => 1,
  2689	.     'args' => [
  2690	.       [
  2691	.         'timex_p',
  2692	.         'txc_p'
  2693	.       ]
  2694	.     ],
  2695	.     'ret' => 'int'
  2696	.   },
  2697	.   'setrlimit' => {
  2698	.     'code' => 160,
  2699	.     'name' => 'setrlimit',
  2700	.     'impl' => 1,
  2701	.     'args' => [
  2702	.       [
  2703	.         'unsigned',
  2704	.         'resource'
  2705	.       ],
  2706	.       [
  2707	.         'rlimit_p',
  2708	.         'rlim'
  2709	.       ]
  2710	.     ],
  2711	.     'ret' => 'int'
  2712	.   },
  2713	.   'chroot' => {
  2714	.     'code' => 161,
  2715	.     'name' => 'chroot',
  2716	.     'impl' => 1,
  2717	.     'args' => [
  2718	.       [
  2719	.         'istr_t',
  2720	.         'path'
  2721	.       ]
  2722	.     ],
  2723	.     'ret' => 'int'
  2724	.   },
  2725	.   'sync' => {
  2726	.     'code' => 162,
  2727	.     'name' => 'sync',
  2728	.     'impl' => 1,
  2729	.     'args' => [],
  2730	.     'ret' => 'int'
  2731	.   },
  2732	.   'acct' => {
  2733	.     'code' => 163,
  2734	.     'name' => 'acct',
  2735	.     'impl' => 1,
  2736	.     'args' => [
  2737	.       [
  2738	.         'istr_t',
  2739	.         'name'
  2740	.       ]
  2741	.     ],
  2742	.     'ret' => 'int'
  2743	.   },
  2744	.   'settimeofday' => {
  2745	.     'code' => 164,
  2746	.     'name' => 'settimeofday',
  2747	.     'impl' => 1,
  2748	.     'args' => [
  2749	.       [
  2750	.         'timeval_p',
  2751	.         'tv'
  2752	.       ],
  2753	.       [
  2754	.         'timezone_p',
  2755	.         'tz'
  2756	.       ]
  2757	.     ],
  2758	.     'ret' => 'int'
  2759	.   },
  2760	.   'mount' => {
  2761	.     'code' => 165,
  2762	.     'name' => 'mount',
  2763	.     'impl' => 1,
  2764	.     'args' => [
  2765	.       [
  2766	.         'ostr_t',
  2767	.         'dev_name'
  2768	.       ],
  2769	.       [
  2770	.         'ostr_t',
  2771	.         'dir_name'
  2772	.       ],
  2773	.       [
  2774	.         'ostr_t',
  2775	.         'type'
  2776	.       ],
  2777	.       [
  2778	.         'uint64_t',
  2779	.         'flags'
  2780	.       ],
  2781	.       [
  2782	.         'void_p',
  2783	.         'data'
  2784	.       ]
  2785	.     ],
  2786	.     'ret' => 'int'
  2787	.   },
  2788	.   'umount2' => {
  2789	.     'code' => 166,
  2790	.     'name' => 'umount2',
  2791	.     'impl' => 1,
  2792	.     'args' => [
  2793	.       [
  2794	.         'istr_t',
  2795	.         'target'
  2796	.       ],
  2797	.       [
  2798	.         'int',
  2799	.         'flags'
  2800	.       ]
  2801	.     ],
  2802	.     'ret' => 'int'
  2803	.   },
  2804	.   'swapon' => {
  2805	.     'code' => 167,
  2806	.     'name' => 'swapon',
  2807	.     'impl' => 1,
  2808	.     'args' => [
  2809	.       [
  2810	.         'istr_t',
  2811	.         'specialfile'
  2812	.       ],
  2813	.       [
  2814	.         'int',
  2815	.         'swap_flags'
  2816	.       ]
  2817	.     ],
  2818	.     'ret' => 'int'
  2819	.   },
  2820	.   'swapoff' => {
  2821	.     'code' => 168,
  2822	.     'name' => 'swapoff',
  2823	.     'impl' => 1,
  2824	.     'args' => [
  2825	.       [
  2826	.         'istr_t',
  2827	.         'specialfile'
  2828	.       ]
  2829	.     ],
  2830	.     'ret' => 'int'
  2831	.   },
  2832	.   'reboot' => {
  2833	.     'code' => 169,
  2834	.     'name' => 'reboot',
  2835	.     'impl' => 1,
  2836	.     'args' => [
  2837	.       [
  2838	.         'int',
  2839	.         'magic1'
  2840	.       ],
  2841	.       [
  2842	.         'int',
  2843	.         'magic2'
  2844	.       ],
  2845	.       [
  2846	.         'unsigned',
  2847	.         'cmd'
  2848	.       ],
  2849	.       [
  2850	.         'void_p',
  2851	.         'arg'
  2852	.       ]
  2853	.     ],
  2854	.     'ret' => 'int'
  2855	.   },
  2856	.   'sethostname' => {
  2857	.     'code' => 170,
  2858	.     'name' => 'sethostname',
  2859	.     'impl' => 1,
  2860	.     'args' => [
  2861	.       [
  2862	.         'ostr_t',
  2863	.         'name'
  2864	.       ],
  2865	.       [
  2866	.         'int',
  2867	.         'len'
  2868	.       ]
  2869	.     ],
  2870	.     'ret' => 'int'
  2871	.   },
  2872	.   'setdomainname' => {
  2873	.     'code' => 171,
  2874	.     'name' => 'setdomainname',
  2875	.     'impl' => 1,
  2876	.     'args' => [
  2877	.       [
  2878	.         'ostr_t',
  2879	.         'name'
  2880	.       ],
  2881	.       [
  2882	.         'int',
  2883	.         'len'
  2884	.       ]
  2885	.     ],
  2886	.     'ret' => 'int'
  2887	.   },
  2888	.   'iopl' => {
  2889	.     'code' => 172,
  2890	.     'name' => 'iopl',
  2891	.     'impl' => 1,
  2892	.     'args' => [
  2893	.       [
  2894	.         'unsigned',
  2895	.         'level'
  2896	.       ],
  2897	.       [
  2898	.         'pt_regs_p',
  2899	.         'regs'
  2900	.       ]
  2901	.     ],
  2902	.     'ret' => 'int'
  2903	.   },
  2904	.   'ioperm' => {
  2905	.     'code' => 173,
  2906	.     'name' => 'ioperm',
  2907	.     'impl' => 1,
  2908	.     'args' => [
  2909	.       [
  2910	.         'uint64_t',
  2911	.         'from'
  2912	.       ],
  2913	.       [
  2914	.         'uint64_t',
  2915	.         'num'
  2916	.       ],
  2917	.       [
  2918	.         'int',
  2919	.         'turn_on'
  2920	.       ]
  2921	.     ],
  2922	.     'ret' => 'int'
  2923	.   },
  2924	.   'create_module' => {
  2925	.     'code' => 174,
  2926	.     'name' => 'create_module',
  2927	.     'impl' => 0,
  2928	.     'ret' => 'int'
  2929	.   },
  2930	.   'init_module' => {
  2931	.     'code' => 175,
  2932	.     'name' => 'init_module',
  2933	.     'impl' => 1,
  2934	.     'args' => [
  2935	.       [
  2936	.         'void_p',
  2937	.         'umod'
  2938	.       ],
  2939	.       [
  2940	.         'uint64_t',
  2941	.         'len'
  2942	.       ],
  2943	.       [
  2944	.         'istr_t',
  2945	.         'uargs'
  2946	.       ]
  2947	.     ],
  2948	.     'ret' => 'int'
  2949	.   },
  2950	.   'delete_module' => {
  2951	.     'code' => 176,
  2952	.     'name' => 'delete_module',
  2953	.     'impl' => 1,
  2954	.     'args' => [
  2955	.       [
  2956	.         'istr_t',
  2957	.         'name_user'
  2958	.       ],
  2959	.       [
  2960	.         'unsigned',
  2961	.         'flags'
  2962	.       ]
  2963	.     ],
  2964	.     'ret' => 'int'
  2965	.   },
  2966	.   'get_kernel_syms' => {
  2967	.     'code' => 177,
  2968	.     'name' => 'get_kernel_syms',
  2969	.     'impl' => 0
  2970	.   },
  2971	.   'query_module' => {
  2972	.     'code' => 178,
  2973	.     'name' => 'query_module',
  2974	.     'impl' => 0
  2975	.   },
  2976	.   'quotactl' => {
  2977	.     'code' => 179,
  2978	.     'name' => 'quotactl',
  2979	.     'impl' => 1,
  2980	.     'args' => [
  2981	.       [
  2982	.         'unsigned',
  2983	.         'cmd'
  2984	.       ],
  2985	.       [
  2986	.         'istr_t',
  2987	.         'special'
  2988	.       ],
  2989	.       [
  2990	.         'qid_t',
  2991	.         'id'
  2992	.       ],
  2993	.       [
  2994	.         'void_p',
  2995	.         'addr'
  2996	.       ]
  2997	.     ],
  2998	.     'ret' => 'int'
  2999	.   },
  3000	.   'nfsservctl' => {
  3001	.     'code' => 180,
  3002	.     'name' => 'nfsservctl',
  3003	.     'impl' => 0
  3004	.   },
  3005	.   'getpmsg' => {
  3006	.     'code' => 181,
  3007	.     'name' => 'getpmsg',
  3008	.     'impl' => 0
  3009	.   },
  3010	.   'putpmsg' => {
  3011	.     'code' => 182,
  3012	.     'name' => 'putpmsg',
  3013	.     'impl' => 0
  3014	.   },
  3015	.   'afs_syscall' => {
  3016	.     'code' => 183,
  3017	.     'name' => 'afs_syscall',
  3018	.     'impl' => 0
  3019	.   },
  3020	.   'tuxcall' => {
  3021	.     'code' => 184,
  3022	.     'name' => 'tuxcall',
  3023	.     'impl' => 0
  3024	.   },
  3025	.   'security' => {
  3026	.     'code' => 185,
  3027	.     'name' => 'security',
  3028	.     'impl' => 0
  3029	.   },
  3030	.   'gettid' => {
  3031	.     'code' => 186,
  3032	.     'name' => 'gettid',
  3033	.     'impl' => 1,
  3034	.     'args' => [],
  3035	.     'ret' => 'int'
  3036	.   },
  3037	.   'readahead' => {
  3038	.     'code' => 187,
  3039	.     'name' => 'readahead',
  3040	.     'impl' => 1,
  3041	.     'args' => [
  3042	.       [
  3043	.         'fd_t',
  3044	.         'fd'
  3045	.       ],
  3046	.       [
  3047	.         'off_t',
  3048	.         'offset'
  3049	.       ],
  3050	.       [
  3051	.         'size_t',
  3052	.         'count'
  3053	.       ]
  3054	.     ],
  3055	.     'ret' => 'int'
  3056	.   },
  3057	.   'setxattr' => {
  3058	.     'code' => 188,
  3059	.     'name' => 'setxattr',
  3060	.     'impl' => 1,
  3061	.     'args' => [
  3062	.       [
  3063	.         'istr_t',
  3064	.         'path'
  3065	.       ],
  3066	.       [
  3067	.         'istr_t',
  3068	.         'name'
  3069	.       ],
  3070	.       [
  3071	.         'const void_p',
  3072	.         'value'
  3073	.       ],
  3074	.       [
  3075	.         'size_t',
  3076	.         'size'
  3077	.       ],
  3078	.       [
  3079	.         'int',
  3080	.         'flags'
  3081	.       ]
  3082	.     ],
  3083	.     'ret' => 'int'
  3084	.   },
  3085	.   'lsetxattr' => {
  3086	.     'code' => 189,
  3087	.     'name' => 'lsetxattr',
  3088	.     'impl' => 1,
  3089	.     'args' => [
  3090	.       [
  3091	.         'istr_t',
  3092	.         'path'
  3093	.       ],
  3094	.       [
  3095	.         'istr_t',
  3096	.         'name'
  3097	.       ],
  3098	.       [
  3099	.         'const void_p',
  3100	.         'value'
  3101	.       ],
  3102	.       [
  3103	.         'size_t',
  3104	.         'size'
  3105	.       ],
  3106	.       [
  3107	.         'int',
  3108	.         'flags'
  3109	.       ]
  3110	.     ],
  3111	.     'ret' => 'int'
  3112	.   },
  3113	.   'fsetxattr' => {
  3114	.     'code' => 190,
  3115	.     'name' => 'fsetxattr',
  3116	.     'impl' => 1,
  3117	.     'args' => [
  3118	.       [
  3119	.         'fd_t',
  3120	.         'fd'
  3121	.       ],
  3122	.       [
  3123	.         'istr_t',
  3124	.         'name'
  3125	.       ],
  3126	.       [
  3127	.         'const void_p',
  3128	.         'value'
  3129	.       ],
  3130	.       [
  3131	.         'size_t',
  3132	.         'size'
  3133	.       ],
  3134	.       [
  3135	.         'int',
  3136	.         'flags'
  3137	.       ]
  3138	.     ],
  3139	.     'ret' => 'int'
  3140	.   },
  3141	.   'getxattr' => {
  3142	.     'code' => 191,
  3143	.     'name' => 'getxattr',
  3144	.     'impl' => 1,
  3145	.     'args' => [
  3146	.       [
  3147	.         'istr_t',
  3148	.         'path'
  3149	.       ],
  3150	.       [
  3151	.         'istr_t',
  3152	.         'name'
  3153	.       ],
  3154	.       [
  3155	.         'void_p',
  3156	.         'value'
  3157	.       ],
  3158	.       [
  3159	.         'size_t',
  3160	.         'size'
  3161	.       ]
  3162	.     ],
  3163	.     'ret' => 'int'
  3164	.   },
  3165	.   'lgetxattr' => {
  3166	.     'code' => 192,
  3167	.     'name' => 'lgetxattr',
  3168	.     'impl' => 1,
  3169	.     'args' => [
  3170	.       [
  3171	.         'istr_t',
  3172	.         'path'
  3173	.       ],
  3174	.       [
  3175	.         'istr_t',
  3176	.         'name'
  3177	.       ],
  3178	.       [
  3179	.         'void_p',
  3180	.         'value'
  3181	.       ],
  3182	.       [
  3183	.         'size_t',
  3184	.         'size'
  3185	.       ]
  3186	.     ],
  3187	.     'ret' => 'int'
  3188	.   },
  3189	.   'fgetxattr' => {
  3190	.     'code' => 193,
  3191	.     'name' => 'fgetxattr',
  3192	.     'impl' => 1,
  3193	.     'args' => [
  3194	.       [
  3195	.         'fd_t',
  3196	.         'fd'
  3197	.       ],
  3198	.       [
  3199	.         'istr_t',
  3200	.         'name'
  3201	.       ],
  3202	.       [
  3203	.         'void_p',
  3204	.         'value'
  3205	.       ],
  3206	.       [
  3207	.         'size_t',
  3208	.         'size'
  3209	.       ]
  3210	.     ],
  3211	.     'ret' => 'int'
  3212	.   },
  3213	.   'listxattr' => {
  3214	.     'code' => 194,
  3215	.     'name' => 'listxattr',
  3216	.     'impl' => 1,
  3217	.     'args' => [
  3218	.       [
  3219	.         'istr_t',
  3220	.         'path'
  3221	.       ],
  3222	.       [
  3223	.         'ostr_t',
  3224	.         'list'
  3225	.       ],
  3226	.       [
  3227	.         'size_t',
  3228	.         'size'
  3229	.       ]
  3230	.     ],
  3231	.     'ret' => 'int'
  3232	.   },
  3233	.   'llistxattr' => {
  3234	.     'code' => 195,
  3235	.     'name' => 'llistxattr',
  3236	.     'impl' => 1,
  3237	.     'args' => [
  3238	.       [
  3239	.         'istr_t',
  3240	.         'path'
  3241	.       ],
  3242	.       [
  3243	.         'ostr_t',
  3244	.         'list'
  3245	.       ],
  3246	.       [
  3247	.         'size_t',
  3248	.         'size'
  3249	.       ]
  3250	.     ],
  3251	.     'ret' => 'int'
  3252	.   },
  3253	.   'flistxattr' => {
  3254	.     'code' => 196,
  3255	.     'name' => 'flistxattr',
  3256	.     'impl' => 1,
  3257	.     'args' => [
  3258	.       [
  3259	.         'fd_t',
  3260	.         'fd'
  3261	.       ],
  3262	.       [
  3263	.         'ostr_t',
  3264	.         'list'
  3265	.       ],
  3266	.       [
  3267	.         'size_t',
  3268	.         'size'
  3269	.       ]
  3270	.     ],
  3271	.     'ret' => 'int'
  3272	.   },
  3273	.   'removexattr' => {
  3274	.     'code' => 197,
  3275	.     'name' => 'removexattr',
  3276	.     'impl' => 1,
  3277	.     'args' => [
  3278	.       [
  3279	.         'istr_t',
  3280	.         'path'
  3281	.       ],
  3282	.       [
  3283	.         'istr_t',
  3284	.         'name'
  3285	.       ]
  3286	.     ],
  3287	.     'ret' => 'int'
  3288	.   },
  3289	.   'lremovexattr' => {
  3290	.     'code' => 198,
  3291	.     'name' => 'lremovexattr',
  3292	.     'impl' => 1,
  3293	.     'args' => [
  3294	.       [
  3295	.         'istr_t',
  3296	.         'path'
  3297	.       ],
  3298	.       [
  3299	.         'istr_t',
  3300	.         'name'
  3301	.       ]
  3302	.     ],
  3303	.     'ret' => 'int'
  3304	.   },
  3305	.   'fremovexattr' => {
  3306	.     'code' => 199,
  3307	.     'name' => 'fremovexattr',
  3308	.     'impl' => 1,
  3309	.     'args' => [
  3310	.       [
  3311	.         'fd_t',
  3312	.         'fd'
  3313	.       ],
  3314	.       [
  3315	.         'istr_t',
  3316	.         'name'
  3317	.       ]
  3318	.     ],
  3319	.     'ret' => 'int'
  3320	.   },
  3321	.   'tkill' => {
  3322	.     'code' => 200,
  3323	.     'name' => 'tkill',
  3324	.     'impl' => 1,
  3325	.     'args' => [
  3326	.       [
  3327	.         'pid_t',
  3328	.         'pid'
  3329	.       ],
  3330	.       [
  3331	.         'int',
  3332	.         'sig'
  3333	.       ]
  3334	.     ],
  3335	.     'ret' => 'int'
  3336	.   },
  3337	.   'time' => {
  3338	.     'code' => 201,
  3339	.     'name' => 'time',
  3340	.     'impl' => 1,
  3341	.     'args' => [
  3342	.       [
  3343	.         'time_p',
  3344	.         'tloc'
  3345	.       ]
  3346	.     ],
  3347	.     'ret' => 'time_t'
  3348	.   },
  3349	.   'futex' => {
  3350	.     'code' => 202,
  3351	.     'name' => 'futex',
  3352	.     'impl' => 1,
  3353	.     'args' => [
  3354	.       [
  3355	.         'uint32_p',
  3356	.         'uaddr'
  3357	.       ],
  3358	.       [
  3359	.         'int',
  3360	.         'op'
  3361	.       ],
  3362	.       [
  3363	.         'uint32_t',
  3364	.         'val'
  3365	.       ],
  3366	.       [
  3367	.         'timespec_p',
  3368	.         'utime'
  3369	.       ],
  3370	.       [
  3371	.         'uint32_p',
  3372	.         'uaddr2'
  3373	.       ],
  3374	.       [
  3375	.         'uint32_t',
  3376	.         'val3'
  3377	.       ]
  3378	.     ],
  3379	.     'ret' => 'int'
  3380	.   },
  3381	.   'sys_sched_setaffinity' => {
  3382	.     'code' => 203,
  3383	.     'name' => 'sched_setaffinity',
  3384	.     'impl' => 1,
  3385	.     'args' => [
  3386	.       [
  3387	.         'pid_t',
  3388	.         'pid'
  3389	.       ],
  3390	.       [
  3391	.         'size_t',
  3392	.         'len'
  3393	.       ],
  3394	.       [
  3395	.         'const void *',
  3396	.         'user_mask_ptr'
  3397	.       ]
  3398	.     ],
  3399	.     'ret' => 'int'
  3400	.   },
  3401	.   'sys_sched_getaffinity' => {
  3402	.     'code' => 204,
  3403	.     'name' => 'sched_getaffinity',
  3404	.     'impl' => 1,
  3405	.     'args' => [
  3406	.       [
  3407	.         'pid_t',
  3408	.         'pid'
  3409	.       ],
  3410	.       [
  3411	.         'unsigned',
  3412	.         'len'
  3413	.       ],
  3414	.       [
  3415	.         'uint64_p',
  3416	.         'user_mask_ptr'
  3417	.       ]
  3418	.     ],
  3419	.     'ret' => 'int'
  3420	.   },
  3421	.   'set_thread_area' => {
  3422	.     'code' => 205,
  3423	.     'name' => 'set_thread_area',
  3424	.     'impl' => 0
  3425	.   },
  3426	.   'io_setup' => {
  3427	.     'code' => 206,
  3428	.     'name' => 'io_setup',
  3429	.     'impl' => 1,
  3430	.     'args' => [
  3431	.       [
  3432	.         'unsigned',
  3433	.         'nr_events'
  3434	.       ],
  3435	.       [
  3436	.         'aio_context_p',
  3437	.         'ctxp'
  3438	.       ]
  3439	.     ],
  3440	.     'ret' => 'int'
  3441	.   },
  3442	.   'io_destroy' => {
  3443	.     'code' => 207,
  3444	.     'name' => 'io_destroy',
  3445	.     'impl' => 1,
  3446	.     'args' => [
  3447	.       [
  3448	.         'aio_context_t',
  3449	.         'ctx'
  3450	.       ]
  3451	.     ],
  3452	.     'ret' => 'int'
  3453	.   },
  3454	.   'io_getevents' => {
  3455	.     'code' => 208,
  3456	.     'name' => 'io_getevents',
  3457	.     'impl' => 1,
  3458	.     'args' => [
  3459	.       [
  3460	.         'aio_context_t',
  3461	.         'ctx_id'
  3462	.       ],
  3463	.       [
  3464	.         'long',
  3465	.         'min_nr'
  3466	.       ],
  3467	.       [
  3468	.         'long',
  3469	.         'nr'
  3470	.       ],
  3471	.       [
  3472	.         'io_event_p',
  3473	.         'events'
  3474	.       ]
  3475	.     ],
  3476	.     'ret' => 'int'
  3477	.   },
  3478	.   'io_submit' => {
  3479	.     'code' => 209,
  3480	.     'name' => 'io_submit',
  3481	.     'impl' => 1,
  3482	.     'args' => [
  3483	.       [
  3484	.         'aio_context_t',
  3485	.         'ctx_id'
  3486	.       ],
  3487	.       [
  3488	.         'long',
  3489	.         'nr'
  3490	.       ],
  3491	.       [
  3492	.         'iocb_p',
  3493	.         'iocbpp'
  3494	.       ]
  3495	.     ],
  3496	.     'ret' => 'int'
  3497	.   },
  3498	.   'io_cancel' => {
  3499	.     'code' => 210,
  3500	.     'name' => 'io_cancel',
  3501	.     'impl' => 1,
  3502	.     'args' => [
  3503	.       [
  3504	.         'aio_context_t',
  3505	.         'ctx_id'
  3506	.       ],
  3507	.       [
  3508	.         'iocb_p',
  3509	.         'iocb'
  3510	.       ],
  3511	.       [
  3512	.         'io_event_p',
  3513	.         'result'
  3514	.       ]
  3515	.     ],
  3516	.     'ret' => 'int'
  3517	.   },
  3518	.   'get_thread_area' => {
  3519	.     'code' => 211,
  3520	.     'name' => 'get_thread_area',
  3521	.     'impl' => 0
  3522	.   },
  3523	.   'lookup_dcookie' => {
  3524	.     'code' => 212,
  3525	.     'name' => 'lookup_dcookie',
  3526	.     'impl' => 1,
  3527	.     'args' => [
  3528	.       [
  3529	.         'uint64_t',
  3530	.         'cookie64'
  3531	.       ],
  3532	.       [
  3533	.         'long',
  3534	.         'buf'
  3535	.       ],
  3536	.       [
  3537	.         'long',
  3538	.         'len'
  3539	.       ]
  3540	.     ],
  3541	.     'ret' => 'int'
  3542	.   },
  3543	.   'epoll_create' => {
  3544	.     'code' => 213,
  3545	.     'name' => 'epoll_create',
  3546	.     'impl' => 1,
  3547	.     'args' => [
  3548	.       [
  3549	.         'int',
  3550	.         'size'
  3551	.       ]
  3552	.     ],
  3553	.     'ret' => 'int'
  3554	.   },
  3555	.   'epoll_ctl_old' => {
  3556	.     'code' => 214,
  3557	.     'name' => 'epoll_ctl_old',
  3558	.     'impl' => 0
  3559	.   },
  3560	.   'epoll_wait_old' => {
  3561	.     'code' => 215,
  3562	.     'name' => 'epoll_wait_old',
  3563	.     'impl' => 0
  3564	.   },
  3565	.   'remap_file_pages' => {
  3566	.     'code' => 216,
  3567	.     'name' => 'remap_file_pages',
  3568	.     'impl' => 1,
  3569	.     'args' => [
  3570	.       [
  3571	.         'uint64_t',
  3572	.         'start'
  3573	.       ],
  3574	.       [
  3575	.         'uint64_t',
  3576	.         'size'
  3577	.       ],
  3578	.       [
  3579	.         'uint64_t',
  3580	.         'prot'
  3581	.       ],
  3582	.       [
  3583	.         'uint64_t',
  3584	.         'pgoff'
  3585	.       ],
  3586	.       [
  3587	.         'uint64_t',
  3588	.         'flags'
  3589	.       ]
  3590	.     ],
  3591	.     'ret' => 'int'
  3592	.   },
  3593	.   'getdents64' => {
  3594	.     'code' => 217,
  3595	.     'name' => 'getdents64',
  3596	.     'impl' => 1,
  3597	.     'args' => [
  3598	.       [
  3599	.         'fd_t',
  3600	.         'fd'
  3601	.       ],
  3602	.       [
  3603	.         'linux_dirent64_p',
  3604	.         'dirent'
  3605	.       ],
  3606	.       [
  3607	.         'unsigned',
  3608	.         'count'
  3609	.       ]
  3610	.     ],
  3611	.     'ret' => 'int'
  3612	.   },
  3613	.   'set_tid_address' => {
  3614	.     'code' => 218,
  3615	.     'name' => 'set_tid_address',
  3616	.     'impl' => 1,
  3617	.     'args' => [
  3618	.       [
  3619	.         'int32_p',
  3620	.         'tidptr'
  3621	.       ]
  3622	.     ],
  3623	.     'ret' => 'int'
  3624	.   },
  3625	.   'restart_syscall' => {
  3626	.     'code' => 219,
  3627	.     'name' => 'restart_syscall',
  3628	.     'impl' => 1,
  3629	.     'args' => [],
  3630	.     'ret' => 'int'
  3631	.   },
  3632	.   'semtimedop' => {
  3633	.     'code' => 220,
  3634	.     'name' => 'semtimedop',
  3635	.     'impl' => 1,
  3636	.     'args' => [
  3637	.       [
  3638	.         'int',
  3639	.         'semid'
  3640	.       ],
  3641	.       [
  3642	.         'sembuf_p',
  3643	.         'tsops'
  3644	.       ],
  3645	.       [
  3646	.         'unsigned',
  3647	.         'nsops'
  3648	.       ],
  3649	.       [
  3650	.         'timespec_p',
  3651	.         'timeout'
  3652	.       ]
  3653	.     ],
  3654	.     'ret' => 'int'
  3655	.   },
  3656	.   'fadvise64' => {
  3657	.     'code' => 221,
  3658	.     'name' => 'fadvise64',
  3659	.     'impl' => 1,
  3660	.     'args' => [
  3661	.       [
  3662	.         'fd_t',
  3663	.         'fd'
  3664	.       ],
  3665	.       [
  3666	.         'off_t',
  3667	.         'offset'
  3668	.       ],
  3669	.       [
  3670	.         'size_t',
  3671	.         'len'
  3672	.       ],
  3673	.       [
  3674	.         'int',
  3675	.         'advice'
  3676	.       ]
  3677	.     ],
  3678	.     'ret' => 'int'
  3679	.   },
  3680	.   'timer_create' => {
  3681	.     'code' => 222,
  3682	.     'name' => 'timer_create',
  3683	.     'impl' => 1,
  3684	.     'args' => [
  3685	.       [
  3686	.         'const clockid_t',
  3687	.         'which_clock'
  3688	.       ],
  3689	.       [
  3690	.         'sigevent_p',
  3691	.         'timer_event_spec'
  3692	.       ],
  3693	.       [
  3694	.         'timer_p',
  3695	.         'created_timer_id'
  3696	.       ]
  3697	.     ],
  3698	.     'ret' => 'int'
  3699	.   },
  3700	.   'timer_settime' => {
  3701	.     'code' => 223,
  3702	.     'name' => 'timer_settime',
  3703	.     'impl' => 1,
  3704	.     'args' => [
  3705	.       [
  3706	.         'timer_t',
  3707	.         'timer_id'
  3708	.       ],
  3709	.       [
  3710	.         'int',
  3711	.         'flags'
  3712	.       ],
  3713	.       [
  3714	.         'itimerspec_p',
  3715	.         'new_setting'
  3716	.       ],
  3717	.       [
  3718	.         'itimerspec_p',
  3719	.         'old_setting'
  3720	.       ]
  3721	.     ],
  3722	.     'ret' => 'int'
  3723	.   },
  3724	.   'timer_gettime' => {
  3725	.     'code' => 224,
  3726	.     'name' => 'timer_gettime',
  3727	.     'impl' => 1,
  3728	.     'args' => [
  3729	.       [
  3730	.         'timer_t',
  3731	.         'timer_id'
  3732	.       ],
  3733	.       [
  3734	.         'itimerspec_p',
  3735	.         'setting'
  3736	.       ]
  3737	.     ],
  3738	.     'ret' => 'int'
  3739	.   },
  3740	.   'timer_getoverrun' => {
  3741	.     'code' => 225,
  3742	.     'name' => 'timer_getoverrun',
  3743	.     'impl' => 1,
  3744	.     'args' => [
  3745	.       [
  3746	.         'timer_t',
  3747	.         'timer_id'
  3748	.       ]
  3749	.     ],
  3750	.     'ret' => 'int'
  3751	.   },
  3752	.   'timer_delete' => {
  3753	.     'code' => 226,
  3754	.     'name' => 'timer_delete',
  3755	.     'impl' => 1,
  3756	.     'args' => [
  3757	.       [
  3758	.         'timer_t',
  3759	.         'timer_id'
  3760	.       ]
  3761	.     ],
  3762	.     'ret' => 'int'
  3763	.   },
  3764	.   'clock_settime' => {
  3765	.     'code' => 227,
  3766	.     'name' => 'clock_settime',
  3767	.     'impl' => 1,
  3768	.     'args' => [
  3769	.       [
  3770	.         'const clockid_t',
  3771	.         'which_clock'
  3772	.       ],
  3773	.       [
  3774	.         'timespec_p',
  3775	.         'tp'
  3776	.       ]
  3777	.     ],
  3778	.     'ret' => 'int'
  3779	.   },
  3780	.   'clock_gettime' => {
  3781	.     'code' => 228,
  3782	.     'name' => 'clock_gettime',
  3783	.     'impl' => 1,
  3784	.     'args' => [
  3785	.       [
  3786	.         'const clockid_t',
  3787	.         'which_clock'
  3788	.       ],
  3789	.       [
  3790	.         'timespec_p',
  3791	.         'tp'
  3792	.       ]
  3793	.     ],
  3794	.     'ret' => 'int'
  3795	.   },
  3796	.   'clock_getres' => {
  3797	.     'code' => 229,
  3798	.     'name' => 'clock_getres',
  3799	.     'impl' => 1,
  3800	.     'args' => [
  3801	.       [
  3802	.         'const clockid_t',
  3803	.         'which_clock'
  3804	.       ],
  3805	.       [
  3806	.         'timespec_p',
  3807	.         'tp'
  3808	.       ]
  3809	.     ],
  3810	.     'ret' => 'int'
  3811	.   },
  3812	.   'clock_nanosleep' => {
  3813	.     'code' => 230,
  3814	.     'name' => 'clock_nanosleep',
  3815	.     'impl' => 1,
  3816	.     'args' => [
  3817	.       [
  3818	.         'const clockid_t',
  3819	.         'which_clock'
  3820	.       ],
  3821	.       [
  3822	.         'int',
  3823	.         'flags'
  3824	.       ],
  3825	.       [
  3826	.         'timespec_p',
  3827	.         'rqtp'
  3828	.       ],
  3829	.       [
  3830	.         'timespec_p',
  3831	.         'rmtp'
  3832	.       ]
  3833	.     ],
  3834	.     'ret' => 'int'
  3835	.   },
  3836	.   'exit_group' => {
  3837	.     'code' => 231,
  3838	.     'name' => 'exit_group',
  3839	.     'impl' => 1,
  3840	.     'args' => [
  3841	.       [
  3842	.         'int',
  3843	.         'error_code'
  3844	.       ]
  3845	.     ],
  3846	.     'ret' => 'int'
  3847	.   },
  3848	.   'epoll_wait' => {
  3849	.     'code' => 232,
  3850	.     'name' => 'epoll_wait',
  3851	.     'impl' => 1,
  3852	.     'args' => [
  3853	.       [
  3854	.         'int',
  3855	.         'epfd'
  3856	.       ],
  3857	.       [
  3858	.         'epoll_event_p',
  3859	.         'events'
  3860	.       ],
  3861	.       [
  3862	.         'int',
  3863	.         'maxevents'
  3864	.       ],
  3865	.       [
  3866	.         'int',
  3867	.         'timeout'
  3868	.       ]
  3869	.     ],
  3870	.     'ret' => 'int'
  3871	.   },
  3872	.   'epoll_ctl' => {
  3873	.     'code' => 233,
  3874	.     'name' => 'epoll_ctl',
  3875	.     'impl' => 1,
  3876	.     'args' => [
  3877	.       [
  3878	.         'int',
  3879	.         'epfd'
  3880	.       ],
  3881	.       [
  3882	.         'int',
  3883	.         'op'
  3884	.       ],
  3885	.       [
  3886	.         'fd_t',
  3887	.         'fd'
  3888	.       ],
  3889	.       [
  3890	.         'epoll_event_p',
  3891	.         'event'
  3892	.       ]
  3893	.     ],
  3894	.     'ret' => 'int'
  3895	.   },
  3896	.   'tgkill' => {
  3897	.     'code' => 234,
  3898	.     'name' => 'tgkill',
  3899	.     'impl' => 1,
  3900	.     'args' => [
  3901	.       [
  3902	.         'pid_t',
  3903	.         'tgid'
  3904	.       ],
  3905	.       [
  3906	.         'pid_t',
  3907	.         'pid'
  3908	.       ],
  3909	.       [
  3910	.         'int',
  3911	.         'sig'
  3912	.       ]
  3913	.     ],
  3914	.     'ret' => 'int'
  3915	.   },
  3916	.   'utimes' => {
  3917	.     'code' => 235,
  3918	.     'name' => 'utimes',
  3919	.     'impl' => 1,
  3920	.     'args' => [
  3921	.       [
  3922	.         'ostr_t',
  3923	.         'path'
  3924	.       ],
  3925	.       [
  3926	.         'timeval_p',
  3927	.         'utimes'
  3928	.       ]
  3929	.     ],
  3930	.     'ret' => 'int'
  3931	.   },
  3932	.   'vserver' => {
  3933	.     'code' => 236,
  3934	.     'name' => 'vserver',
  3935	.     'impl' => 0
  3936	.   },
  3937	.   'mbind' => {
  3938	.     'code' => 237,
  3939	.     'name' => 'mbind',
  3940	.     'impl' => 1,
  3941	.     'args' => [
  3942	.       [
  3943	.         'uint64_t',
  3944	.         'start'
  3945	.       ],
  3946	.       [
  3947	.         'uint64_t',
  3948	.         'len'
  3949	.       ],
  3950	.       [
  3951	.         'uint64_t',
  3952	.         'mode'
  3953	.       ],
  3954	.       [
  3955	.         'uint64_p',
  3956	.         'nmask'
  3957	.       ],
  3958	.       [
  3959	.         'uint64_t',
  3960	.         'maxnode'
  3961	.       ],
  3962	.       [
  3963	.         'unsigned',
  3964	.         'flags'
  3965	.       ]
  3966	.     ],
  3967	.     'ret' => 'int'
  3968	.   },
  3969	.   'set_mempolicy' => {
  3970	.     'code' => 238,
  3971	.     'name' => 'set_mempolicy',
  3972	.     'impl' => 1,
  3973	.     'args' => [
  3974	.       [
  3975	.         'int',
  3976	.         'mode'
  3977	.       ],
  3978	.       [
  3979	.         'uint64_p',
  3980	.         'nmask'
  3981	.       ],
  3982	.       [
  3983	.         'uint64_t',
  3984	.         'maxnode'
  3985	.       ]
  3986	.     ],
  3987	.     'ret' => 'int'
  3988	.   },
  3989	.   'get_mempolicy' => {
  3990	.     'code' => 239,
  3991	.     'name' => 'get_mempolicy',
  3992	.     'impl' => 1,
  3993	.     'args' => [
  3994	.       [
  3995	.         'int32_p',
  3996	.         'policy'
  3997	.       ],
  3998	.       [
  3999	.         'uint64_p',
  4000	.         'nmask'
  4001	.       ],
  4002	.       [
  4003	.         'uint64_t',
  4004	.         'maxnode'
  4005	.       ],
  4006	.       [
  4007	.         'uint64_t',
  4008	.         'addr'
  4009	.       ],
  4010	.       [
  4011	.         'uint64_t',
  4012	.         'flags'
  4013	.       ]
  4014	.     ],
  4015	.     'ret' => 'int'
  4016	.   },
  4017	.   'mq_open' => {
  4018	.     'code' => 240,
  4019	.     'name' => 'mq_open',
  4020	.     'impl' => 1,
  4021	.     'args' => [
  4022	.       [
  4023	.         'istr_t',
  4024	.         'u_name'
  4025	.       ],
  4026	.       [
  4027	.         'int',
  4028	.         'oflag'
  4029	.       ],
  4030	.       [
  4031	.         'mode_t',
  4032	.         'mode'
  4033	.       ],
  4034	.       [
  4035	.         'mq_attr_p',
  4036	.         'u_attr'
  4037	.       ]
  4038	.     ],
  4039	.     'ret' => 'int'
  4040	.   },
  4041	.   'mq_unlink' => {
  4042	.     'code' => 241,
  4043	.     'name' => 'mq_unlink',
  4044	.     'impl' => 1,
  4045	.     'args' => [
  4046	.       [
  4047	.         'istr_t',
  4048	.         'u_name'
  4049	.       ]
  4050	.     ],
  4051	.     'ret' => 'int'
  4052	.   },
  4053	.   'mq_timedsend' => {
  4054	.     'code' => 242,
  4055	.     'name' => 'mq_timedsend',
  4056	.     'impl' => 1,
  4057	.     'args' => [
  4058	.       [
  4059	.         'mqd_t',
  4060	.         'mqdes'
  4061	.       ],
  4062	.       [
  4063	.         'istr_t',
  4064	.         'u_msg_ptr'
  4065	.       ],
  4066	.       [
  4067	.         'size_t',
  4068	.         'msg_len'
  4069	.       ],
  4070	.       [
  4071	.         'unsigned',
  4072	.         'msg_prio'
  4073	.       ],
  4074	.       [
  4075	.         'timespec_p',
  4076	.         'u_abs_timeout'
  4077	.       ]
  4078	.     ],
  4079	.     'ret' => 'int'
  4080	.   },
  4081	.   'mq_timedreceive' => {
  4082	.     'code' => 243,
  4083	.     'name' => 'mq_timedreceive',
  4084	.     'impl' => 1,
  4085	.     'args' => [
  4086	.       [
  4087	.         'mqd_t',
  4088	.         'mqdes'
  4089	.       ],
  4090	.       [
  4091	.         'ostr_t',
  4092	.         'u_msg_ptr'
  4093	.       ],
  4094	.       [
  4095	.         'size_t',
  4096	.         'msg_len'
  4097	.       ],
  4098	.       [
  4099	.         'uint32_p',
  4100	.         'u_msg_prio'
  4101	.       ],
  4102	.       [
  4103	.         'timespec_p',
  4104	.         'u_abs_timeout'
  4105	.       ]
  4106	.     ],
  4107	.     'ret' => 'int'
  4108	.   },
  4109	.   'mq_notify' => {
  4110	.     'code' => 244,
  4111	.     'name' => 'mq_notify',
  4112	.     'impl' => 1,
  4113	.     'args' => [
  4114	.       [
  4115	.         'mqd_t',
  4116	.         'mqdes'
  4117	.       ],
  4118	.       [
  4119	.         'sigevent_p',
  4120	.         'u_notification'
  4121	.       ]
  4122	.     ],
  4123	.     'ret' => 'int'
  4124	.   },
  4125	.   'mq_getsetattr' => {
  4126	.     'code' => 245,
  4127	.     'name' => 'mq_getsetattr',
  4128	.     'impl' => 1,
  4129	.     'args' => [
  4130	.       [
  4131	.         'mqd_t',
  4132	.         'mqdes'
  4133	.       ],
  4134	.       [
  4135	.         'mq_attr_p',
  4136	.         'u_mqstat'
  4137	.       ],
  4138	.       [
  4139	.         'mq_attr_p',
  4140	.         'u_omqstat'
  4141	.       ]
  4142	.     ],
  4143	.     'ret' => 'int'
  4144	.   },
  4145	.   'kexec_load' => {
  4146	.     'code' => 246,
  4147	.     'name' => 'kexec_load',
  4148	.     'impl' => 1,
  4149	.     'args' => [
  4150	.       [
  4151	.         'uint64_t',
  4152	.         'entry'
  4153	.       ],
  4154	.       [
  4155	.         'uint64_t',
  4156	.         'nr_segments'
  4157	.       ],
  4158	.       [
  4159	.         'kexec_segment_p',
  4160	.         'segments'
  4161	.       ],
  4162	.       [
  4163	.         'uint64_t',
  4164	.         'flags'
  4165	.       ]
  4166	.     ],
  4167	.     'ret' => 'int'
  4168	.   },
  4169	.   'waitid' => {
  4170	.     'code' => 247,
  4171	.     'name' => 'waitid',
  4172	.     'impl' => 1,
  4173	.     'args' => [
  4174	.       [
  4175	.         'int',
  4176	.         'which'
  4177	.       ],
  4178	.       [
  4179	.         'pid_t',
  4180	.         'upid'
  4181	.       ],
  4182	.       [
  4183	.         'siginfo_p',
  4184	.         'infop'
  4185	.       ],
  4186	.       [
  4187	.         'int',
  4188	.         'options'
  4189	.       ],
  4190	.       [
  4191	.         'rusage_p',
  4192	.         'ru'
  4193	.       ]
  4194	.     ],
  4195	.     'ret' => 'int'
  4196	.   },
  4197	.   'add_key' => {
  4198	.     'code' => 248,
  4199	.     'name' => 'add_key',
  4200	.     'impl' => 1,
  4201	.     'args' => [
  4202	.       [
  4203	.         'istr_t',
  4204	.         '_type'
  4205	.       ],
  4206	.       [
  4207	.         'istr_t',
  4208	.         '_description'
  4209	.       ],
  4210	.       [
  4211	.         'const void_p',
  4212	.         '_payload'
  4213	.       ],
  4214	.       [
  4215	.         'size_t',
  4216	.         'plen'
  4217	.       ]
  4218	.     ],
  4219	.     'ret' => 'int'
  4220	.   },
  4221	.   'request_key' => {
  4222	.     'code' => 249,
  4223	.     'name' => 'request_key',
  4224	.     'impl' => 1,
  4225	.     'args' => [
  4226	.       [
  4227	.         'istr_t',
  4228	.         '_type'
  4229	.       ],
  4230	.       [
  4231	.         'istr_t',
  4232	.         '_description'
  4233	.       ],
  4234	.       [
  4235	.         'istr_t',
  4236	.         '_callout_info'
  4237	.       ],
  4238	.       [
  4239	.         'uint64_t',
  4240	.         'destringid'
  4241	.       ]
  4242	.     ],
  4243	.     'ret' => 'int'
  4244	.   },
  4245	.   'keyctl' => {
  4246	.     'code' => 250,
  4247	.     'name' => 'keyctl',
  4248	.     'impl' => 1,
  4249	.     'args' => [
  4250	.       [
  4251	.         'int',
  4252	.         'option'
  4253	.       ],
  4254	.       [
  4255	.         'uint64_t',
  4256	.         'arg2'
  4257	.       ],
  4258	.       [
  4259	.         'uint64_t',
  4260	.         'arg3'
  4261	.       ],
  4262	.       [
  4263	.         'uint64_t',
  4264	.         'arg4'
  4265	.       ],
  4266	.       [
  4267	.         'uint64_t',
  4268	.         'arg5'
  4269	.       ]
  4270	.     ],
  4271	.     'ret' => 'int'
  4272	.   },
  4273	.   'ioprio_set' => {
  4274	.     'code' => 251,
  4275	.     'name' => 'ioprio_set',
  4276	.     'impl' => 1,
  4277	.     'args' => [
  4278	.       [
  4279	.         'int',
  4280	.         'which'
  4281	.       ],
  4282	.       [
  4283	.         'int',
  4284	.         'who'
  4285	.       ],
  4286	.       [
  4287	.         'int',
  4288	.         'ioprio'
  4289	.       ]
  4290	.     ],
  4291	.     'ret' => 'int'
  4292	.   },
  4293	.   'ioprio_get' => {
  4294	.     'code' => 252,
  4295	.     'name' => 'ioprio_get',
  4296	.     'impl' => 1,
  4297	.     'args' => [
  4298	.       [
  4299	.         'int',
  4300	.         'which'
  4301	.       ],
  4302	.       [
  4303	.         'int',
  4304	.         'who'
  4305	.       ]
  4306	.     ],
  4307	.     'ret' => 'int'
  4308	.   },
  4309	.   'inotify_init' => {
  4310	.     'code' => 253,
  4311	.     'name' => 'inotify_init',
  4312	.     'impl' => 1,
  4313	.     'args' => [],
  4314	.     'ret' => 'int'
  4315	.   },
  4316	.   'inotify_add_watch' => {
  4317	.     'code' => 254,
  4318	.     'name' => 'inotify_add_watch',
  4319	.     'impl' => 1,
  4320	.     'args' => [
  4321	.       [
  4322	.         'fd_t',
  4323	.         'fd'
  4324	.       ],
  4325	.       [
  4326	.         'istr_t',
  4327	.         'path'
  4328	.       ],
  4329	.       [
  4330	.         'uint32_t',
  4331	.         'mask'
  4332	.       ]
  4333	.     ],
  4334	.     'ret' => 'int'
  4335	.   },
  4336	.   'inotify_rm_watch' => {
  4337	.     'code' => 255,
  4338	.     'name' => 'inotify_rm_watch',
  4339	.     'impl' => 1,
  4340	.     'args' => [
  4341	.       [
  4342	.         'fd_t',
  4343	.         'fd'
  4344	.       ],
  4345	.       [
  4346	.         'int32_t',
  4347	.         'wd'
  4348	.       ]
  4349	.     ],
  4350	.     'ret' => 'int'
  4351	.   },
  4352	.   'migrate_pages' => {
  4353	.     'code' => 256,
  4354	.     'name' => 'migrate_pages',
  4355	.     'impl' => 1,
  4356	.     'args' => [
  4357	.       [
  4358	.         'pid_t',
  4359	.         'pid'
  4360	.       ],
  4361	.       [
  4362	.         'uint64_t',
  4363	.         'maxnode'
  4364	.       ],
  4365	.       [
  4366	.         'uint64_p',
  4367	.         'old_nodes'
  4368	.       ],
  4369	.       [
  4370	.         'uint64_p',
  4371	.         'new_nodes'
  4372	.       ]
  4373	.     ],
  4374	.     'ret' => 'int'
  4375	.   },
  4376	.   'openat' => {
  4377	.     'code' => 257,
  4378	.     'name' => 'openat',
  4379	.     'impl' => 1,
  4380	.     'args' => [
  4381	.       [
  4382	.         'fd_t',
  4383	.         'dfd'
  4384	.       ],
  4385	.       [
  4386	.         'istr_t',
  4387	.         'path'
  4388	.       ],
  4389	.       [
  4390	.         'int',
  4391	.         'flags'
  4392	.       ],
  4393	.       [
  4394	.         'int',
  4395	.         'mode'
  4396	.       ]
  4397	.     ],
  4398	.     'ret' => 'int'
  4399	.   },
  4400	.   'mkdirat' => {
  4401	.     'code' => 258,
  4402	.     'name' => 'mkdirat',
  4403	.     'impl' => 1,
  4404	.     'args' => [
  4405	.       [
  4406	.         'fd_t',
  4407	.         'dfd'
  4408	.       ],
  4409	.       [
  4410	.         'istr_t',
  4411	.         'path'
  4412	.       ],
  4413	.       [
  4414	.         'int',
  4415	.         'mode'
  4416	.       ]
  4417	.     ],
  4418	.     'ret' => 'int'
  4419	.   },
  4420	.   'mknodat' => {
  4421	.     'code' => 259,
  4422	.     'name' => 'mknodat',
  4423	.     'impl' => 1,
  4424	.     'args' => [
  4425	.       [
  4426	.         'fd_t',
  4427	.         'dfd'
  4428	.       ],
  4429	.       [
  4430	.         'istr_t',
  4431	.         'path'
  4432	.       ],
  4433	.       [
  4434	.         'int',
  4435	.         'mode'
  4436	.       ],
  4437	.       [
  4438	.         'unsigned',
  4439	.         'dev'
  4440	.       ]
  4441	.     ],
  4442	.     'ret' => 'int'
  4443	.   },
  4444	.   'fchownat' => {
  4445	.     'code' => 260,
  4446	.     'name' => 'fchownat',
  4447	.     'impl' => 1,
  4448	.     'args' => [
  4449	.       [
  4450	.         'fd_t',
  4451	.         'dfd'
  4452	.       ],
  4453	.       [
  4454	.         'istr_t',
  4455	.         'path'
  4456	.       ],
  4457	.       [
  4458	.         'uid_t',
  4459	.         'user'
  4460	.       ],
  4461	.       [
  4462	.         'gid_t',
  4463	.         'group'
  4464	.       ],
  4465	.       [
  4466	.         'int',
  4467	.         'flag'
  4468	.       ]
  4469	.     ],
  4470	.     'ret' => 'int'
  4471	.   },
  4472	.   'futimesat' => {
  4473	.     'code' => 261,
  4474	.     'name' => 'futimesat',
  4475	.     'impl' => 1,
  4476	.     'args' => [
  4477	.       [
  4478	.         'fd_t',
  4479	.         'dfd'
  4480	.       ],
  4481	.       [
  4482	.         'istr_t',
  4483	.         'path'
  4484	.       ],
  4485	.       [
  4486	.         'timeval_p',
  4487	.         'utimes'
  4488	.       ]
  4489	.     ],
  4490	.     'ret' => 'int'
  4491	.   },
  4492	.   'newfstatat' => {
  4493	.     'code' => 262,
  4494	.     'name' => 'newfstatat',
  4495	.     'impl' => 1,
  4496	.     'args' => [
  4497	.       [
  4498	.         'fd_t',
  4499	.         'dfd'
  4500	.       ],
  4501	.       [
  4502	.         'istr_t',
  4503	.         'path'
  4504	.       ],
  4505	.       [
  4506	.         'stat_p',
  4507	.         'statbuf'
  4508	.       ],
  4509	.       [
  4510	.         'int',
  4511	.         'flag'
  4512	.       ]
  4513	.     ],
  4514	.     'ret' => 'int'
  4515	.   },
  4516	.   'unlinkat' => {
  4517	.     'code' => 263,
  4518	.     'name' => 'unlinkat',
  4519	.     'impl' => 1,
  4520	.     'args' => [
  4521	.       [
  4522	.         'fd_t',
  4523	.         'dfd'
  4524	.       ],
  4525	.       [
  4526	.         'istr_t',
  4527	.         'path'
  4528	.       ],
  4529	.       [
  4530	.         'int',
  4531	.         'flag'
  4532	.       ]
  4533	.     ],
  4534	.     'ret' => 'int'
  4535	.   },
  4536	.   'renameat' => {
  4537	.     'code' => 264,
  4538	.     'name' => 'renameat',
  4539	.     'impl' => 1,
  4540	.     'args' => [
  4541	.       [
  4542	.         'fd_t',
  4543	.         'oldfd'
  4544	.       ],
  4545	.       [
  4546	.         'istr_t',
  4547	.         'opath'
  4548	.       ],
  4549	.       [
  4550	.         'fd_t',
  4551	.         'newfd'
  4552	.       ],
  4553	.       [
  4554	.         'istr_t',
  4555	.         'npath'
  4556	.       ]
  4557	.     ],
  4558	.     'ret' => 'int'
  4559	.   },
  4560	.   'linkat' => {
  4561	.     'code' => 265,
  4562	.     'name' => 'linkat',
  4563	.     'impl' => 1,
  4564	.     'args' => [
  4565	.       [
  4566	.         'fd_t',
  4567	.         'oldfd'
  4568	.       ],
  4569	.       [
  4570	.         'istr_t',
  4571	.         'opath'
  4572	.       ],
  4573	.       [
  4574	.         'fd_t',
  4575	.         'newfd'
  4576	.       ],
  4577	.       [
  4578	.         'istr_t',
  4579	.         'npath'
  4580	.       ],
  4581	.       [
  4582	.         'int',
  4583	.         'flags'
  4584	.       ]
  4585	.     ],
  4586	.     'ret' => 'int'
  4587	.   },
  4588	.   'symlinkat' => {
  4589	.     'code' => 266,
  4590	.     'name' => 'symlinkat',
  4591	.     'impl' => 1,
  4592	.     'args' => [
  4593	.       [
  4594	.         'istr_t',
  4595	.         'opath'
  4596	.       ],
  4597	.       [
  4598	.         'fd_t',
  4599	.         'newfd'
  4600	.       ],
  4601	.       [
  4602	.         'istr_t',
  4603	.         'npath'
  4604	.       ]
  4605	.     ],
  4606	.     'ret' => 'int'
  4607	.   },
  4608	.   'readlinkat' => {
  4609	.     'code' => 267,
  4610	.     'name' => 'readlinkat',
  4611	.     'impl' => 1,
  4612	.     'args' => [
  4613	.       [
  4614	.         'fd_t',
  4615	.         'dfd'
  4616	.       ],
  4617	.       [
  4618	.         'istr_t',
  4619	.         'path'
  4620	.       ],
  4621	.       [
  4622	.         'ostr_t',
  4623	.         'buf'
  4624	.       ],
  4625	.       [
  4626	.         'int',
  4627	.         'bufsiz'
  4628	.       ]
  4629	.     ],
  4630	.     'ret' => 'int'
  4631	.   },
  4632	.   'fchmodat' => {
  4633	.     'code' => 268,
  4634	.     'name' => 'fchmodat',
  4635	.     'impl' => 1,
  4636	.     'args' => [
  4637	.       [
  4638	.         'fd_t',
  4639	.         'dfd'
  4640	.       ],
  4641	.       [
  4642	.         'istr_t',
  4643	.         'path'
  4644	.       ],
  4645	.       [
  4646	.         'mode_t',
  4647	.         'mode'
  4648	.       ]
  4649	.     ],
  4650	.     'ret' => 'int'
  4651	.   },
  4652	.   'faccessat' => {
  4653	.     'code' => 269,
  4654	.     'name' => 'faccessat',
  4655	.     'impl' => 1,
  4656	.     'args' => [
  4657	.       [
  4658	.         'fd_t',
  4659	.         'dfd'
  4660	.       ],
  4661	.       [
  4662	.         'istr_t',
  4663	.         'path'
  4664	.       ],
  4665	.       [
  4666	.         'int',
  4667	.         'mode'
  4668	.       ]
  4669	.     ],
  4670	.     'ret' => 'int'
  4671	.   },
  4672	.   'pselect6' => {
  4673	.     'code' => 270,
  4674	.     'name' => 'pselect6',
  4675	.     'impl' => 1,
  4676	.     'args' => [
  4677	.       [
  4678	.         'int',
  4679	.         'n'
  4680	.       ],
  4681	.       [
  4682	.         'fd_set_p',
  4683	.         'inp'
  4684	.       ],
  4685	.       [
  4686	.         'fd_set_p',
  4687	.         'outp'
  4688	.       ],
  4689	.       [
  4690	.         'fd_set_p',
  4691	.         'exp'
  4692	.       ],
  4693	.       [
  4694	.         'timespec_p',
  4695	.         'tsp'
  4696	.       ],
  4697	.       [
  4698	.         'void_p',
  4699	.         'sig'
  4700	.       ]
  4701	.     ],
  4702	.     'ret' => 'int'
  4703	.   },
  4704	.   'ppoll' => {
  4705	.     'code' => 271,
  4706	.     'name' => 'ppoll',
  4707	.     'impl' => 1,
  4708	.     'args' => [
  4709	.       [
  4710	.         'pollfd_p',
  4711	.         'ufds'
  4712	.       ],
  4713	.       [
  4714	.         'unsigned',
  4715	.         'nfds'
  4716	.       ],
  4717	.       [
  4718	.         'timespec_p',
  4719	.         'tsp'
  4720	.       ],
  4721	.       [
  4722	.         'const sigset_p',
  4723	.         'sigmask'
  4724	.       ],
  4725	.       [
  4726	.         'size_t',
  4727	.         'sigsetsize'
  4728	.       ]
  4729	.     ],
  4730	.     'ret' => 'int'
  4731	.   },
  4732	.   'unshare' => {
  4733	.     'code' => 272,
  4734	.     'name' => 'unshare',
  4735	.     'impl' => 1,
  4736	.     'args' => [
  4737	.       [
  4738	.         'int',
  4739	.         'unshare_flags'
  4740	.       ]
  4741	.     ],
  4742	.     'ret' => 'int'
  4743	.   },
  4744	.   'set_robust_list' => {
  4745	.     'code' => 273,
  4746	.     'name' => 'set_robust_list',
  4747	.     'impl' => 1,
  4748	.     'args' => [
  4749	.       [
  4750	.         'robust_list_head_p',
  4751	.         'head'
  4752	.       ],
  4753	.       [
  4754	.         'size_t',
  4755	.         'len'
  4756	.       ]
  4757	.     ],
  4758	.     'ret' => 'int'
  4759	.   },
  4760	.   'get_robust_list' => {
  4761	.     'code' => 274,
  4762	.     'name' => 'get_robust_list',
  4763	.     'impl' => 1,
  4764	.     'args' => [
  4765	.       [
  4766	.         'int',
  4767	.         'pid'
  4768	.       ],
  4769	.       [
  4770	.         'robust_list_head_p',
  4771	.         'head_ptr'
  4772	.       ],
  4773	.       [
  4774	.         'size_p',
  4775	.         'len_ptr'
  4776	.       ]
  4777	.     ],
  4778	.     'ret' => 'int'
  4779	.   },
  4780	.   'splice' => {
  4781	.     'code' => 275,
  4782	.     'name' => 'splice',
  4783	.     'impl' => 1,
  4784	.     'args' => [
  4785	.       [
  4786	.         'int',
  4787	.         'fd_in'
  4788	.       ],
  4789	.       [
  4790	.         'off_p',
  4791	.         'off_in'
  4792	.       ],
  4793	.       [
  4794	.         'int',
  4795	.         'fd_out'
  4796	.       ],
  4797	.       [
  4798	.         'off_p',
  4799	.         'off_out'
  4800	.       ],
  4801	.       [
  4802	.         'size_t',
  4803	.         'len'
  4804	.       ],
  4805	.       [
  4806	.         'unsigned',
  4807	.         'flags'
  4808	.       ]
  4809	.     ],
  4810	.     'ret' => 'int'
  4811	.   },
  4812	.   'tee' => {
  4813	.     'code' => 276,
  4814	.     'name' => 'tee',
  4815	.     'impl' => 1,
  4816	.     'args' => [
  4817	.       [
  4818	.         'int',
  4819	.         'fdin'
  4820	.       ],
  4821	.       [
  4822	.         'int',
  4823	.         'fdout'
  4824	.       ],
  4825	.       [
  4826	.         'size_t',
  4827	.         'len'
  4828	.       ],
  4829	.       [
  4830	.         'unsigned',
  4831	.         'flags'
  4832	.       ]
  4833	.     ],
  4834	.     'ret' => 'int'
  4835	.   },
  4836	.   'sync_file_range' => {
  4837	.     'code' => 277,
  4838	.     'name' => 'sync_file_range',
  4839	.     'impl' => 1,
  4840	.     'args' => [
  4841	.       [
  4842	.         'fd_t',
  4843	.         'fd'
  4844	.       ],
  4845	.       [
  4846	.         'off_t',
  4847	.         'offset'
  4848	.       ],
  4849	.       [
  4850	.         'off_t',
  4851	.         'bytes'
  4852	.       ],
  4853	.       [
  4854	.         'long',
  4855	.         'flags'
  4856	.       ]
  4857	.     ],
  4858	.     'ret' => 'int'
  4859	.   },
  4860	.   'vmsplice' => {
  4861	.     'code' => 278,
  4862	.     'name' => 'vmsplice',
  4863	.     'impl' => 1,
  4864	.     'args' => [
  4865	.       [
  4866	.         'fd_t',
  4867	.         'fd'
  4868	.       ],
  4869	.       [
  4870	.         'iovec_p',
  4871	.         'iov'
  4872	.       ],
  4873	.       [
  4874	.         'uint64_t',
  4875	.         'nr_segs'
  4876	.       ],
  4877	.       [
  4878	.         'unsigned',
  4879	.         'flags'
  4880	.       ]
  4881	.     ],
  4882	.     'ret' => 'int'
  4883	.   },
  4884	.   'move_pages' => {
  4885	.     'code' => 279,
  4886	.     'name' => 'move_pages',
  4887	.     'impl' => 1,
  4888	.     'args' => [
  4889	.       [
  4890	.         'pid_t',
  4891	.         'pid'
  4892	.       ],
  4893	.       [
  4894	.         'uint64_t',
  4895	.         'nr_pages'
  4896	.       ],
  4897	.       [
  4898	.         'void_p',
  4899	.         'pages'
  4900	.       ],
  4901	.       [
  4902	.         'int32_p',
  4903	.         'nodes'
  4904	.       ],
  4905	.       [
  4906	.         'int32_p',
  4907	.         'status'
  4908	.       ],
  4909	.       [
  4910	.         'int',
  4911	.         'flags'
  4912	.       ]
  4913	.     ],
  4914	.     'ret' => 'int'
  4915	.   },
  4916	.   'utimensat' => {
  4917	.     'code' => 280,
  4918	.     'name' => 'utimensat',
  4919	.     'impl' => 1,
  4920	.     'args' => [
  4921	.       [
  4922	.         'fd_t',
  4923	.         'dfd'
  4924	.       ],
  4925	.       [
  4926	.         'istr_t',
  4927	.         'path'
  4928	.       ],
  4929	.       [
  4930	.         'timespec_p',
  4931	.         'utimes'
  4932	.       ],
  4933	.       [
  4934	.         'int',
  4935	.         'flags'
  4936	.       ]
  4937	.     ],
  4938	.     'ret' => 'int'
  4939	.   },
  4940	.   'epoll_pwait' => {
  4941	.     'code' => 281,
  4942	.     'name' => 'epoll_pwait',
  4943	.     'impl' => 1,
  4944	.     'args' => [
  4945	.       [
  4946	.         'int',
  4947	.         'epfd'
  4948	.       ],
  4949	.       [
  4950	.         'epoll_event_p',
  4951	.         'events'
  4952	.       ],
  4953	.       [
  4954	.         'int',
  4955	.         'maxevents'
  4956	.       ],
  4957	.       [
  4958	.         'int',
  4959	.         'timeout'
  4960	.       ],
  4961	.       [
  4962	.         'const sigset_p',
  4963	.         'sigmask'
  4964	.       ],
  4965	.       [
  4966	.         'size_t',
  4967	.         'sigsetsize'
  4968	.       ]
  4969	.     ],
  4970	.     'ret' => 'int'
  4971	.   },
  4972	.   'signalfd' => {
  4973	.     'code' => 282,
  4974	.     'name' => 'signalfd',
  4975	.     'impl' => 1,
  4976	.     'args' => [
  4977	.       [
  4978	.         'int',
  4979	.         'ufd'
  4980	.       ],
  4981	.       [
  4982	.         'sigset_p',
  4983	.         'user_mask'
  4984	.       ],
  4985	.       [
  4986	.         'size_t',
  4987	.         'sizemask'
  4988	.       ]
  4989	.     ],
  4990	.     'ret' => 'int'
  4991	.   },
  4992	.   'timerfd_create' => {
  4993	.     'code' => 283,
  4994	.     'name' => 'timerfd_create',
  4995	.     'impl' => 1,
  4996	.     'args' => [
  4997	.       [
  4998	.         'int',
  4999	.         'clockid'
  5000	.       ],
  5001	.       [
  5002	.         'int',
  5003	.         'flags'
  5004	.       ]
  5005	.     ],
  5006	.     'ret' => 'int'
  5007	.   },
  5008	.   'eventfd' => {
  5009	.     'code' => 284,
  5010	.     'name' => 'eventfd',
  5011	.     'impl' => 1,
  5012	.     'args' => [
  5013	.       [
  5014	.         'unsigned',
  5015	.         'count'
  5016	.       ]
  5017	.     ],
  5018	.     'ret' => 'int'
  5019	.   },
  5020	.   'fallocate' => {
  5021	.     'code' => 285,
  5022	.     'name' => 'fallocate',
  5023	.     'impl' => 1,
  5024	.     'args' => [
  5025	.       [
  5026	.         'fd_t',
  5027	.         'fd'
  5028	.       ],
  5029	.       [
  5030	.         'long',
  5031	.         'mode'
  5032	.       ],
  5033	.       [
  5034	.         'off_t',
  5035	.         'offset'
  5036	.       ],
  5037	.       [
  5038	.         'off_t',
  5039	.         'len'
  5040	.       ]
  5041	.     ],
  5042	.     'ret' => 'int'
  5043	.   },
  5044	.   'timerfd_settime' => {
  5045	.     'code' => 286,
  5046	.     'name' => 'timerfd_settime',
  5047	.     'impl' => 1,
  5048	.     'args' => [
  5049	.       [
  5050	.         'int',
  5051	.         'ufd'
  5052	.       ],
  5053	.       [
  5054	.         'int',
  5055	.         'flags'
  5056	.       ],
  5057	.       [
  5058	.         'itimerspec_p',
  5059	.         'utmr'
  5060	.       ],
  5061	.       [
  5062	.         'itimerspec_p',
  5063	.         'otmr'
  5064	.       ]
  5065	.     ],
  5066	.     'ret' => 'int'
  5067	.   },
  5068	.   'timerfd_gettime' => {
  5069	.     'code' => 287,
  5070	.     'name' => 'timerfd_gettime',
  5071	.     'impl' => 1,
  5072	.     'args' => [
  5073	.       [
  5074	.         'int',
  5075	.         'ufd'
  5076	.       ],
  5077	.       [
  5078	.         'itimerspec_p',
  5079	.         'otmr'
  5080	.       ]
  5081	.     ],
  5082	.     'ret' => 'int'
  5083	.   },
  5084	.   'accept4' => {
  5085	.     'code' => 288,
  5086	.     'name' => 'accept4',
  5087	.     'impl' => 1,
  5088	.     'args' => [
  5089	.       [
  5090	.         'fd_t',
  5091	.         'fd'
  5092	.       ],
  5093	.       [
  5094	.         'sockaddr_p',
  5095	.         'upeer_sockaddr'
  5096	.       ],
  5097	.       [
  5098	.         'int32_p',
  5099	.         'upeer_addrlen'
  5100	.       ],
  5101	.       [
  5102	.         'int',
  5103	.         'flags'
  5104	.       ]
  5105	.     ],
  5106	.     'ret' => 'int'
  5107	.   },
  5108	.   'signalfd4' => {
  5109	.     'code' => 289,
  5110	.     'name' => 'signalfd4',
  5111	.     'impl' => 1,
  5112	.     'args' => [
  5113	.       [
  5114	.         'int',
  5115	.         'ufd'
  5116	.       ],
  5117	.       [
  5118	.         'sigset_p',
  5119	.         'user_mask'
  5120	.       ],
  5121	.       [
  5122	.         'size_t',
  5123	.         'sizemask'
  5124	.       ],
  5125	.       [
  5126	.         'int',
  5127	.         'flags'
  5128	.       ]
  5129	.     ],
  5130	.     'ret' => 'int'
  5131	.   },
  5132	.   'eventfd2' => {
  5133	.     'code' => 290,
  5134	.     'name' => 'eventfd2',
  5135	.     'impl' => 1,
  5136	.     'args' => [
  5137	.       [
  5138	.         'unsigned',
  5139	.         'count'
  5140	.       ],
  5141	.       [
  5142	.         'int',
  5143	.         'flags'
  5144	.       ]
  5145	.     ],
  5146	.     'ret' => 'int'
  5147	.   },
  5148	.   'epoll_create1' => {
  5149	.     'code' => 291,
  5150	.     'name' => 'epoll_create1',
  5151	.     'impl' => 1,
  5152	.     'args' => [
  5153	.       [
  5154	.         'int',
  5155	.         'flags'
  5156	.       ]
  5157	.     ],
  5158	.     'ret' => 'int'
  5159	.   },
  5160	.   'dup3' => {
  5161	.     'code' => 292,
  5162	.     'name' => 'dup3',
  5163	.     'impl' => 1,
  5164	.     'args' => [
  5165	.       [
  5166	.         'fd_t',
  5167	.         'oldfd'
  5168	.       ],
  5169	.       [
  5170	.         'fd_t',
  5171	.         'newfd'
  5172	.       ],
  5173	.       [
  5174	.         'int',
  5175	.         'flags'
  5176	.       ]
  5177	.     ],
  5178	.     'ret' => 'int'
  5179	.   },
  5180	.   'pipe2' => {
  5181	.     'code' => 293,
  5182	.     'name' => 'pipe2',
  5183	.     'impl' => 1,
  5184	.     'args' => [
  5185	.       [
  5186	.         'fd_p',
  5187	.         'filedes'
  5188	.       ],
  5189	.       [
  5190	.         'int',
  5191	.         'flags'
  5192	.       ]
  5193	.     ],
  5194	.     'ret' => 'int'
  5195	.   },
  5196	.   'inotify_init1' => {
  5197	.     'code' => 294,
  5198	.     'name' => 'inotify_init1',
  5199	.     'impl' => 1,
  5200	.     'args' => [
  5201	.       [
  5202	.         'int',
  5203	.         'flags'
  5204	.       ]
  5205	.     ],
  5206	.     'ret' => 'int'
  5207	.   },
  5208	.   'preadv' => {
  5209	.     'code' => 295,
  5210	.     'name' => 'preadv',
  5211	.     'impl' => 1,
  5212	.     'args' => [
  5213	.       [
  5214	.         'fd_t',
  5215	.         'fd'
  5216	.       ],
  5217	.       [
  5218	.         'iovec_p',
  5219	.         'vec'
  5220	.       ],
  5221	.       [
  5222	.         'uint64_t',
  5223	.         'vlen'
  5224	.       ],
  5225	.       [
  5226	.         'uint64_t',
  5227	.         'pos_l'
  5228	.       ],
  5229	.       [
  5230	.         'uint64_t',
  5231	.         'pos_h'
  5232	.       ]
  5233	.     ],
  5234	.     'ret' => 'int'
  5235	.   },
  5236	.   'pwritev' => {
  5237	.     'code' => 296,
  5238	.     'name' => 'pwritev',
  5239	.     'impl' => 1,
  5240	.     'args' => [
  5241	.       [
  5242	.         'fd_t',
  5243	.         'fd'
  5244	.       ],
  5245	.       [
  5246	.         'iovec_p',
  5247	.         'vec'
  5248	.       ],
  5249	.       [
  5250	.         'uint64_t',
  5251	.         'vlen'
  5252	.       ],
  5253	.       [
  5254	.         'uint64_t',
  5255	.         'pos_l'
  5256	.       ],
  5257	.       [
  5258	.         'uint64_t',
  5259	.         'pos_h'
  5260	.       ]
  5261	.     ],
  5262	.     'ret' => 'int'
  5263	.   },
  5264	.   'rt_tgsigqueueinfo' => {
  5265	.     'code' => 297,
  5266	.     'name' => 'rt_tgsigqueueinfo',
  5267	.     'impl' => 1,
  5268	.     'args' => [
  5269	.       [
  5270	.         'pid_t',
  5271	.         'tgid'
  5272	.       ],
  5273	.       [
  5274	.         'pid_t',
  5275	.         'pid'
  5276	.       ],
  5277	.       [
  5278	.         'int',
  5279	.         'sig'
  5280	.       ],
  5281	.       [
  5282	.         'siginfo_p',
  5283	.         'uinfo'
  5284	.       ]
  5285	.     ],
  5286	.     'ret' => 'int'
  5287	.   },
  5288	.   'perf_event_open' => {
  5289	.     'code' => 298,
  5290	.     'name' => 'perf_event_open',
  5291	.     'impl' => 1,
  5292	.     'args' => [
  5293	.       [
  5294	.         'perf_event_attr_p',
  5295	.         'attr_uptr'
  5296	.       ],
  5297	.       [
  5298	.         'pid_t',
  5299	.         'pid'
  5300	.       ],
  5301	.       [
  5302	.         'int',
  5303	.         'cpu'
  5304	.       ],
  5305	.       [
  5306	.         'int',
  5307	.         'group_fd'
  5308	.       ],
  5309	.       [
  5310	.         'uint64_t',
  5311	.         'flags'
  5312	.       ]
  5313	.     ],
  5314	.     'ret' => 'int'
  5315	.   },
  5316	.   'recvmmsg' => {
  5317	.     'code' => 299,
  5318	.     'name' => 'recvmmsg',
  5319	.     'impl' => 1,
  5320	.     'args' => [
  5321	.       [
  5322	.         'fd_t',
  5323	.         'fd'
  5324	.       ],
  5325	.       [
  5326	.         'msghdr_p',
  5327	.         'mmsg'
  5328	.       ],
  5329	.       [
  5330	.         'unsigned',
  5331	.         'vlen'
  5332	.       ],
  5333	.       [
  5334	.         'unsigned',
  5335	.         'flags'
  5336	.       ],
  5337	.       [
  5338	.         'timespec_p',
  5339	.         'timeout'
  5340	.       ]
  5341	.     ],
  5342	.     'ret' => 'int'
  5343	.   },
  5344	.   'fanotify_init' => {
  5345	.     'code' => 300,
  5346	.     'name' => 'fanotify_init',
  5347	.     'impl' => 1,
  5348	.     'args' => [
  5349	.       [
  5350	.         'unsigned',
  5351	.         'flags'
  5352	.       ],
  5353	.       [
  5354	.         'unsigned',
  5355	.         'event_f_flags'
  5356	.       ]
  5357	.     ],
  5358	.     'ret' => 'int'
  5359	.   },
  5360	.   'fanotify_mark' => {
  5361	.     'code' => 301,
  5362	.     'name' => 'fanotify_mark',
  5363	.     'impl' => 1,
  5364	.     'args' => [
  5365	.       [
  5366	.         'long',
  5367	.         'fanotify_fd'
  5368	.       ],
  5369	.       [
  5370	.         'long',
  5371	.         'flags'
  5372	.       ],
  5373	.       [
  5374	.         'uint64_t',
  5375	.         'mask'
  5376	.       ],
  5377	.       [
  5378	.         'fd_t',
  5379	.         'dfd'
  5380	.       ],
  5381	.       [
  5382	.         'istr_t',
  5383	.         'path'
  5384	.       ]
  5385	.     ],
  5386	.     'ret' => 'int'
  5387	.   },
  5388	.   'prlimit64' => {
  5389	.     'code' => 302,
  5390	.     'name' => 'prlimit64',
  5391	.     'impl' => 1,
  5392	.     'args' => [
  5393	.       [
  5394	.         'pid_t',
  5395	.         'pid'
  5396	.       ],
  5397	.       [
  5398	.         'unsigned',
  5399	.         'resource'
  5400	.       ],
  5401	.       [
  5402	.         'rlimit64_p',
  5403	.         'new_rlim'
  5404	.       ],
  5405	.       [
  5406	.         'rlimit64_p',
  5407	.         'old_rlim'
  5408	.       ]
  5409	.     ],
  5410	.     'ret' => 'int'
  5411	.   },
  5412	.   'name_to_handle_at' => {
  5413	.     'code' => 303,
  5414	.     'name' => 'name_to_handle_at',
  5415	.     'impl' => 1,
  5416	.     'args' => [
  5417	.       [
  5418	.         'fd_t',
  5419	.         'dfd'
  5420	.       ],
  5421	.       [
  5422	.         'istr_t',
  5423	.         'name'
  5424	.       ],
  5425	.       [
  5426	.         'file_handle_p',
  5427	.         'handle'
  5428	.       ],
  5429	.       [
  5430	.         'int32_p',
  5431	.         'mnt_id'
  5432	.       ],
  5433	.       [
  5434	.         'int',
  5435	.         'flag'
  5436	.       ]
  5437	.     ],
  5438	.     'ret' => 'int'
  5439	.   },
  5440	.   'open_by_handle_at' => {
  5441	.     'code' => 304,
  5442	.     'name' => 'open_by_handle_at',
  5443	.     'impl' => 1,
  5444	.     'args' => [
  5445	.       [
  5446	.         'fd_t',
  5447	.         'dfd'
  5448	.       ],
  5449	.       [
  5450	.         'istr_t',
  5451	.         'name'
  5452	.       ],
  5453	.       [
  5454	.         'file_handle_p',
  5455	.         'handle'
  5456	.       ],
  5457	.       [
  5458	.         'int32_p',
  5459	.         'mnt_id'
  5460	.       ],
  5461	.       [
  5462	.         'int',
  5463	.         'flags'
  5464	.       ]
  5465	.     ],
  5466	.     'ret' => 'int'
  5467	.   },
  5468	.   'clock_adjtime' => {
  5469	.     'code' => 305,
  5470	.     'name' => 'clock_adjtime',
  5471	.     'impl' => 1,
  5472	.     'args' => [
  5473	.       [
  5474	.         'clockid_t',
  5475	.         'which_clock'
  5476	.       ],
  5477	.       [
  5478	.         'timex_p',
  5479	.         'tx'
  5480	.       ]
  5481	.     ],
  5482	.     'ret' => 'int'
  5483	.   },
  5484	.   'syncfs' => {
  5485	.     'code' => 306,
  5486	.     'name' => 'syncfs',
  5487	.     'impl' => 1,
  5488	.     'args' => [
  5489	.       [
  5490	.         'fd_t',
  5491	.         'fd'
  5492	.       ]
  5493	.     ],
  5494	.     'ret' => 'int'
  5495	.   },
  5496	.   'sendmmsg' => {
  5497	.     'code' => 307,
  5498	.     'name' => 'sendmmsg',
  5499	.     'impl' => 1,
  5500	.     'args' => [
  5501	.       [
  5502	.         'fd_t',
  5503	.         'fd'
  5504	.       ],
  5505	.       [
  5506	.         'msghdr_p',
  5507	.         'mmsg'
  5508	.       ],
  5509	.       [
  5510	.         'unsigned',
  5511	.         'vlen'
  5512	.       ],
  5513	.       [
  5514	.         'unsigned',
  5515	.         'flags'
  5516	.       ]
  5517	.     ],
  5518	.     'ret' => 'int'
  5519	.   },
  5520	.   'setns' => {
  5521	.     'code' => 308,
  5522	.     'name' => 'setns',
  5523	.     'impl' => 1,
  5524	.     'args' => [
  5525	.       [
  5526	.         'fd_t',
  5527	.         'fd'
  5528	.       ],
  5529	.       [
  5530	.         'int',
  5531	.         'nstype'
  5532	.       ]
  5533	.     ],
  5534	.     'ret' => 'int'
  5535	.   },
  5536	.   'getcpu' => {
  5537	.     'code' => 309,
  5538	.     'name' => 'getcpu',
  5539	.     'impl' => 1,
  5540	.     'args' => [
  5541	.       [
  5542	.         'uint32_p',
  5543	.         'cpup'
  5544	.       ],
  5545	.       [
  5546	.         'uint32_p',
  5547	.         'nodep'
  5548	.       ]
  5549	.     ],
  5550	.     'ret' => 'int'
  5551	.   },
  5552	.   'process_vm_readv' => {
  5553	.     'code' => 310,
  5554	.     'name' => 'process_vm_readv',
  5555	.     'impl' => 1,
  5556	.     'args' => [
  5557	.       [
  5558	.         'pid_t',
  5559	.         'pid'
  5560	.       ],
  5561	.       [
  5562	.         'iovec_p',
  5563	.         'lvec'
  5564	.       ],
  5565	.       [
  5566	.         'uint64_t',
  5567	.         'liovcnt'
  5568	.       ],
  5569	.       [
  5570	.         'iovec_p',
  5571	.         'rvec'
  5572	.       ],
  5573	.       [
  5574	.         'uint64_t',
  5575	.         'riovcnt'
  5576	.       ],
  5577	.       [
  5578	.         'uint64_t',
  5579	.         'flags'
  5580	.       ]
  5581	.     ],
  5582	.     'ret' => 'int'
  5583	.   },
  5584	.   'process_vm_writev' => {
  5585	.     'code' => 311,
  5586	.     'name' => 'process_vm_writev',
  5587	.     'impl' => 1,
  5588	.     'args' => [
  5589	.       [
  5590	.         'pid_t',
  5591	.         'pid'
  5592	.       ],
  5593	.       [
  5594	.         'iovec_p',
  5595	.         'lvec'
  5596	.       ],
  5597	.       [
  5598	.         'uint64_t',
  5599	.         'liovcnt'
  5600	.       ],
  5601	.       [
  5602	.         'iovec_p',
  5603	.         'rvec'
  5604	.       ],
  5605	.       [
  5606	.         'uint64_t',
  5607	.         'riovcnt'
  5608	.       ],
  5609	.       [
  5610	.         'uint64_t',
  5611	.         'flags'
  5612	.       ]
  5613	.     ],
  5614	.     'ret' => 'int'
  5615	.   },
  5616	.   'kcmp' => {
  5617	.     'code' => 312,
  5618	.     'name' => 'kcmp',
  5619	.     'impl' => 1,
  5620	.     'args' => [
  5621	.       [
  5622	.         'pid_t',
  5623	.         'pid1'
  5624	.       ],
  5625	.       [
  5626	.         'pid_t',
  5627	.         'pid2'
  5628	.       ],
  5629	.       [
  5630	.         'int',
  5631	.         'type'
  5632	.       ],
  5633	.       [
  5634	.         'uint64_t',
  5635	.         'idx1'
  5636	.       ],
  5637	.       [
  5638	.         'uint64_t',
  5639	.         'idx2'
  5640	.       ]
  5641	.     ],
  5642	.     'ret' => 'int'
  5643	.   },
  5644	.   'finit_module' => {
  5645	.     'code' => 313,
  5646	.     'name' => 'finit_module',
  5647	.     'impl' => 1,
  5648	.     'args' => [
  5649	.       [
  5650	.         'fd_t',
  5651	.         'fd'
  5652	.       ],
  5653	.       [
  5654	.         'istr_t',
  5655	.         'uargs'
  5656	.       ],
  5657	.       [
  5658	.         'int',
  5659	.         'flags'
  5660	.       ]
  5661	.     ],
  5662	.     'ret' => 'int'
  5663	.   },
  5664	.   'sched_setattr' => {
  5665	.     'code' => 314,
  5666	.     'name' => 'sched_setattr',
  5667	.     'impl' => 1,
  5668	.     'args' => [
  5669	.       [
  5670	.         'pid_t',
  5671	.         'pid'
  5672	.       ],
  5673	.       [
  5674	.         'sched_attr_p',
  5675	.         'attr'
  5676	.       ],
  5677	.       [
  5678	.         'unsigned',
  5679	.         'flags'
  5680	.       ]
  5681	.     ],
  5682	.     'ret' => 'int'
  5683	.   },
  5684	.   'sched_getattr' => {
  5685	.     'code' => 315,
  5686	.     'name' => 'sched_getattr',
  5687	.     'impl' => 1,
  5688	.     'args' => [
  5689	.       [
  5690	.         'pid_t',
  5691	.         'pid'
  5692	.       ],
  5693	.       [
  5694	.         'sched_attr_p',
  5695	.         'attr'
  5696	.       ],
  5697	.       [
  5698	.         'unsigned',
  5699	.         'size'
  5700	.       ],
  5701	.       [
  5702	.         'unsigned',
  5703	.         'flags'
  5704	.       ]
  5705	.     ],
  5706	.     'ret' => 'int'
  5707	.   },
  5708	.   'renameat2' => {
  5709	.     'code' => 316,
  5710	.     'name' => 'renameat2',
  5711	.     'impl' => 1,
  5712	.     'args' => [
  5713	.       [
  5714	.         'int',
  5715	.         'olddfd'
  5716	.       ],
  5717	.       [
  5718	.         'istr_t',
  5719	.         'opath'
  5720	.       ],
  5721	.       [
  5722	.         'int',
  5723	.         'newdfd'
  5724	.       ],
  5725	.       [
  5726	.         'istr_t',
  5727	.         'npath'
  5728	.       ],
  5729	.       [
  5730	.         'unsigned',
  5731	.         'flags'
  5732	.       ]
  5733	.     ],
  5734	.     'ret' => 'int'
  5735	.   },
  5736	.   'seccomp' => {
  5737	.     'code' => 317,
  5738	.     'name' => 'seccomp',
  5739	.     'impl' => 1,
  5740	.     'args' => [
  5741	.       [
  5742	.         'unsigned',
  5743	.         'op'
  5744	.       ],
  5745	.       [
  5746	.         'unsigned',
  5747	.         'flags'
  5748	.       ],
  5749	.       [
  5750	.         'istr_t',
  5751	.         'uargs'
  5752	.       ]
  5753	.     ],
  5754	.     'ret' => 'int'
  5755	.   },
  5756	.   'getrandom' => {
  5757	.     'code' => 318,
  5758	.     'name' => 'getrandom',
  5759	.     'impl' => 1,
  5760	.     'args' => [
  5761	.       [
  5762	.         'ostr_t',
  5763	.         'buf'
  5764	.       ],
  5765	.       [
  5766	.         'size_t',
  5767	.         'count'
  5768	.       ],
  5769	.       [
  5770	.         'unsigned',
  5771	.         'flags'
  5772	.       ]
  5773	.     ],
  5774	.     'ret' => 'int'
  5775	.   },
  5776	.   'memfd_create' => {
  5777	.     'code' => 319,
  5778	.     'name' => 'memfd_create',
  5779	.     'impl' => 1,
  5780	.     'args' => [
  5781	.       [
  5782	.         'istr_t',
  5783	.         'uname_ptr'
  5784	.       ],
  5785	.       [
  5786	.         'unsigned',
  5787	.         'flags'
  5788	.       ]
  5789	.     ],
  5790	.     'ret' => 'int'
  5791	.   },
  5792	.   'kexec_file_load' => {
  5793	.     'code' => 320,
  5794	.     'name' => 'kexec_file_load',
  5795	.     'impl' => 1,
  5796	.     'args' => [
  5797	.       [
  5798	.         'int',
  5799	.         'kernel_fd'
  5800	.       ],
  5801	.       [
  5802	.         'int',
  5803	.         'initrd_fd'
  5804	.       ],
  5805	.       [
  5806	.         'size_t',
  5807	.         'cmdline_len'
  5808	.       ],
  5809	.       [
  5810	.         'istr_t',
  5811	.         'cmdline_ptr'
  5812	.       ],
  5813	.       [
  5814	.         'uint64_t',
  5815	.         'flags'
  5816	.       ]
  5817	.     ],
  5818	.     'ret' => 'int'
  5819	.   },
  5820	.   'bpf' => {
  5821	.     'code' => 321,
  5822	.     'name' => 'bpf',
  5823	.     'impl' => 1,
  5824	.     'args' => [
  5825	.       [
  5826	.         'int',
  5827	.         'cmd'
  5828	.       ],
  5829	.       [
  5830	.         'bpf_attr_p',
  5831	.         'attr'
  5832	.       ],
  5833	.       [
  5834	.         'unsigned',
  5835	.         'size'
  5836	.       ]
  5837	.     ],
  5838	.     'ret' => 'int'
  5839	.   },
  5840	.   'stub_execveat' => {
  5841	.     'code' => 322,
  5842	.     'name' => 'stub_execveat',
  5843	.     'impl' => 1,
  5844	.     'args' => [
  5845	.       [
  5846	.         'fd_t',
  5847	.         'dfd'
  5848	.       ],
  5849	.       [
  5850	.         'istr_t',
  5851	.         'path'
  5852	.       ],
  5853	.       [
  5854	.         'istr_v',
  5855	.         'argv'
  5856	.       ],
  5857	.       [
  5858	.         'istr_v',
  5859	.         'envp'
  5860	.       ],
  5861	.       [
  5862	.         'int',
  5863	.         'flags'
  5864	.       ]
  5865	.     ],
  5866	.     'ret' => 'int'
  5867	.   },
  5868	.   'userfaultfd' => {
  5869	.     'code' => 323,
  5870	.     'name' => 'userfaultfd',
  5871	.     'impl' => 1,
  5872	.     'args' => [
  5873	.       [
  5874	.         'int',
  5875	.         'flags'
  5876	.       ]
  5877	.     ],
  5878	.     'ret' => 'int'
  5879	.   },
  5880	.   'membarrier' => {
  5881	.     'code' => 324,
  5882	.     'name' => 'membarrier',
  5883	.     'impl' => 1,
  5884	.     'args' => [
  5885	.       [
  5886	.         'int',
  5887	.         'cmd'
  5888	.       ],
  5889	.       [
  5890	.         'int',
  5891	.         'flags'
  5892	.       ]
  5893	.     ],
  5894	.     'ret' => 'int'
  5895	.   },
  5896	.   'mlock2' => {
  5897	.     'code' => 325,
  5898	.     'name' => 'mlock2',
  5899	.     'impl' => 1,
  5900	.     'args' => [
  5901	.       [
  5902	.         'uint64_t',
  5903	.         'start'
  5904	.       ],
  5905	.       [
  5906	.         'size_t',
  5907	.         'len'
  5908	.       ],
  5909	.       [
  5910	.         'int',
  5911	.         'flags'
  5912	.       ]
  5913	.     ],
  5914	.     'ret' => 'int'
  5915	.   },
  5916	.   'copy_file_range' => {
  5917	.     'code' => 326,
  5918	.     'name' => 'copy_file_range',
  5919	.     'impl' => 1,
  5920	.     'args' => [
  5921	.       [
  5922	.         'fd_t',
  5923	.         'fd_in'
  5924	.       ],
  5925	.       [
  5926	.         'off_p',
  5927	.         'off_in'
  5928	.       ],
  5929	.       [
  5930	.         'fd_t',
  5931	.         'fd_out'
  5932	.       ],
  5933	.       [
  5934	.         'off_p',
  5935	.         'off_out'
  5936	.       ],
  5937	.       [
  5938	.         'size_t',
  5939	.         'len'
  5940	.       ],
  5941	.       [
  5942	.         'unsigned',
  5943	.         'flags'
  5944	.       ]
  5945	.     ],
  5946	.     'ret' => 'int'
  5947	.   },
  5948	.   'preadv2' => {
  5949	.     'code' => 327,
  5950	.     'name' => 'preadv2',
  5951	.     'impl' => 1,
  5952	.     'args' => [
  5953	.       [
  5954	.         'fd_t',
  5955	.         'fd'
  5956	.       ],
  5957	.       [
  5958	.         'iovec_p',
  5959	.         'vec'
  5960	.       ],
  5961	.       [
  5962	.         'uint64_t',
  5963	.         'vlen'
  5964	.       ],
  5965	.       [
  5966	.         'uint64_t',
  5967	.         'pos_l'
  5968	.       ],
  5969	.       [
  5970	.         'uint64_t',
  5971	.         'pos_h'
  5972	.       ],
  5973	.       [
  5974	.         'int',
  5975	.         'flags'
  5976	.       ]
  5977	.     ],
  5978	.     'ret' => 'int'
  5979	.   },
  5980	.   'pwritev2' => {
  5981	.     'code' => 328,
  5982	.     'name' => 'pwritev2',
  5983	.     'impl' => 1,
  5984	.     'args' => [
  5985	.       [
  5986	.         'fd_t',
  5987	.         'fd'
  5988	.       ],
  5989	.       [
  5990	.         'iovec_p',
  5991	.         'vec'
  5992	.       ],
  5993	.       [
  5994	.         'uint64_t',
  5995	.         'vlen'
  5996	.       ],
  5997	.       [
  5998	.         'uint64_t',
  5999	.         'pos_l'
  6000	.       ],
  6001	.       [
  6002	.         'uint64_t',
  6003	.         'pos_h'
  6004	.       ],
  6005	.       [
  6006	.         'int',
  6007	.         'flags'
  6008	.       ]
  6009	.     ],
  6010	.     'ret' => 'int'
  6011	.   }
  6012	. );
  6013	. 
FILE: END: sbin/syscall.pl
FILE: START: sbin/vi-bash
HASH: MD5: 8f104ed530ed4962bc31e83e4ad93cf8
     1	. #!/usr/bin/perl
     2	. 
     3	. use strict;
     4	. use feature qw(say);
     5	. use warnings;
     6	. use autodie qw(:all);
     7	. use autodie qw(fork);
     8	. use File::stat;
     9	. use FindBin qw($Bin $Script); 
    10	. use lib "$Bin/../lib/perl";
    11	. use Nobody::PP;
    12	. 
    13	. $|++;
    14	. 
    15	. sub main();
    16	. #print __FILE__, ":", __LINE__, ": starting\n";
    17	. die "usage: $0 [args and script and args ...] ...\n..." unless(@ARGV);
    18	. main();
    19	. 
    20	. use IO::Pipe;
    21	. sub run_child($$);
    22	. sub run_filt($$);
    23	. 
    24	. sub main()
    25	. {
    26	. 
    27	.   my ($pipe1,$pipe2);
    28	.   $pipe1=new IO::Pipe;
    29	.   $pipe2=new IO::Pipe;
    30	.   my ($child_pid, $filt_pid);
    31	.   my ($child_res, $filt_res);
    32	.   my ($child_sig, $filt_sig);
    33	.   if(($child_pid=fork)==0) {
    34	.     exit(run_child($pipe1,$pipe2));
    35	.   } elsif(($filt_pid=fork)==0) {
    36	.     exit(run_filt($pipe1,$pipe2));
    37	.   } else {
    38	.     my $pid;
    39	.     close($pipe1->writer);
    40	.     close($pipe2->writer);
    41	.     while(($pid=wait)!=-1)
    42	.     {
    43	.       if( $pid == $child_pid ) {
    44	.         $child_res=$?/256;
    45	.         $child_sig=$?%256;
    46	.         warn "child done, res=$child_res, sig=$child_sig\n" if ($child_res||$child_sig);
    47	.       } elsif( $pid == $filt_pid ) {
    48	.         $filt_res=$?/256;
    49	.         $filt_sig=$?%256;
    50	.         warn "filter done, res=$filt_res, sig=$filt_sig\n" if ($filt_res||$filt_sig);
    51	.       } else {
    52	.         die "unknown pid: $pid (\$?=$?)\n";
    53	.       };
    54	.     };
    55	.     if($child_sig||$filt_sig){
    56	.       exit(255);
    57	.     } else {
    58	.       exit($child_res|$filt_res);
    59	.     };
    60	.   };
    61	.   die "wtf?";
    62	. 
    63	. };
    64	. 
    65	. sub run_child($$) {
    66	.   for(sort keys %SIG){
    67	.     $SIG{$_}='IGNORE';
    68	.   };
    69	.   my ($out,$err) = splice(@_);
    70	.   open(STDOUT,">&".fileno($out->writer)) or die;
    71	.   close($out);
    72	.   open(STDERR,">&".fileno($err->writer)) or die;
    73	.   close($err);
    74	.   exec "bash", @ARGV;
    75	.   die "failed!";
    76	. };
    77	. sub run_filt($$)
    78	. {
    79	.   my $out_buf="";
    80	.   my $err_buf="";
    81	.   my $sel;
    82	.   {
    83	.     my ($out,$err) = splice(@_);
    84	.     open(STDIN,"</dev/null");
    85	.     use IO::Select;
    86	.     $sel = new IO::Select;
    87	.     $sel->add( [ $out->reader(), \$out_buf, 0 ] );
    88	.     $sel->add( [ $err->reader(), \$err_buf, 1 ] );
    89	.   }
    90	.   my $last=0;
    91	.   while($sel->handles){
    92	.     my @can=$sel->can_read;
    93	.     for(@can)
    94	.     {
    95	.       my ($pipe,$ref,$err);
    96	.       ( $pipe, $ref, $err ) = @$_;
    97	.       local (*_)=$ref;
    98	.       my $res=sysread($pipe,$_,1,length);
    99	.       if(!defined($res)) {
   100	.         die "sysread:$!";
   101	.       } elsif ( !$res ) {
   102	.         $sel->remove($pipe);
   103	.         close($pipe) or die "close:$!";
   104	.         $last=1 if length($$ref);
   105	.       };
   106	.       my $nl=chomp($_)?"\n":"";
   107	.       next unless ($last || length($nl));
   108	.       if(!$err) {
   109	.         print STDOUT "O:$_$nl";
   110	.         $_="";
   111	.         next;
   112	.       } else {
   113	.         print STDERR "E:$_$nl";
   114	.         $_="";
   115	.         next;
   116	.       };
   117	.     };
   118	.   };
   119	.   exit(0);
   120	. };
FILE: END: sbin/vi-bash
